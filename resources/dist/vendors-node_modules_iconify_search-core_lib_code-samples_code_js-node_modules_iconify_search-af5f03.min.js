"use strict";
(self["webpackChunkgameplay_blocks"] = self["webpackChunkgameplay_blocks"] || []).push([["vendors-node_modules_iconify_search-core_lib_code-samples_code_js-node_modules_iconify_search-af5f03"],{

/***/ "./node_modules/@iconify/search-core/lib/api/base.js":
/*!***********************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/api/base.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.searchCacheKey = exports.collectionCacheKey = exports.collectionsCacheKey = exports.BaseAPI = exports.mergeQuery = void 0;
const providers_1 = __webpack_require__(/*! ../data/providers */ "./node_modules/@iconify/search-core/lib/data/providers.js");
/**
 * Add parameters to query
 */
function mergeQuery(base, params) {
    let result = base, hasParams = result.indexOf('?') !== -1;
    /**
     * Convertion of parameters to string, only allows simple types used by Iconify API
     */
    function paramToString(value, nested) {
        switch (typeof value) {
            case 'boolean':
                if (nested) {
                    throw new Error('Nested boolean items are not allowed');
                }
                return value ? 'true' : 'false';
            case 'number':
                return encodeURIComponent(value);
            case 'string':
                return encodeURIComponent(value);
            case 'object':
                if (nested) {
                    throw new Error('Nested objects are not allowed');
                }
                if (value instanceof Array) {
                    return value
                        .map((item) => paramToString(item, true))
                        .join(',');
                }
                throw new Error('Objects are not allowed');
            default:
                throw new Error('Invalid type');
        }
    }
    Object.keys(params).forEach((key) => {
        let value;
        try {
            value = paramToString(params[key], false);
        }
        catch (err) {
            return;
        }
        result +=
            (hasParams ? '&' : '?') + encodeURIComponent(key) + '=' + value;
        hasParams = true;
    });
    return result;
}
exports.mergeQuery = mergeQuery;
/**
 * Base API class
 */
class BaseAPI {
    /**
     * Constructor
     *
     * @param registry
     */
    constructor(registry) {
        // Provider specific cache
        this._cache = Object.create(null);
        this._registry = registry;
        this._query = this._query.bind(this);
    }
    /**
     * Send query
     *
     * @param provider Provider
     * @param endpoint End point string
     * @param params Query parameters as object
     * @param callback Callback to call when data is available
     * @param cacheKey Key to store provider specific cache, true if key should be generated, false if cache should be ignored
     */
    query(provider, endpoint, params, callback, cacheKey = true) {
        const uri = mergeQuery(endpoint, params);
        const cacheKeyStr = typeof cacheKey === 'string' ? cacheKey : uri;
        // Check for cache
        if (this._cache[provider] === void 0) {
            this._cache[provider] = Object.create(null);
        }
        const providerCache = this._cache[provider];
        if (cacheKey !== false && providerCache[cacheKeyStr] !== void 0) {
            // Return cached data
            const cached = providerCache[cacheKeyStr];
            callback(cached === null ? null : JSON.parse(cached), void 0, true);
            return;
        }
        // Init redundancy
        const redundancy = this._getRedundancy(provider);
        if (!redundancy) {
            // Error
            callback(null, false);
            return;
        }
        // Send query
        const query = redundancy.find((item) => {
            const status = item();
            return status.status === 'pending' && status.payload === uri;
        });
        if (query !== null) {
            // Attach callback to existing query
            query().subscribe((data, error) => {
                callback(data, error, false);
            });
            return;
        }
        // Create new query
        redundancy.query(uri, this._query.bind(this, provider, cacheKey === false ? null : cacheKeyStr), (data, error) => {
            callback(data, error, false);
        });
    }
    /**
     * Check if query is cached
     */
    isCached(provider, endpoint, params) {
        const uri = mergeQuery(endpoint, params);
        return (this._cache[provider] !== void 0 &&
            this._cache[provider][uri] !== void 0);
    }
    /**
     * Check if query is pending
     */
    isPending(provider, endpoint, params) {
        // Init redundancy
        const redundancy = this._getRedundancy(provider);
        if (!redundancy) {
            // Error
            return false;
        }
        const uri = mergeQuery(endpoint, params);
        const query = redundancy.find((item) => {
            const status = item();
            return status.status === 'pending' && status.payload === uri;
        });
        return query !== null;
    }
    /**
     * Send query, callback from Redundancy
     */
    _query(provider, cacheKey, host, params, item) {
        // Should be implemented by child classes
        throw new Error('_query() should not be called on base API class');
    }
    /**
     * Store cached data
     */
    storeCache(provider, cacheKey, data) {
        if (this._cache[provider] === void 0) {
            this._cache[provider] = Object.create(null);
        }
        this._cache[provider][cacheKey] =
            data === null ? null : JSON.stringify(data);
    }
    /**
     * Clear all cache
     */
    clearCache() {
        this._cache = Object.create(null);
    }
    /**
     * Get Redundancy instance
     */
    _getRedundancy(provider) {
        // Init redundancy
        const providerData = providers_1.getProvider(provider);
        if (!providerData) {
            // Error
            return null;
        }
        return providerData.redundancy;
    }
}
exports.BaseAPI = BaseAPI;
/**
 * Various cache keys
 */
function collectionsCacheKey() {
    return 'collections';
}
exports.collectionsCacheKey = collectionsCacheKey;
function collectionCacheKey(prefix) {
    return 'collection.' + prefix;
}
exports.collectionCacheKey = collectionCacheKey;
function searchCacheKey(query, limit) {
    return 'search.' + query + '.' + limit;
}
exports.searchCacheKey = searchCacheKey;
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/api/fetch.js":
/*!************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/api/fetch.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.API = exports.setFetch = void 0;
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@iconify/search-core/lib/api/base.js");
/**
 * Fetch function
 *
 * Use this to set 'cross-fetch' in node.js environment if you are retrieving icons on server side.
 * Not needed when using stuff like Next.js or SvelteKit because components use API only on client side.
 */
let fetchModule = null;
try {
    fetchModule = fetch;
}
catch (err) {
    //
}
function setFetch(fetch) {
    fetchModule = fetch;
}
exports.setFetch = setFetch;
/**
 * API class
 */
class API extends base_1.BaseAPI {
    /**
     * Send API query without provider
     *
     * @param host Host string
     * @param params End point and parameters as string
     * @param callback Callback
     */
    sendQuery(host, params, callback) {
        if (!fetchModule) {
            // Fail: return 424 Failed Dependency (its not meant to be used like that, but it is the best match)
            callback(void 0, 424);
            return;
        }
        fetchModule(host + params)
            .then((response) => {
            if (response.status !== 200) {
                callback(void 0, response.status);
                return;
            }
            return response.json();
        })
            .then((data) => {
            if (data === void 0) {
                // Return from previous then() without Promise
                return;
            }
            if (typeof data !== 'object' || data === null) {
                // Error
                callback(void 0, null);
                return;
            }
            // Store cache and complete
            callback(data);
        })
            .catch((err) => {
            callback(void 0, err === null || err === void 0 ? void 0 : err.errno);
        });
    }
    /**
     * Send query, callback from Redundancy
     *
     * @param provider Provider string
     * @param cacheKey API cache key, null if data should not be cached
     * @param host Host string
     * @param params End point and parameters as string
     * @param item Query item
     */
    _query(provider, cacheKey, host, params, item) {
        // console.log('API request: ' + host + params);
        this.sendQuery(host, params, (data, error) => {
            if (data !== void 0 && cacheKey !== null) {
                // Store cache on success
                this.storeCache(provider, cacheKey, data);
            }
            item.done(data, error);
        });
    }
}
exports.API = API;
//# sourceMappingURL=fetch.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/blocks/collection-info.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/blocks/collection-info.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCollectionInfoBlockEmpty = exports.defaultCollectionInfoBlock = void 0;
/**
 * Default block values
 */
const defaultCollectionInfoBlock = () => {
    return {
        type: 'collection-info',
        prefix: '',
        info: null,
    };
};
exports.defaultCollectionInfoBlock = defaultCollectionInfoBlock;
/**
 * Check if block is empty
 */
function isCollectionInfoBlockEmpty(block) {
    return block === void 0 || block === null || block.info === null;
}
exports.isCollectionInfoBlockEmpty = isCollectionInfoBlockEmpty;
//# sourceMappingURL=collection-info.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/blocks/collections-filter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/blocks/collections-filter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCollectionsFilterBlockEmpty = exports.defaultCollectionsFilterBlock = void 0;
/**
 * Default block values
 */
const defaultCollectionsFilterBlock = () => {
    return {
        type: 'collections-filter',
        keyword: '',
    };
};
exports.defaultCollectionsFilterBlock = defaultCollectionsFilterBlock;
/**
 * Check if block is empty
 */
function isCollectionsFilterBlockEmpty(block) {
    return block === void 0 || block === null || block.keyword.trim() === '';
}
exports.isCollectionsFilterBlockEmpty = isCollectionsFilterBlockEmpty;
//# sourceMappingURL=collections-filter.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/blocks/collections-list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/blocks/collections-list.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applyCollectionsFilter = exports.disableInactiveCategories = exports.filterCollectionsBlock = exports.iterateCollectionsBlock = exports.collectionsPrefixesWithInfo = exports.getCollectionsBlockPrefixes = exports.getCollectionsBlockCategories = exports.isCollectionsBlockEmpty = exports.defaultCollectionsListBlock = void 0;
const collections_1 = __webpack_require__(/*! ../converters/collections */ "./node_modules/@iconify/search-core/lib/converters/collections.js");
const filters_1 = __webpack_require__(/*! ./filters */ "./node_modules/@iconify/search-core/lib/blocks/filters.js");
const objects_1 = __webpack_require__(/*! ../misc/objects */ "./node_modules/@iconify/search-core/lib/misc/objects.js");
/**
 * Default values
 */
const defaultCollectionsListBlock = () => {
    return {
        type: 'collections-list',
        showCategories: true,
        collections: Object.create(null),
    };
};
exports.defaultCollectionsListBlock = defaultCollectionsListBlock;
/**
 * Check if block is empty
 */
function isCollectionsBlockEmpty(block) {
    if (block === void 0 || block === null) {
        return true;
    }
    const categories = Object.keys(block.collections);
    for (let i = 0; i < categories.length; i++) {
        if (Object.keys(block.collections[categories[i]]).length > 0) {
            return false;
        }
    }
    return true;
}
exports.isCollectionsBlockEmpty = isCollectionsBlockEmpty;
/**
 * Get categories
 */
function getCollectionsBlockCategories(block, ignoreEmpty = false) {
    let categories = Object.keys(block.collections);
    if (ignoreEmpty) {
        categories = categories.filter((category) => Object.keys(block.collections[category]).length > 0);
    }
    return categories;
}
exports.getCollectionsBlockCategories = getCollectionsBlockCategories;
/**
 * Get all prefixes
 */
function getCollectionsBlockPrefixes(block) {
    return collections_1.collectionsPrefixes(block.collections);
}
exports.getCollectionsBlockPrefixes = getCollectionsBlockPrefixes;
/**
 * Get all collections info as array
 */
function collectionsPrefixesWithInfo(block) {
    const info = [];
    Object.keys(block.collections).forEach((category) => {
        const items = block.collections[category];
        Object.keys(items).forEach((prefix) => {
            if (items[prefix] !== null) {
                info.push(items[prefix]);
            }
        });
    });
    return info;
}
exports.collectionsPrefixesWithInfo = collectionsPrefixesWithInfo;
/**
 * Iterate collections block
 */
function iterateCollectionsBlock(block, callback) {
    Object.keys(block.collections).forEach((category) => {
        const items = block.collections[category];
        Object.keys(items).forEach((prefix) => {
            callback(items[prefix], prefix, category);
        });
    });
}
exports.iterateCollectionsBlock = iterateCollectionsBlock;
/**
 * Filter collections list (creates new block)
 */
function filterCollectionsBlock(block, callback, keepEmptyCategories = false) {
    const result = {
        type: 'collections-list',
        showCategories: block.showCategories,
        collections: collections_1.filterCollections(block.collections, callback, keepEmptyCategories),
    };
    return result;
}
exports.filterCollectionsBlock = filterCollectionsBlock;
/**
 * Remove all inactive categories
 */
function disableInactiveCategories(block, category) {
    if (category === null) {
        return block;
    }
    const result = {
        type: 'collections-list',
        showCategories: block.showCategories,
        collections: Object.create(null),
    };
    if (block.collections[category] !== void 0) {
        result.collections[category] = block.collections[category];
    }
    return result;
}
exports.disableInactiveCategories = disableInactiveCategories;
/**
 * List of keys to apply filter to
 */
const filterKeys = [
    'prefix',
    'name',
    'author',
    'license',
    'category',
    'palette',
    'height',
];
/**
 * Apply filter to collections list and to collections filters
 */
function applyCollectionsFilter(block, filter, filters) {
    const keyword = filter.keyword.trim();
    const hasFilters = filters !== null && filters.filterType === 'categories';
    const filtersList = filters;
    if (keyword === '') {
        // Empty
        if (hasFilters) {
            // Enable all filters
            filters_1.enableFilters(filtersList, true);
        }
        return block;
    }
    // Disable all filters, will re-enable them again during filter process
    const activeCategories = {};
    if (hasFilters) {
        filters_1.enableFilters(filtersList, false);
    }
    // Filter collections block
    return filterCollectionsBlock(block, (item, category) => {
        for (let i = filterKeys.length - 1; i >= 0; i--) {
            // Get key
            const key = filterKeys[i];
            if (item[key] === void 0) {
                continue;
            }
            // Test value
            if (objects_1.match(item[key], keyword)) {
                // Enable category in category filters
                if (hasFilters) {
                    if (activeCategories[category] !== true) {
                        activeCategories[category] = true;
                        if (filtersList.filters[category] !== void 0) {
                            filtersList.filters[category].disabled = false;
                        }
                    }
                }
                return true;
            }
        }
        return false;
    }, false);
}
exports.applyCollectionsFilter = applyCollectionsFilter;
//# sourceMappingURL=collections-list.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/blocks/filters.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/blocks/filters.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.autoIndexFilters = exports.enableFilters = exports.isFiltersBlockEmpty = exports.defaultFiltersBlock = exports.defaultFilter = void 0;
/**
 * Default values for filter
 */
const defaultFilter = (title) => {
    return {
        title,
        index: 0,
        disabled: false,
    };
};
exports.defaultFilter = defaultFilter;
/**
 * Default value
 */
const defaultFiltersBlock = () => {
    return {
        type: 'filters',
        filterType: '',
        active: null,
        filters: Object.create(null),
    };
};
exports.defaultFiltersBlock = defaultFiltersBlock;
/**
 * Check if block is empty
 */
function isFiltersBlockEmpty(block) {
    return (block === void 0 ||
        block === null ||
        Object.keys(block.filters).length < 2);
}
exports.isFiltersBlockEmpty = isFiltersBlockEmpty;
/**
 * Enable or disable all filters in block
 */
function enableFilters(block, enable = true) {
    Object.keys(block.filters).forEach((filter) => {
        block.filters[filter].disabled = !enable;
    });
}
exports.enableFilters = enableFilters;
/**
 * Set indexes to all filters
 *
 * Returns next start index to chain index multiple sets of filters
 */
function autoIndexFilters(block, start = 0) {
    let index = start;
    Object.keys(block.filters).forEach((filter) => {
        block.filters[filter].index = index++;
    });
    return index;
}
exports.autoIndexFilters = autoIndexFilters;
//# sourceMappingURL=filters.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/blocks/icons-list.js":
/*!********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/blocks/icons-list.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applyIconFilters = exports.isIconsListBlockEmpty = exports.defaultIconsListBlock = void 0;
const filters_1 = __webpack_require__(/*! ./filters */ "./node_modules/@iconify/search-core/lib/blocks/filters.js");
/**
 * Default block values
 */
const defaultIconsListBlock = () => {
    return {
        type: 'icons-list',
        icons: [],
    };
};
exports.defaultIconsListBlock = defaultIconsListBlock;
/**
 * Check if block is empty
 */
function isIconsListBlockEmpty(block) {
    return block === void 0 || block === null || block.icons.length < 1;
}
exports.isIconsListBlockEmpty = isIconsListBlockEmpty;
/**
 * Icon attributes to search
 */
const searchableIconAttributes = ['name', 'chars', 'aliases'];
const searchableIconAttributesWithPrefixes = [
    'prefix',
    'name',
    'chars',
    'aliases',
];
/**
 * Apply filters to icons list
 */
function applyIconFilters(block, search, filters = [], searchPrefixes = false) {
    let icons = block.icons.slice(0);
    const searchableAttributes = searchPrefixes
        ? searchableIconAttributesWithPrefixes
        : searchableIconAttributes;
    // Get Icon attribute matching filter (legacy from when attributes didn't match, but kept in case things change again)
    function iconAttr(key) {
        return key;
    }
    // Search
    const keyword = search ? search.keyword.trim() : '';
    if (keyword !== '') {
        // Find all icons that match keyword
        const keywords = keyword
            .toLowerCase()
            .split(/[\s:]/)
            .map((keyword) => keyword.trim())
            .filter((keyword) => keyword.length > 0);
        if (keywords.length) {
            const searches = searchableAttributes.slice(0);
            keywords.forEach((keyword) => {
                let exclude = false;
                if (keyword.slice(0, 1) === '-') {
                    exclude = true;
                    keyword = keyword.slice(1);
                    if (!keyword.length) {
                        return;
                    }
                }
                icons = icons.filter((item) => {
                    const icon = item;
                    let match = false;
                    searches.forEach((attr) => {
                        if (match || icon[attr] === void 0) {
                            return;
                        }
                        if (typeof icon[attr] === 'string') {
                            match =
                                icon[attr].indexOf(keyword) !== -1;
                            return;
                        }
                        if (icon[attr] instanceof Array) {
                            icon[attr].forEach((value) => {
                                match = match || value.indexOf(keyword) !== -1;
                            });
                        }
                    });
                    return exclude ? !match : match;
                });
            });
        }
    }
    // Toggle filter visibility
    const isSearched = icons.length !== block.icons.length;
    filters.forEach((filter) => {
        filters_1.enableFilters(filter, true);
        if (!isSearched) {
            return;
        }
        const attr = iconAttr(filter.filterType);
        if (attr === null) {
            return;
        }
        Object.keys(filter.filters).forEach((match) => {
            for (let i = icons.length - 1; i >= 0; i--) {
                const value = icons[i][attr];
                if (value === void 0 || value === null) {
                    continue;
                }
                if (typeof value === 'string') {
                    if (value === match) {
                        return;
                    }
                    continue;
                }
                if (value instanceof Array && value.indexOf(match) !== -1) {
                    return;
                }
            }
            // No matches
            filter.filters[match].disabled = true;
        });
    });
    // Apply filters
    filters.forEach((filter) => {
        if (filter.active === null) {
            return;
        }
        const match = filter.active;
        const attr = iconAttr(filter.filterType);
        if (attr === null) {
            return;
        }
        icons = icons.filter((icon) => {
            const value = icon[attr];
            if (value === void 0 || value === null) {
                return false;
            }
            if (typeof value === 'string') {
                return value === match;
            }
            if (value instanceof Array) {
                return value.indexOf(match) !== -1;
            }
            return false;
        });
    });
    block.icons = icons;
}
exports.applyIconFilters = applyIconFilters;
//# sourceMappingURL=icons-list.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/blocks/pagination.js":
/*!********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/blocks/pagination.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showPagination = exports.getPageForIndex = exports.maxPage = exports.isPaginationEmpty = exports.defaultPaginationBlock = void 0;
/**
 * Default values
 */
const defaultPaginationBlock = () => {
    return {
        type: 'pagination',
        page: 0,
        length: 0,
        perPage: 24,
        more: false,
    };
};
exports.defaultPaginationBlock = defaultPaginationBlock;
/**
 * Check if pagination is empty
 */
function isPaginationEmpty(block) {
    return block === void 0 || block === null || block.length <= block.perPage;
}
exports.isPaginationEmpty = isPaginationEmpty;
/**
 * Get maximum page number
 */
function maxPage(block) {
    return block.perPage && block.length > 0
        ? Math.floor((block.length - 1) / block.perPage)
        : 0;
}
exports.maxPage = maxPage;
/**
 * Calculate page where item at index "index" is located
 */
function getPageForIndex(perPage, index) {
    return perPage && index > 0 ? Math.floor(index / perPage) : 0;
}
exports.getPageForIndex = getPageForIndex;
/**
 * Get list of pages to show
 */
function showPagination(block) {
    const total = block.length ? maxPage(block) + 1 : 0;
    const pagination = [];
    let i, min;
    // Less than 2 pages
    if (total < 2) {
        return pagination;
    }
    // Show all pages
    // 3 first + total+-2 + 3 last + 2 spacers = 13
    if (total < 14) {
        for (i = 0; i < total; i++) {
            pagination.push(i);
        }
        return pagination;
    }
    // First 3 pages
    for (i = 0; i < Math.min(total, 3); i++) {
        pagination.push(i);
    }
    if ((min = i) >= total) {
        return pagination;
    }
    // Current +- 2 (or - 3 if only 1 page is skipped)
    for (i = min === block.page - 3 ? min : Math.max(block.page - 2, min); i < Math.min(block.page + 3, total); i++) {
        pagination.push(i);
    }
    if ((min = i) >= total) {
        return pagination;
    }
    // Last 3 (or 4 if only 1 page is skipped)
    for (i = min === total - 4 ? total - 4 : Math.max(total - 3, min); i < total; i++) {
        pagination.push(i);
    }
    return pagination;
}
exports.showPagination = showPagination;
//# sourceMappingURL=pagination.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/blocks/search.js":
/*!****************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/blocks/search.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSearchBlockEmpty = exports.defaultSearchBlock = void 0;
/**
 * Default block values
 */
const defaultSearchBlock = () => {
    return {
        type: 'search',
        keyword: '',
    };
};
exports.defaultSearchBlock = defaultSearchBlock;
/**
 * Check if block is empty
 */
function isSearchBlockEmpty(block) {
    return block === void 0 || block === null || block.keyword.trim() === '';
}
exports.isSearchBlockEmpty = isSearchBlockEmpty;
//# sourceMappingURL=search.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/blocks/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/blocks/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBlockEmpty = void 0;
const collection_info_1 = __webpack_require__(/*! ./collection-info */ "./node_modules/@iconify/search-core/lib/blocks/collection-info.js");
const collections_filter_1 = __webpack_require__(/*! ./collections-filter */ "./node_modules/@iconify/search-core/lib/blocks/collections-filter.js");
const collections_list_1 = __webpack_require__(/*! ./collections-list */ "./node_modules/@iconify/search-core/lib/blocks/collections-list.js");
const filters_1 = __webpack_require__(/*! ./filters */ "./node_modules/@iconify/search-core/lib/blocks/filters.js");
const icons_list_1 = __webpack_require__(/*! ./icons-list */ "./node_modules/@iconify/search-core/lib/blocks/icons-list.js");
const pagination_1 = __webpack_require__(/*! ./pagination */ "./node_modules/@iconify/search-core/lib/blocks/pagination.js");
const search_1 = __webpack_require__(/*! ./search */ "./node_modules/@iconify/search-core/lib/blocks/search.js");
/**
 * TypeScript guard
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function
function assertNever(s) { }
/**
 * Check if block is empty
 */
function isBlockEmpty(block) {
    if (block === void 0 || block === null) {
        return true;
    }
    const type = block.type;
    switch (type) {
        case 'collection-info':
            return collection_info_1.isCollectionInfoBlockEmpty(block);
        case 'collections-filter':
            return collections_filter_1.isCollectionsFilterBlockEmpty(block);
        case 'collections-list':
            return collections_list_1.isCollectionsBlockEmpty(block);
        case 'filters':
            return filters_1.isFiltersBlockEmpty(block);
        case 'icons-list':
            return icons_list_1.isIconsListBlockEmpty(block);
        case 'pagination':
            return pagination_1.isPaginationEmpty(block);
        case 'search':
            return search_1.isSearchBlockEmpty(block);
        default:
            assertNever(type);
            return true;
    }
}
exports.isBlockEmpty = isBlockEmpty;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/code.js":
/*!********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/code.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIconCode = exports.codeOutputComponentKeys = void 0;
const css_1 = __webpack_require__(/*! ./parsers/css */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/css.js");
const ember_1 = __webpack_require__(/*! ./parsers/ember */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/ember.js");
const react_1 = __webpack_require__(/*! ./parsers/react */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/react.js");
const svelte_1 = __webpack_require__(/*! ./parsers/svelte */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/svelte.js");
const svg_1 = __webpack_require__(/*! ./parsers/svg */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/svg.js");
const svg_framework_1 = __webpack_require__(/*! ./parsers/svg-framework */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/svg-framework.js");
const vue_1 = __webpack_require__(/*! ./parsers/vue */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/vue.js");
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental
function assertNever(v) {
    //
}
/**
 * Output
 */
exports.codeOutputComponentKeys = [
    'install-simple',
    'install-addon',
    'install-offline',
    'import-simple',
    'import-offline',
    'vue-simple',
    'vue-offline',
    // Usage
    'use-in-code',
    'use-in-template',
    'use-in-html',
    'use-generic',
];
/**
 * Get code for icon
 */
function getIconCode(lang, icon, customisations, providerConfig) {
    let parser;
    switch (lang) {
        // SVG Framework
        case 'iconify':
            parser = svg_framework_1.svgFrameworkParser;
            break;
        // CSS
        case 'css':
            parser = css_1.cssParser;
            break;
        // React
        case 'react-api':
            parser = react_1.reactParser;
            break;
        case 'react-offline':
            parser = react_1.reactOfflineParser;
            break;
        // Vue
        case 'vue2-api':
            parser = vue_1.vueParser.bind(null, false);
            break;
        case 'vue2-offline':
            parser = vue_1.vueOfflineParser.bind(null, false);
            break;
        case 'vue3-api':
            parser = vue_1.vueParser.bind(null, true);
            break;
        case 'vue3-offline':
            parser = vue_1.vueOfflineParser.bind(null, true);
            break;
        // Svelte
        case 'svelte-api':
            parser = svelte_1.svelteParser;
            break;
        case 'svelte-offline':
            parser = svelte_1.svelteOfflineParser;
            break;
        // Ember
        case 'ember':
            parser = ember_1.emberParser;
            break;
        // SVG
        case 'svg-box':
        case 'svg-raw':
        case 'svg-uri':
            parser = svg_1.svgParser.bind(null, lang);
            break;
        default:
            assertNever(lang);
            return null;
    }
    return parser(icon, customisations, providerConfig);
}
exports.getIconCode = getIconCode;
//# sourceMappingURL=code.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/html.js":
/*!********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.renderHTML = void 0;
const build_1 = __webpack_require__(/*! @iconify/utils/lib/svg/build */ "./node_modules/@iconify/utils/lib/svg/build.js");
function renderHTML(icon, customisations, className) {
    const buildResult = build_1.iconToSVG(icon, customisations);
    // Style
    const style = [];
    if (customisations.inline) {
        style.push('vertical-align: -0.125em');
    }
    /*
    if (customisations.color !== '') {
        style.push('color: ' + customisations.color);
    }
    */
    const customAttributes = {};
    if (typeof className === 'string' && className !== '') {
        customAttributes['class'] = className;
    }
    if (style.length) {
        customAttributes['style'] = style.join('; ') + ';';
    }
    // Generate SVG attributes
    const attributes = {
        // Default SVG stuff
        'xmlns': 'http://www.w3.org/2000/svg',
        'xmlns:xlink': 'http://www.w3.org/1999/xlink',
        'aria-hidden': 'true',
        'role': 'img',
        // Custom attributes
        ...customAttributes,
        // Attributes from build result
        ...buildResult.attributes,
    };
    // Replace color inside SVG
    let body = buildResult.body;
    if (customisations.color !== '') {
        body = body.replace(/currentColor/g, customisations.color);
    }
    // Generate HTML
    return ('<svg ' +
        Object.keys(attributes)
            .map((key) => {
            // There should be no quotes in content, so nothing to encode
            return key + '="' + attributes[key] + '"';
        })
            .join(' ') +
        '>' +
        body +
        '</svg>');
}
exports.renderHTML = renderHTML;
//# sourceMappingURL=html.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeAttributes = exports.mergeAttr = exports.addEmberAttr = exports.addVueAttr = exports.addReactAttr = exports.addDynamicAttr = exports.addAttr = exports.npmIconImport = exports.getCustomisationsList = exports.docsBase = exports.getCustomisationAttributes = exports.toString = exports.degrees = exports.isNumber = exports.iconToVarName = void 0;
const customisations_1 = __webpack_require__(/*! ../../misc/customisations */ "./node_modules/@iconify/search-core/lib/misc/customisations.js");
/**
 * Convert icon name to variable
 */
function iconToVarName(iconName) {
    let name = '';
    const parts = iconName.split('-');
    parts.forEach((part, index) => {
        name += index ? part.slice(0, 1).toUpperCase() + part.slice(1) : part;
    });
    if (name.charCodeAt(0) < 97 || name.charCodeAt(0) > 122) {
        // Not a-z - add "icon" at start
        name = 'icon' + name.slice(0, 1).toUpperCase() + name.slice(1);
    }
    else if (parts.length < 2) {
        // Add "Icon" to avoid reserved keywords
        name += 'Icon';
    }
    return name;
}
exports.iconToVarName = iconToVarName;
/**
 * Check if string contains units
 */
function isNumber(value) {
    return typeof value === 'number'
        ? true
        : typeof value === 'string'
            ? !!value.match(/^-?[0-9.]+$/)
            : false;
}
exports.isNumber = isNumber;
/**
 * Convert number to degrees string
 */
function degrees(value) {
    return value * 90 + 'deg';
}
exports.degrees = degrees;
/**
 * Convert value to string
 */
function toString(value) {
    switch (typeof value) {
        case 'number':
            return value + '';
        case 'string':
            return value;
        default:
            return JSON.stringify(value);
    }
}
exports.toString = toString;
/**
 * List of attributes
 */
const baseCustomisationAttributes = [
    'width',
    'height',
    'rotate',
    'hFlip',
    'vFlip',
    'hAlign',
    'vAlign',
    'slice',
];
function getCustomisationAttributes(color, inline) {
    const results = baseCustomisationAttributes.slice(0);
    if (color) {
        results.push('color');
    }
    if (inline) {
        results.push('inline');
    }
    return results;
}
exports.getCustomisationAttributes = getCustomisationAttributes;
/**
 * Documentation
 */
exports.docsBase = 'https://docs.iconify.design/icon-components/';
function getCustomisationsList(customisations) {
    const results = new Set();
    // Add color
    if (customisations.color !== '') {
        results.add('color');
    }
    // Add dimensions
    const width = customisations.width;
    const hasWidth = width !== null && width !== '';
    const height = customisations.height;
    const hasHeight = height !== null && height !== '';
    if (hasWidth) {
        results.add('width');
    }
    if (hasHeight) {
        results.add(hasWidth || height === 'auto' ? 'height' : 'onlyHeight');
    }
    // Transformations and alignment
    ['rotate', 'hFlip', 'vFlip', 'hAlign', 'vAlign', 'slice'].forEach((prop) => {
        const key = prop;
        const value = customisations[key];
        if (value !== void 0 && value !== customisations_1.emptyCustomisations[key]) {
            results.add(key);
        }
    });
    // Inline
    if (customisations.inline) {
        results.add('inline');
    }
    return results;
}
exports.getCustomisationsList = getCustomisationsList;
function npmIconImport(icon, name, providerConfig, preferES) {
    const npm = preferES
        ? providerConfig.npmES
            ? providerConfig.npmES
            : providerConfig.npmCJS
        : providerConfig.npmCJS
            ? providerConfig.npmCJS
            : providerConfig.npmES;
    if (!npm) {
        return null;
    }
    const packageName = typeof npm.package === 'string'
        ? npm.package.replace('{prefix}', icon.prefix)
        : typeof npm.package === 'function'
            ? npm.package(providerConfig, icon)
            : null;
    if (typeof packageName !== 'string') {
        return null;
    }
    const file = typeof npm.file === 'string'
        ? npm.file.replace('{name}', icon.name)
        : typeof npm.file === 'function'
            ? npm.file(providerConfig, icon)
            : null;
    if (typeof file !== 'string') {
        return null;
    }
    const code = 'import ' + name + " from '" + packageName + file + "';";
    return {
        name,
        package: packageName,
        file,
        code,
    };
}
exports.npmIconImport = npmIconImport;
function addAttr(list, key, value) {
    list[key] = {
        key,
        value,
    };
}
exports.addAttr = addAttr;
function addDynamicAttr(list, key, anyValue, syntax) {
    let value;
    switch (typeof anyValue) {
        case 'boolean':
            value = anyValue ? 'true' : 'false';
            break;
        case 'object':
            value = JSON.stringify(anyValue);
            break;
        default:
            value = anyValue;
    }
    list[key] = {
        key,
        value,
        syntax,
    };
}
exports.addDynamicAttr = addDynamicAttr;
function addReactAttr(list, key, value) {
    if (typeof value === 'string' && key !== 'icon') {
        addAttr(list, key, value);
    }
    else {
        addDynamicAttr(list, key, value, '{var}={{value}}');
    }
}
exports.addReactAttr = addReactAttr;
function addVueAttr(list, key, value) {
    if (typeof value === 'string' && key !== 'icon') {
        addAttr(list, key, value);
    }
    else {
        addDynamicAttr(list, key, value, ':{var}="{value}"');
    }
}
exports.addVueAttr = addVueAttr;
function addEmberAttr(list, key, value) {
    if (typeof value === 'string') {
        addAttr(list, '@' + key, value);
    }
    else {
        addDynamicAttr(list, key, value, '@{var}={{{value}}}');
    }
}
exports.addEmberAttr = addEmberAttr;
/**
 * Merge attribute values
 */
function mergeAttr(list, key, value, separator) {
    const oldItem = typeof list[key] === 'object'
        ? list[key]
        : void 0;
    list[key] = {
        key,
        value: (oldItem ? oldItem.value + separator : '') + value,
        syntax: oldItem ? oldItem.syntax : void 0,
    };
}
exports.mergeAttr = mergeAttr;
/**
 * Merge result
 */
function mergeAttributes(list) {
    return Object.keys(list)
        .map((key) => {
        const item = list[key];
        if (typeof item === 'object') {
            return (typeof item.syntax === 'string'
                ? item.syntax
                : '{var}="{value}"')
                .replace('{var}', item.key)
                .replace('{value}', item.value);
        }
        return item;
    })
        .join(' ');
}
exports.mergeAttributes = mergeAttributes;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/parsers/css.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/parsers/css.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cssParser = void 0;
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js");
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental
function assertNever(v) {
    //
}
// Documentation links
const docs = {
    type: 'css',
    href: common_1.docsBase + 'css.html',
};
/**
 * Code output for CSS
 */
const cssParser = (icon, customisations, providerConfig) => {
    if (typeof providerConfig.svg !== 'string') {
        return null;
    }
    // Parse all customisations
    const list = {};
    common_1.getCustomisationsList(customisations).forEach((attr) => {
        switch (attr) {
            // Ignore
            case 'inline':
                break;
            // Color
            case 'color':
                common_1.addAttr(list, 'color', customisations[attr]);
                break;
            // Dimensions
            case 'width':
            case 'height':
                common_1.addAttr(list, attr, common_1.toString(customisations[attr]));
                break;
            case 'onlyHeight':
                common_1.addAttr(list, 'height', common_1.toString(customisations.height));
                break;
            // Transformations
            case 'rotate':
                common_1.addAttr(list, attr, common_1.degrees(customisations[attr]));
                break;
            case 'hFlip':
                common_1.mergeAttr(list, 'flip', 'horizontal', ',');
                break;
            case 'vFlip':
                common_1.mergeAttr(list, 'flip', 'vertical', ',');
                break;
            // Alignment
            case 'hAlign':
            case 'vAlign':
                common_1.mergeAttr(list, 'align', customisations[attr], ',');
                break;
            case 'slice':
                common_1.mergeAttr(list, 'align', attr, ',');
                break;
            default:
                assertNever(attr);
        }
    });
    // Generate params
    const params = Object.keys(list)
        .map((key) => {
        const item = list[key];
        if (typeof item === 'object') {
            return item.key + '=' + encodeURIComponent(item.value);
        }
        return key + '=' + encodeURIComponent(item);
    })
        .join('&');
    // Get URL
    const url = providerConfig.svg
        .replace('{prefix}', icon.prefix)
        .replace('{name}', icon.name) + (params ? '?' + params : '');
    const result = {
        raw: [
            "background: url('" + url + "') no-repeat center center / contain;",
            "content: url('" + url + "');",
        ],
        isAPI: true,
        docs,
    };
    return result;
};
exports.cssParser = cssParser;
//# sourceMappingURL=css.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/parsers/ember.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/parsers/ember.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emberParser = void 0;
const icon_1 = __webpack_require__(/*! ../../misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
const versions_1 = __webpack_require__(/*! ../versions */ "./node_modules/@iconify/search-core/lib/code-samples/versions.js");
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js");
// Documentation links
const docs = {
    type: 'ember',
    href: common_1.docsBase + 'ember/',
};
// Code cache
const installCode = versions_1.getComponentInstall('ember', true);
/**
 * Code output for API component
 */
const emberParser = (icon, customisations, providerConfig) => {
    if (!providerConfig.api) {
        return null;
    }
    // List of attributes
    const list = {};
    // Add icon name
    common_1.addEmberAttr(list, 'icon', icon_1.iconToString(icon));
    // Params
    common_1.getCustomisationsList(customisations).forEach((attr) => {
        switch (attr) {
            case 'onlyHeight': {
                const value = customisations.height;
                common_1.addEmberAttr(list, 'height', value);
                break;
            }
            default:
                common_1.addEmberAttr(list, attr, customisations[attr]);
        }
    });
    // Generate code
    const code = '<IconifyIcon ' + common_1.mergeAttributes(list) + ' />';
    const result = {
        component: {
            'install-addon': installCode,
            'use-in-template': code,
        },
        isAPI: true,
        docs,
    };
    return result;
};
exports.emberParser = emberParser;
//# sourceMappingURL=ember.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/parsers/react.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/parsers/react.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reactOfflineParser = exports.reactParser = void 0;
const icon_1 = __webpack_require__(/*! ../../misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
const versions_1 = __webpack_require__(/*! ../versions */ "./node_modules/@iconify/search-core/lib/code-samples/versions.js");
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js");
// Documentation links
const docs = {
    type: 'react',
    href: common_1.docsBase + 'react/',
};
// Code cache
const installCode = versions_1.getComponentInstall('react', true);
const importCode = "import { Icon } from '" + versions_1.componentPackages.react.name + "';";
/**
 * Add properties and generate code
 */
function generateCode(list, customisations) {
    // Parse all customisations
    common_1.getCustomisationsList(customisations).forEach((attr) => {
        switch (attr) {
            case 'onlyHeight': {
                const value = customisations.height;
                common_1.addReactAttr(list, 'height', value);
                break;
            }
            default:
                common_1.addReactAttr(list, attr, customisations[attr]);
        }
    });
    return '<Icon ' + common_1.mergeAttributes(list) + ' />';
}
/**
 * Code output for API component
 */
const reactParser = (icon, customisations, providerConfig) => {
    if (!providerConfig.api) {
        return null;
    }
    // List of attributes
    const list = {};
    // Add icon name
    common_1.addAttr(list, 'icon', icon_1.iconToString(icon));
    // Generate code
    const code = generateCode(list, customisations);
    const result = {
        component: {
            'install-simple': installCode,
            'import-simple': importCode,
            'use-in-template': code,
        },
        isAPI: true,
        docs,
    };
    return result;
};
exports.reactParser = reactParser;
/**
 * Code output for offline component
 */
const reactOfflineParser = (icon, customisations, providerConfig) => {
    if (!providerConfig.npmCJS && !providerConfig.npmES) {
        return null;
    }
    // Variable name
    const varName = common_1.iconToVarName(icon.name);
    // Import statement
    const npmImport = common_1.npmIconImport(icon, varName, providerConfig, false);
    if (!npmImport) {
        return null;
    }
    // List of attributes
    const list = {};
    // Add icon name
    common_1.addReactAttr(list, 'icon', varName);
    // Generate code
    const code = generateCode(list, customisations);
    const result = {
        component: {
            'install-offline': installCode + ' ' + npmImport.package,
            'import-offline': importCode + '\n' + npmImport.code,
            'use-in-template': code,
        },
        isAPI: false,
        docs,
    };
    return result;
};
exports.reactOfflineParser = reactOfflineParser;
//# sourceMappingURL=react.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/parsers/svelte.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/parsers/svelte.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.svelteOfflineParser = exports.svelteParser = void 0;
const icon_1 = __webpack_require__(/*! ../../misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
const versions_1 = __webpack_require__(/*! ../versions */ "./node_modules/@iconify/search-core/lib/code-samples/versions.js");
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js");
// Documentation links
const docs = {
    type: 'svelte',
    href: common_1.docsBase + 'svelte/',
};
// Code cache
const installCode = versions_1.getComponentInstall('svelte', true);
const importCode = "import Icon from '" + versions_1.componentPackages.svelte.name + "';";
/**
 * Add properties and generate code
 */
function generateCode(list, customisations) {
    // Parse all customisations
    common_1.getCustomisationsList(customisations).forEach((attr) => {
        switch (attr) {
            case 'onlyHeight': {
                const value = customisations.height;
                common_1.addReactAttr(list, 'height', value);
                break;
            }
            default:
                common_1.addReactAttr(list, attr, customisations[attr]);
        }
    });
    return '<Icon ' + common_1.mergeAttributes(list) + ' />';
}
/**
 * Code output for API component
 */
const svelteParser = (icon, customisations, providerConfig) => {
    if (!providerConfig.api) {
        return null;
    }
    // List of attributes
    const list = {};
    // Add icon name
    common_1.addAttr(list, 'icon', icon_1.iconToString(icon));
    // Generate code
    const code = generateCode(list, customisations);
    const result = {
        component: {
            'install-simple': installCode,
            'import-simple': importCode,
            'use-in-template': code,
        },
        isAPI: true,
        docs,
    };
    return result;
};
exports.svelteParser = svelteParser;
/**
 * Code output for offline component
 */
const svelteOfflineParser = (icon, customisations, providerConfig) => {
    if (!providerConfig.npmCJS && !providerConfig.npmES) {
        return null;
    }
    // Variable name
    const varName = common_1.iconToVarName(icon.name);
    // Import statement
    const npmImport = common_1.npmIconImport(icon, varName, providerConfig, false);
    if (!npmImport) {
        return null;
    }
    // List of attributes
    const list = {};
    // Add icon name
    common_1.addReactAttr(list, 'icon', varName);
    // Generate code
    const code = generateCode(list, customisations);
    const result = {
        component: {
            'install-offline': installCode + ' ' + npmImport.package,
            'import-offline': importCode + '\n' + npmImport.code,
            'use-in-template': code,
        },
        isAPI: false,
        docs,
    };
    return result;
};
exports.svelteOfflineParser = svelteOfflineParser;
//# sourceMappingURL=svelte.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/parsers/svg-framework.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/parsers/svg-framework.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.svgFrameworkParser = void 0;
const iconify_1 = __webpack_require__(/*! ../../iconify */ "./node_modules/@iconify/search-core/lib/iconify/index.js");
const icon_1 = __webpack_require__(/*! ../../misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
const versions_1 = __webpack_require__(/*! ../versions */ "./node_modules/@iconify/search-core/lib/code-samples/versions.js");
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js");
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental
function assertNever(v) {
    //
}
// Documentation links
const docs = {
    type: 'iconify',
    href: common_1.docsBase + 'svg-framework/',
};
// Head section
let head;
/**
 * Code output for SVG Framework
 */
const svgFrameworkParser = (icon, customisations, providerConfig) => {
    if (!providerConfig.api) {
        return null;
    }
    // List of attributes
    const list = {};
    // Add class
    common_1.addAttr(list, 'class', customisations.inline ? 'iconify-inline' : 'iconify');
    // Add icon name
    common_1.addAttr(list, 'data-icon', icon_1.iconToString(icon));
    // Parse all customisations
    common_1.getCustomisationsList(customisations).forEach((attr) => {
        switch (attr) {
            case 'inline':
                break;
            // Color
            case 'color':
                common_1.mergeAttr(list, 'style', 'color: ' + customisations[attr] + ';', ' ');
                break;
            // Dimensions
            case 'width':
                common_1.addAttr(list, 'data-width', common_1.toString(customisations[attr]));
                break;
            case 'onlyHeight': {
                const value = customisations.height;
                common_1.mergeAttr(list, 'style', 'font-size: ' + value + (common_1.isNumber(value) ? 'px;' : ';'), ' ');
                break;
            }
            case 'height':
                common_1.addAttr(list, 'data-height', common_1.toString(customisations[attr]));
                break;
            // Transformations
            case 'rotate':
                common_1.addAttr(list, 'data-rotate', common_1.degrees(customisations[attr]));
                break;
            case 'hFlip':
                common_1.mergeAttr(list, 'data-flip', 'horizontal', ',');
                break;
            case 'vFlip':
                common_1.mergeAttr(list, 'data-flip', 'vertical', ',');
                break;
            // Alignment
            case 'hAlign':
            case 'vAlign':
                common_1.mergeAttr(list, 'data-align', customisations[attr], ',');
                break;
            case 'slice':
                common_1.mergeAttr(list, 'data-align', attr, ',');
                break;
            default:
                assertNever(attr);
        }
    });
    // Generate HTML
    const html = '<span ' + common_1.mergeAttributes(list) + '></span>';
    // Head script
    if (head === void 0) {
        const str = iconify_1.Iconify.getVersion ? iconify_1.Iconify.getVersion() : versions_1.iconifyVersion;
        head =
            '<script src="https://code.iconify.design/' +
                str.split('.').shift() +
                '/' +
                str +
                '/iconify.min.js"><' +
                '/script>';
    }
    const result = {
        iconify: {
            head,
            html,
        },
        isAPI: true,
        docs,
    };
    return result;
};
exports.svgFrameworkParser = svgFrameworkParser;
//# sourceMappingURL=svg-framework.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/parsers/svg.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/parsers/svg.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.svgParser = void 0;
const iconify_1 = __webpack_require__(/*! ../../iconify */ "./node_modules/@iconify/search-core/lib/iconify/index.js");
const icon_1 = __webpack_require__(/*! ../../misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
const html_1 = __webpack_require__(/*! ../html */ "./node_modules/@iconify/search-core/lib/code-samples/html.js");
/**
 * Code output for API component
 */
function svgParser(lang, icon, customisations, providerConfig) {
    var _a;
    if (!providerConfig.raw) {
        return null;
    }
    const iconName = icon_1.iconToString(icon);
    const data = (_a = iconify_1.Iconify.getIcon) === null || _a === void 0 ? void 0 : _a.call(iconify_1.Iconify, iconName);
    if (!data) {
        return null;
    }
    let str = html_1.renderHTML(data, customisations);
    switch (lang) {
        case 'svg-box':
            // Add empty rectangle before shapes
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            str = str.replace('>', '><rect x="' +
                data.left +
                '" y="' +
                data.top +
                '" width="' +
                data.width +
                '" height="' +
                data.height +
                '" fill="none" stroke="none" />');
            break;
        case 'svg-uri': {
            // Remove unused attributes
            const parts = str.split('>');
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            let firstTag = parts.shift();
            ['aria-hidden', 'focusable', 'role', 'class', 'style'].forEach((attr) => {
                firstTag = firstTag.replace(new RegExp('\\s' + attr + '="[^"]*"'), '');
            });
            parts.unshift(firstTag);
            str = parts.join('>');
            // Encode
            str = "url('data:image/svg+xml," + encodeURIComponent(str) + "')";
            break;
        }
    }
    const result = {
        raw: [str],
        isAPI: false,
    };
    return result;
}
exports.svgParser = svgParser;
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/parsers/vue.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/parsers/vue.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vueOfflineParser = exports.vueParser = void 0;
const icon_1 = __webpack_require__(/*! ../../misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
const versions_1 = __webpack_require__(/*! ../versions */ "./node_modules/@iconify/search-core/lib/code-samples/versions.js");
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js");
// Documentation links
const docs2 = {
    type: 'vue',
    href: common_1.docsBase + 'vue2/',
};
const docs3 = {
    type: 'vue',
    href: common_1.docsBase + 'vue/',
};
// Code cache
const installCode2 = versions_1.getComponentInstall('vue2', true);
const installCode3 = versions_1.getComponentInstall('vue3', true);
const importCode2 = "import { Icon } from '" + versions_1.componentPackages.vue2.name + "';";
const importCode3 = "import { Icon } from '" + versions_1.componentPackages.vue3.name + "';";
const scriptCode = 'export default {\n\tcomponents: {\n\t\tIcon,\n\t},\n});';
const scriptOfflineCode = 'export default {\n\tcomponents: {\n\t\tIcon,\n\t},\n\tdata() {\n\t\treturn {\n\t\t\ticons: {\n\t\t\t\t{varName},\n\t\t\t},\n\t\t};\n\t},\n});';
/**
 * Add properties and generate code
 */
function generateCode(list, customisations) {
    // Parse all customisations
    common_1.getCustomisationsList(customisations).forEach((attr) => {
        switch (attr) {
            case 'onlyHeight': {
                const value = customisations.height;
                common_1.addVueAttr(list, 'height', value);
                break;
            }
            case 'hFlip':
            case 'vFlip':
            case 'hAlign':
            case 'vAlign': {
                common_1.addVueAttr(list, (attr.slice(0, 1) === 'h' ? 'horizontal' : 'vertical') +
                    attr.slice(1), customisations[attr]);
                break;
            }
            default:
                common_1.addVueAttr(list, attr, customisations[attr]);
        }
    });
    return '<Icon ' + common_1.mergeAttributes(list) + ' />';
}
/**
 * Code output for API component
 */
function vueParser(vue3, icon, customisations, providerConfig) {
    if (!providerConfig.api) {
        return null;
    }
    // List of attributes
    const list = {};
    // Add icon name
    common_1.addAttr(list, 'icon', icon_1.iconToString(icon));
    // Generate code
    const code = generateCode(list, customisations);
    const result = {
        component: {
            'install-simple': vue3 ? installCode3 : installCode2,
            'import-simple': vue3 ? importCode3 : importCode2,
            'use-in-template': code,
            'vue-simple': scriptCode,
        },
        isAPI: true,
        docs: vue3 ? docs3 : docs2,
    };
    return result;
}
exports.vueParser = vueParser;
/**
 * Code output for offline component
 */
function vueOfflineParser(vue3, icon, customisations, providerConfig) {
    if (!providerConfig.npmCJS && !providerConfig.npmES) {
        return null;
    }
    // Variable name
    const varName = common_1.iconToVarName(icon.name);
    // Import statement
    const npmImport = common_1.npmIconImport(icon, varName, providerConfig, vue3);
    if (!npmImport) {
        return null;
    }
    // List of attributes
    const list = {};
    // Add icon name
    common_1.addVueAttr(list, 'icon', 'icons.' + varName);
    // Generate code
    const code = generateCode(list, customisations);
    const result = {
        component: {
            'install-offline': (vue3 ? installCode3 : installCode2) + ' ' + npmImport.package,
            'import-offline': (vue3 ? importCode3 : importCode2) + '\n' + npmImport.code,
            'use-in-template': code,
            'vue-offline': scriptOfflineCode.replace('{varName}', varName),
        },
        isAPI: false,
        docs: vue3 ? docs3 : docs2,
    };
    return result;
}
exports.vueOfflineParser = vueOfflineParser;
//# sourceMappingURL=vue.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/phrases.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/phrases.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.translateCodeSampleTitles = exports.capitalizeCodeSampleTitle = exports.codeSampleTitles = void 0;
const capitalize_1 = __webpack_require__(/*! ../misc/capitalize */ "./node_modules/@iconify/search-core/lib/misc/capitalize.js");
/**
 * Code sample tab and mode titles
 *
 * This list contains only items that require custom text.
 * Everything else will be capitalized using capitalizeCodeSampleTitle() function, such as 'vue2' changed to 'Vue 2'
 */
exports.codeSampleTitles = {
    'iconify': 'SVG Framework',
    'html': 'HTML',
    'css': 'CSS',
    'svg': 'SVG',
    'svg-raw': 'SVG',
    'svg-box': 'SVG with viewBox rectangle',
    'svg-uri': 'SVG as data: URI',
    'react-offline': 'React (offline)',
    'react-api': 'React',
    'vue2-offline': 'Vue 2 (offline)',
    'vue2-api': 'Vue 2',
    'offline': '(offline)',
};
/**
 * Capitalize code sample title
 */
function capitalizeCodeSampleTitle(key) {
    const customValue = exports.codeSampleTitles[key];
    if (customValue !== void 0) {
        return customValue;
    }
    // Check for '-offline' and '-api'
    const parts = key.split('-');
    if (parts.length > 1) {
        const lastPart = parts.pop();
        const testKey = parts.join('-');
        switch (lastPart) {
            case 'offline':
                return (capitalizeCodeSampleTitle(testKey) +
                    ' ' +
                    exports.codeSampleTitles.offline);
            case 'api':
                return capitalizeCodeSampleTitle(testKey);
        }
    }
    // Return capitalised value
    return capitalize_1.capitalize(key);
}
exports.capitalizeCodeSampleTitle = capitalizeCodeSampleTitle;
/**
 * Add / replace custom sample titles
 */
function translateCodeSampleTitles(translation) {
    for (const key in translation) {
        const attr = key;
        exports.codeSampleTitles[attr] = translation[attr];
    }
}
exports.translateCodeSampleTitles = translateCodeSampleTitles;
//# sourceMappingURL=phrases.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/tree.js":
/*!********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/tree.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCodeSamplesTree = void 0;
const phrases_1 = __webpack_require__(/*! ./phrases */ "./node_modules/@iconify/search-core/lib/code-samples/phrases.js");
const iconify_1 = __webpack_require__(/*! ../iconify */ "./node_modules/@iconify/search-core/lib/iconify/index.js");
const rawCodeTabs = {
    html: {
        iconify: 'api',
        css: 'svg',
    },
    react: {
        'react-api': 'api',
        'react-offline': 'offline',
    },
    vue: {
        'vue3-api': 'api',
        'vue2-api': 'api',
        'vue3-offline': 'offline',
        'vue2-offline': 'offline',
    },
    svelte: {
        'svelte-api': 'api',
        'svelte-offline': 'offline',
    },
    ember: 'api',
    svg: {
        'svg-raw': 'raw',
        'svg-box': 'raw',
        'svg-uri': 'raw',
    },
};
/**
 * Get code samples tree
 */
function getCodeSamplesTree(config) {
    const results = [];
    /**
     * Check if code sample can be shown
     */
    function canUse(mode, type) {
        // Check for required functions
        switch (mode) {
            case 'svg-box':
            case 'svg-raw':
            case 'svg-uri':
                if (!iconify_1.Iconify.getIcon) {
                    return false;
                }
        }
        // Check type
        switch (type) {
            case 'raw':
                return config[type];
            case 'api':
                return config.api;
            case 'svg':
                return config.svg !== void 0;
            case 'offline':
                return config.npmES !== void 0 || config.npmCJS !== void 0;
        }
    }
    /**
     * Get title
     */
    function getTitle(mode) {
        if (phrases_1.codeSampleTitles[mode] !== void 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return phrases_1.codeSampleTitles[mode];
        }
        return phrases_1.capitalizeCodeSampleTitle(mode);
    }
    for (const key in rawCodeTabs) {
        // Using weird type casting because TypeScript can't property resolve it
        const attr = key;
        const item = rawCodeTabs[key];
        // Item without children
        if (typeof item === 'string') {
            const mode = attr;
            if (canUse(mode, item)) {
                // Add item without children
                const newItem = {
                    mode,
                    type: item,
                    title: getTitle(attr),
                };
                results.push(newItem);
            }
            else {
                console.error('Cannot use mode:', mode, item);
            }
            continue;
        }
        // Item with children
        const children = [];
        for (const key2 in item) {
            const mode = key2;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const type = item[mode];
            if (canUse(mode, type)) {
                const newItem = {
                    mode,
                    type,
                    title: getTitle(mode),
                };
                children.push(newItem);
            }
        }
        let firstChild;
        const tab = attr;
        const title = getTitle(tab);
        switch (children.length) {
            case 0:
                break;
            case 1:
                // Merge children
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                firstChild = children[0];
                results.push({
                    tab,
                    mode: firstChild.mode,
                    type: firstChild.type,
                    title,
                });
                break;
            default:
                // Add all children
                results.push({
                    tab,
                    children,
                    title,
                });
        }
    }
    return results;
}
exports.getCodeSamplesTree = getCodeSamplesTree;
//# sourceMappingURL=tree.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/code-samples/versions.js":
/*!************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/code-samples/versions.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getComponentInstall = exports.componentPackages = exports.iconifyVersion = void 0;
// Iconify version (do not edit it, replaced during build!)
exports.iconifyVersion = '2.0.3';
exports.componentPackages = {
    react: {
        name: '@iconify/react',
    },
    vue2: {
        name: '@iconify/vue2',
    },
    vue3: {
        name: '@iconify/vue',
    },
    svelte: {
        name: '@iconify/svelte',
    },
    ember: {
        name: '@iconify/ember',
    },
};
/**
 * Get package name to install
 */
function getComponentInstall(key, dev) {
    const item = exports.componentPackages[key];
    let result = item.name;
    if (item.version !== void 0) {
        result += item.version;
    }
    if (typeof dev === 'boolean') {
        return 'npm install --save' + (dev ? '-dev ' : ' ') + result;
    }
    return result;
}
exports.getComponentInstall = getComponentInstall;
//# sourceMappingURL=versions.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/converters/collection.js":
/*!************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/converters/collection.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rawDataToCollection = exports.dataToCollection = void 0;
const info_1 = __webpack_require__(/*! ./info */ "./node_modules/@iconify/search-core/lib/converters/info.js");
/**
 * Parse themes
 */
function parseThemes(iconSet, sortedIcons, result) {
    const data = {
        prefix: {
            hasEmpty: false,
            hasUncategorized: false,
            values: [],
            titles: Object.create(null),
            found: Object.create(null),
            test: (name, test) => name.slice(0, test.length) === test,
        },
        suffix: {
            hasEmpty: false,
            hasUncategorized: false,
            values: [],
            titles: Object.create(null),
            found: Object.create(null),
            test: (name, test) => name.slice(0 - test.length) === test,
        },
    };
    const keys = ['prefix', 'suffix'];
    // Converted icon set data, using ThemeType as key, new theme format as value
    const iconSetData = {
        prefix: null,
        suffix: null,
    };
    // Convert legacy format
    if (typeof iconSet.themes === 'object' && iconSet.themes) {
        const themes = iconSet.themes;
        Object.keys(themes).forEach((key) => {
            const theme = themes[key];
            keys.forEach((attr) => {
                const prop = attr;
                if (typeof theme[prop] === 'string') {
                    // Has prefix or suffix
                    const value = theme[prop];
                    if (iconSetData[attr] === null) {
                        iconSetData[attr] = Object.create(null);
                    }
                    iconSetData[attr][value] = theme.title;
                }
            });
        });
    }
    // Check themes
    keys.forEach((key) => {
        const attr = (key + 'es');
        if (typeof iconSet[attr] === 'object' && iconSet[attr] !== null) {
            // Prefixes or suffixes exist: overwrite old entry
            iconSetData[key] = iconSet[attr];
        }
        if (!iconSetData[key]) {
            // No prefix or suffix? Delete entry in data
            delete data[key];
            return;
        }
        // Validate themes
        const dataItem = data[key];
        const theme = iconSetData[key];
        Object.keys(theme).forEach((value) => {
            const title = theme[value];
            if (value !== '') {
                // Check for '-' at start or end
                switch (key) {
                    case 'prefix':
                        if (value.slice(-1) !== '-') {
                            value += '-';
                        }
                        break;
                    case 'suffix':
                        if (value.slice(0, 1) !== '-') {
                            value = '-' + value;
                        }
                        break;
                }
            }
            if (dataItem.titles[value] !== void 0) {
                // Duplicate entry
                return;
            }
            // Add value
            if (value === '') {
                dataItem.hasEmpty = true;
            }
            else {
                dataItem.values.push(value);
            }
            // Set data
            dataItem.titles[value] = title;
            dataItem.found[value] = 0;
        });
        // Check if theme is empty
        if (!Object.keys(dataItem.titles).length) {
            delete data[key];
        }
    });
    // Check stuff
    Object.keys(data).forEach((attr) => {
        const dataItem = data[attr];
        const matches = dataItem.values;
        const iconKey = attr === 'prefix' ? 'themePrefixes' : 'themeSuffixes';
        // Sort matches by length, then alphabetically
        matches.sort((a, b) => a.length === b.length ? a.localeCompare(b) : b.length - a.length);
        // Check all icons
        sortedIcons.forEach((icon) => {
            // Check icon
            (icon.aliases
                ? [icon.name].concat(icon.aliases)
                : [icon.name]).forEach((name, index) => {
                // Find match
                let theme = null;
                for (let i = 0; i < matches.length; i++) {
                    const match = matches[i];
                    if (dataItem.test(name, match)) {
                        // Found matching theme
                        dataItem.found[match]++;
                        theme = match;
                        break;
                    }
                }
                if (theme === null && dataItem.hasEmpty && !index) {
                    // Empty prefix/suffix, but do not test aliases
                    theme = '';
                    dataItem.found['']++;
                }
                // Get title
                const title = theme === null ? '' : dataItem.titles[theme];
                // Not found
                if (theme === null) {
                    if (index > 0) {
                        return;
                    }
                    // Uncategorized
                    dataItem.hasUncategorized = true;
                    theme = '';
                }
                // Found
                if (icon[iconKey] === void 0) {
                    icon[iconKey] = [title];
                    return;
                }
                const titles = icon[iconKey];
                if (titles.indexOf(title) === -1) {
                    titles.push(title);
                }
            });
        });
        // Add result
        const titles = Object.create(null);
        Object.keys(dataItem.titles).forEach((match) => {
            if (dataItem.found[match]) {
                titles[match] = dataItem.titles[match];
            }
        });
        if (dataItem.hasUncategorized) {
            titles[''] = '';
        }
        switch (Object.keys(titles).length) {
            case 0:
                // Nothing to do
                break;
            case 1:
                // 1 theme: remove all entries
                sortedIcons.forEach((icon) => {
                    delete icon[iconKey];
                });
                break;
            default:
                // Many entries
                result[iconKey] = titles;
        }
    });
}
/**
 * Parse characters map
 */
function parseChars(chars, icons) {
    Object.keys(chars).forEach((char) => {
        const name = chars[char];
        if (icons[name] !== void 0) {
            const icon = icons[name];
            if (icon.chars === void 0) {
                icon.chars = [];
            }
            icon.chars.push(char);
        }
    });
}
/**
 * Convert icons to sorted array
 */
function sortIcons(icons) {
    const sortedIcons = [];
    Object.keys(icons)
        .sort((a, b) => a.localeCompare(b))
        .forEach((name) => {
        sortedIcons.push(icons[name]);
    });
    return sortedIcons;
}
/**
 * Convert collection data
 */
function dataToCollection(provider, data) {
    if (typeof data !== 'object' || data === null) {
        return null;
    }
    const source = data;
    // Check required fields
    if (typeof source.prefix !== 'string') {
        return null;
    }
    // Create result
    const result = {
        provider,
        prefix: source.prefix,
        name: '',
        total: 0,
        icons: [],
    };
    // Get info
    if (typeof source.info === 'object' && source.info !== null) {
        const info = info_1.dataToCollectionInfo(source.info, result.prefix);
        if (info === null) {
            // Invalid info block, so something is wrong
            return null;
        }
        result.info = info;
    }
    // Get collection name
    if (typeof source.name === 'string') {
        result.name = source.name;
    }
    else if (typeof source.title === 'string') {
        // Correct API response
        result.name = source.title;
    }
    else if (result.info !== void 0) {
        result.name = result.info.name;
    }
    else {
        result.name = result.prefix;
    }
    // Check for categories
    let tags = typeof source.categories === 'object' && source.categories !== null
        ? Object.keys(source.categories)
        : [];
    let hasUncategorised = false, uncategorisedKey = 'uncategorized';
    ['uncategorized', 'uncategorised'].forEach((attr) => {
        if (typeof source[attr] === 'object' &&
            source[attr] instanceof Array &&
            source[attr].length > 0) {
            uncategorisedKey = attr;
            hasUncategorised = true;
        }
    });
    // Find all icons
    const icons = Object.create(null);
    function addCategory(iconsList, category) {
        let added = false;
        iconsList.forEach((name) => {
            if (typeof name !== 'string') {
                return;
            }
            added = true;
            if (icons[name] === void 0) {
                // Add new icon
                const icon = {
                    provider,
                    prefix: result.prefix,
                    name,
                    tags: [category],
                };
                icons[name] = icon;
                return;
            }
            // Add tag to existing icon
            if (icons[name].tags === void 0) {
                icons[name].tags = [];
            }
            if (icons[name].tags.indexOf(category) === -1) {
                icons[name].tags.push(category);
            }
        });
        return added;
    }
    tags = tags.filter((category) => {
        let added = false;
        const categoryItems = source.categories[category];
        if (categoryItems instanceof Array) {
            added = addCategory(categoryItems, category);
        }
        else {
            Object.keys(categoryItems).forEach((subcategory) => {
                const subcategoryItems = categoryItems[subcategory];
                if (subcategoryItems instanceof Array) {
                    added = addCategory(subcategoryItems, category) || added;
                }
            });
        }
        return added;
    });
    const hasTags = tags.length > 0;
    // Add uncategorised icons
    if (hasUncategorised) {
        const list = source[uncategorisedKey];
        list.forEach((name) => {
            if (typeof name !== 'string') {
                return;
            }
            if (icons[name] === void 0) {
                // Add new icon
                const icon = {
                    provider,
                    prefix: result.prefix,
                    name: name,
                };
                if (hasTags) {
                    icon.tags = [''];
                }
                icons[name] = icon;
                return;
            }
        });
        if (hasTags) {
            tags.push('');
        }
    }
    // Add characters
    if (typeof source.chars === 'object') {
        parseChars(source.chars, icons);
    }
    // Add aliases
    const missingAliases = Object.create(null);
    if (typeof source.aliases === 'object') {
        const aliases = source.aliases;
        Object.keys(aliases).forEach((alias) => {
            const name = aliases[alias];
            if (icons[name] !== void 0) {
                const icon = icons[name];
                if (icon.aliases === void 0) {
                    icon.aliases = [];
                }
                icon.aliases.push(alias);
                return;
            }
            // Alias is not found. Hidden icon?
            if (missingAliases[name] === void 0) {
                missingAliases[name] = [];
            }
            missingAliases[name].push(alias);
        });
    }
    // Add hidden icons
    if (source.hidden instanceof Array) {
        let hidden = [];
        source.hidden.forEach((icon) => {
            // Add icon
            hidden.push(icon);
            // Look for aliases of hidden icon
            if (missingAliases[icon] !== void 0) {
                hidden = hidden.concat(missingAliases[icon]);
            }
        });
        result.hidden = hidden;
    }
    // Convert to sorted array
    const sortedIcons = sortIcons(icons);
    // Check tags
    if (tags.length > 1) {
        result.tags = tags.sort(sortTags);
    }
    else if (hasTags) {
        // Only one tag - delete tags
        sortedIcons.forEach((icon) => {
            delete icon.tags;
        });
    }
    // Add themes
    parseThemes(source, sortedIcons, result);
    // Add icons
    result.icons = sortedIcons;
    result.total = result.icons.length;
    if (result.info) {
        result.info.total = result.total;
    }
    return result;
}
exports.dataToCollection = dataToCollection;
/**
 * Convert raw data from icon set
 */
function rawDataToCollection(source) {
    /**
     * Add icon
     */
    function addIcon(name, depth = 0) {
        if (depth > 3) {
            // Alias recursion is too high. Do not make aliases of aliases.
            return null;
        }
        if (icons[name] !== void 0) {
            // Already added
            return name;
        }
        // Add icon
        if (source.icons[name] !== void 0) {
            if (!source.icons[name].hidden) {
                icons[name] = {
                    provider: result.provider,
                    prefix: result.prefix,
                    name,
                    tags: [],
                };
                return name;
            }
            return null;
        }
        // Add alias
        if (source.aliases &&
            source.aliases[name] !== void 0 &&
            !source.aliases[name].hidden) {
            // Resolve alias
            const item = source.aliases[name];
            const parent = item.parent;
            // Add parent icon
            const added = addIcon(parent, depth + 1);
            if (added !== null) {
                // Icon was added, which means parent icon is a viable icon
                // Check if new icon is an alias or full icon
                if (!(item.rotate || item.hFlip || item.vFlip)) {
                    // Alias
                    const parentIcon = icons[added];
                    if (!parentIcon.aliases) {
                        parentIcon.aliases = [name];
                    }
                    else if (parentIcon.aliases.indexOf(name) === -1) {
                        parentIcon.aliases.push(name);
                    }
                    return added;
                }
                else {
                    // New icon
                    icons[name] = {
                        provider: result.provider,
                        prefix: result.prefix,
                        name,
                        tags: [],
                    };
                    return name;
                }
            }
        }
        return null;
    }
    /**
     * Add tag to icons
     */
    function addTag(iconsList, tag) {
        let added = false;
        iconsList.forEach((name) => {
            if (icons[name] !== void 0 &&
                icons[name].tags.indexOf(tag) === -1) {
                icons[name].tags.push(tag);
                added = true;
            }
        });
        return added;
    }
    // Check required fields
    if (typeof source.prefix !== 'string') {
        return null;
    }
    const result = {
        provider: typeof source.provider === 'string' ? source.provider : '',
        prefix: source.prefix,
        name: '',
        total: 0,
        icons: [],
    };
    // Get required info
    if (typeof source.info !== 'object' || source.info === null) {
        return null;
    }
    const info = info_1.dataToCollectionInfo(source.info, result.prefix);
    if (info === null) {
        // Invalid info block, so something is wrong
        return null;
    }
    result.info = info;
    // Get collection name
    result.name = result.info.name;
    // Find all icons
    const icons = Object.create(null);
    Object.keys(source.icons).forEach((name) => addIcon(name));
    if (typeof source.aliases === 'object') {
        Object.keys(source.aliases).forEach((name) => addIcon(name));
    }
    const iconNames = Object.keys(icons);
    // Check for categories
    const tags = [];
    if (typeof source.categories === 'object' && source.categories !== null) {
        let hasUncategorised = false;
        const categories = source.categories;
        Object.keys(categories).forEach((category) => {
            const categoryItems = categories[category];
            // Array
            if (categoryItems instanceof Array) {
                if (addTag(categoryItems, category)) {
                    tags.push(category);
                }
            }
            else if (typeof categoryItems === 'object') {
                // Sub-categories. No longer used, but can be found in some older icon sets
                Object.keys(categoryItems).forEach((subcategory) => {
                    const subcategoryItems = categoryItems[subcategory];
                    if (subcategoryItems instanceof Array) {
                        if (addTag(subcategoryItems, category) &&
                            tags.indexOf(category) === -1) {
                            tags.push(category);
                        }
                    }
                });
            }
        });
        // Check if icons without categories exist
        iconNames.forEach((name) => {
            if (!icons[name].tags.length) {
                icons[name].tags.push('');
                hasUncategorised = true;
            }
        });
        if (hasUncategorised) {
            tags.push('');
        }
    }
    // Remove tags if there are less than 2 categories
    if (tags.length < 2) {
        Object.keys(icons).forEach((name) => {
            delete icons[name].tags;
        });
    }
    else {
        result.tags = tags.sort(sortTags);
    }
    // Add characters
    if (typeof source.chars === 'object') {
        parseChars(source.chars, icons);
    }
    // Sort icons
    const sortedIcons = sortIcons(icons);
    // Add themes
    parseThemes(source, sortedIcons, result);
    // Add icons
    result.icons = sortedIcons;
    result.total = result.info.total = result.icons.length;
    return result;
}
exports.rawDataToCollection = rawDataToCollection;
/**
 * Sort categories
 */
function sortTags(a, b) {
    if (a === '') {
        return 1;
    }
    if (b === '') {
        return -1;
    }
    return a.localeCompare(b);
}
//# sourceMappingURL=collection.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/converters/collections.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/converters/collections.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.autoIndexCollections = exports.filterCollections = exports.collectionsPrefixes = exports.dataToCollections = void 0;
const info_1 = __webpack_require__(/*! ./info */ "./node_modules/@iconify/search-core/lib/converters/info.js");
/**
 * Convert data from API to CollectionsList
 */
function dataToCollections(data) {
    const result = Object.create(null);
    const uncategorised = Object.create(null);
    if (typeof data !== 'object' || data === null) {
        return result;
    }
    // Assume Record<prefix, item> structure
    Object.keys(data).forEach((prefix) => {
        const row = data[prefix];
        if (typeof row !== 'object' ||
            row === null ||
            typeof row.category !== 'string') {
            return;
        }
        // Convert item
        const item = info_1.dataToCollectionInfo(row, prefix);
        if (item === null) {
            return;
        }
        // Add category and item
        const category = row.category;
        if (category !== '') {
            if (result[category] === void 0) {
                result[category] = Object.create(null);
            }
            result[category][prefix] = item;
        }
        else {
            uncategorised[prefix] = item;
        }
    });
    // Add uncategorised at the end
    if (Object.keys(uncategorised).length > 0) {
        result[''] = uncategorised;
    }
    return result;
}
exports.dataToCollections = dataToCollections;
/**
 * Get collection prefixes from converted collections list
 */
function collectionsPrefixes(collections) {
    let prefixes = [];
    Object.keys(collections).forEach((category) => {
        prefixes = prefixes.concat(Object.keys(collections[category]));
    });
    return prefixes;
}
exports.collectionsPrefixes = collectionsPrefixes;
/**
 * Filter collections
 */
function filterCollections(collections, callback, keepEmptyCategories = false) {
    const result = Object.create(null);
    // Parse each category
    Object.keys(collections).forEach((category) => {
        if (keepEmptyCategories) {
            result[category] = Object.create(null);
        }
        // Parse each item in category
        Object.keys(collections[category]).forEach((prefix) => {
            const item = collections[category][prefix];
            if (!callback(item, category, prefix)) {
                return;
            }
            // Passed filter
            if (result[category] === void 0) {
                result[category] = Object.create(null);
            }
            result[category][prefix] = item;
        });
    });
    return result;
}
exports.filterCollections = filterCollections;
/**
 * Add indexes to all collections
 */
function autoIndexCollections(collections, start = 0) {
    let index = start;
    Object.keys(collections).forEach((category) => {
        const items = collections[category];
        Object.keys(items).forEach((prefix) => {
            items[prefix].index = index++;
        });
    });
}
exports.autoIndexCollections = autoIndexCollections;
//# sourceMappingURL=collections.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/converters/info.js":
/*!******************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/converters/info.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dataToCollectionInfo = void 0;
const minDisplayHeight = 16;
const maxDisplayHeight = 24;
/**
 * Convert data from API to CollectionInfo
 */
function dataToCollectionInfo(data, expectedPrefix = '') {
    if (typeof data !== 'object' || data === null) {
        return null;
    }
    const source = data;
    const getSourceNestedString = (field, key, defaultValue = '') => {
        if (typeof source[field] !== 'object') {
            return defaultValue;
        }
        const obj = source[field];
        return typeof obj[key] === 'string' ? obj[key] : defaultValue;
    };
    // Get name
    let name;
    if (typeof source.name === 'string') {
        name = source.name;
    }
    else if (typeof source.title === 'string') {
        name = source.title;
    }
    else {
        return null;
    }
    // Get prefix
    let prefix;
    if (expectedPrefix === '') {
        if (typeof source.prefix !== 'string') {
            return null;
        }
        prefix = source.prefix;
    }
    else {
        if (typeof source.prefix === 'string' &&
            source.prefix !== expectedPrefix) {
            // Prefixes do not match
            return null;
        }
        prefix = expectedPrefix;
    }
    // Generate data
    const result = {
        prefix: prefix,
        name: name,
        total: typeof source.total === 'number' ? source.total : 0,
        version: typeof source.version === 'string' ? source.version : '',
        author: {
            name: getSourceNestedString('author', 'name', typeof source.author === 'string' ? source.author : 'Unknown'),
            url: getSourceNestedString('author', 'url', ''),
        },
        license: {
            title: getSourceNestedString('license', 'title', typeof source.license === 'string' ? source.license : 'Unknown'),
            spdx: getSourceNestedString('license', 'spdx', ''),
            url: getSourceNestedString('license', 'url', ''),
        },
        samples: [],
        category: typeof source.category === 'string' ? source.category : '',
        palette: typeof source.palette === 'boolean' ? source.palette : false,
    };
    // Total as string
    if (typeof source.total === 'string') {
        const num = parseInt(source.total);
        if (num > 0) {
            result.total = num;
        }
    }
    // Add samples
    if (source.samples instanceof Array) {
        source.samples.forEach((item) => {
            if (result.samples.length < 3 && typeof item === 'string') {
                result.samples.push(item);
            }
        });
    }
    // Add height
    if (typeof source.height === 'number' ||
        typeof source.height === 'string') {
        const num = parseInt(source.height);
        if (num > 0) {
            result.height = num;
        }
    }
    if (source.height instanceof Array) {
        source.height.forEach((item) => {
            const num = parseInt(item);
            if (num > 0) {
                if (!(result.height instanceof Array)) {
                    result.height = [];
                }
                result.height.push(num);
            }
        });
        switch (result.height.length) {
            case 0:
                delete result.height;
                break;
            case 1:
                result.height = result.height[0];
        }
    }
    // Add display height
    if (typeof result.height === 'number') {
        // Convert from height
        result.displayHeight = result.height;
        while (result.displayHeight < minDisplayHeight) {
            result.displayHeight *= 2;
        }
        while (result.displayHeight > maxDisplayHeight) {
            result.displayHeight /= 2;
        }
        if (result.displayHeight !== Math.round(result.displayHeight) ||
            result.displayHeight < minDisplayHeight ||
            result.displayHeight > maxDisplayHeight) {
            delete result.displayHeight;
        }
    }
    if (typeof source.displayHeight === 'number' ||
        typeof source.displayHeight === 'string') {
        // Convert from source.displayHeight
        const num = parseInt(source.displayHeight);
        if (num >= minDisplayHeight &&
            num <= maxDisplayHeight &&
            Math.round(num) === num) {
            result.displayHeight = num;
        }
    }
    // Convert palette from string value
    if (typeof source.palette === 'string') {
        switch (source.palette.toLowerCase()) {
            case 'colorless': // Iconify v1
            case 'false': // Boolean as string
                result.palette = false;
                break;
            case 'colorful': // Iconify v1
            case 'true': // Boolean as string
                result.palette = true;
        }
    }
    // Parse all old keys
    Object.keys(source).forEach((key) => {
        const value = source[key];
        if (typeof value !== 'string') {
            return;
        }
        switch (key) {
            case 'url':
            case 'uri':
                result.author.url = value;
                break;
            case 'licenseURL':
            case 'licenseURI':
                result.license.url = value;
                break;
            case 'licenseID':
            case 'licenseSPDX':
                result.license.spdx = value;
                break;
        }
    });
    return result;
}
exports.dataToCollectionInfo = dataToCollectionInfo;
//# sourceMappingURL=info.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/converters/search.js":
/*!********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/converters/search.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dataToSearchResults = void 0;
const icon_1 = __webpack_require__(/*! ../misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
const info_1 = __webpack_require__(/*! ./info */ "./node_modules/@iconify/search-core/lib/converters/info.js");
function dataToSearchResults(provider, data) {
    if (typeof data !== 'object' || data === null) {
        return null;
    }
    // Get source as object
    const source = data;
    if (typeof source.request !== 'object' || source.request === null) {
        return null;
    }
    // Check required attributes
    const request = source.request;
    if (typeof request.query !== 'string') {
        return null;
    }
    if (typeof source.total !== 'number' || typeof source.limit !== 'number') {
        return null;
    }
    // Create result
    const result = {
        provider,
        query: request.query,
        total: source.total,
        limit: source.limit,
        icons: [],
        collections: Object.create(null),
    };
    // Parse all icons
    if (typeof source.collections !== 'object' ||
        !(source.icons instanceof Array)) {
        return null;
    }
    const sourceIcons = source.icons;
    const sourceCollections = source.collections;
    try {
        sourceIcons.forEach((item) => {
            const icon = icon_1.stringToIcon(item, true, provider);
            if (icon === null) {
                throw new Error('Invalid icon');
            }
            result.icons.push(icon);
            const prefix = icon.prefix;
            if (result.collections[prefix] === void 0) {
                // Add collection
                if (sourceCollections[prefix] === void 0) {
                    throw new Error(`Missing data for prefix ${prefix}`);
                }
                const info = info_1.dataToCollectionInfo(sourceCollections[prefix], prefix);
                if (info === null) {
                    throw new Error(`Invalid data for prefix ${prefix}`);
                }
                result.collections[prefix] = info;
            }
        });
    }
    catch (err) {
        return null;
    }
    // Overwrite total
    result.total = result.icons.length;
    return result;
}
exports.dataToSearchResults = dataToSearchResults;
//# sourceMappingURL=search.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/data/collections.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/data/collections.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCollectionTitle = exports.getCollectionInfo = exports.setCollectionInfo = void 0;
/**
 * Set data
 */
function setCollectionInfo(storage, provider, prefix, data) {
    if (storage[provider] === void 0) {
        storage[provider] = Object.create(null);
    }
    const providerData = storage[provider];
    if (providerData[prefix] === void 0 || data.index) {
        // Overwrite previous entry only if index is set
        providerData[prefix] = data;
    }
}
exports.setCollectionInfo = setCollectionInfo;
/**
 * Get data
 */
function getCollectionInfo(storage, provider, prefix) {
    return storage[provider] === void 0 || storage[provider][prefix] === void 0
        ? null
        : storage[provider][prefix];
}
exports.getCollectionInfo = getCollectionInfo;
/**
 * Get collection title (or prefix if not available)
 */
function getCollectionTitle(storage, provider, prefix) {
    if (storage[provider] === void 0 || storage[provider][prefix] === void 0) {
        return prefix;
    }
    return storage[provider][prefix].name;
}
exports.getCollectionTitle = getCollectionTitle;
//# sourceMappingURL=collections.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/data/config.js":
/*!**************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/data/config.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.customisedConfig = exports.createConfig = exports.mergeConfig = exports.setComponentsConfig = void 0;
const objects_1 = __webpack_require__(/*! ../misc/objects */ "./node_modules/@iconify/search-core/lib/misc/objects.js");
/**
 * Default UI config
 */
const defaultUIConfig = {
    // Number of icons per page.
    itemsPerPage: 52,
    // Maximum delay between changing current view and updating visible view.
    // This delay is used to avoid "loading" page when changing views.
    viewUpdateDelay: 300,
    // Number of sibling collections to show when collection view is child view of collections list.
    showSiblingCollections: 2,
};
/**
 * Router config
 */
const defaultRouterConfig = {
    // Home route as string, empty to automatically detect route
    home: '',
    // Allow synchronous rendering when API data is available?
    syncRender: false,
};
/**
 * Default configuration.
 *
 * 2 levels deep object:
 * object[key][key2] = value
 */
const defaultConfig = {
    // UI
    ui: defaultUIConfig,
    // Router
    router: defaultRouterConfig,
    // Components
    components: {},
};
/**
 * Set default components config
 */
function setComponentsConfig(config) {
    defaultConfig.components = Object.assign(config);
}
exports.setComponentsConfig = setComponentsConfig;
/**
 * Merge data
 */
function mergeConfig(config, custom) {
    for (const key in custom) {
        const attr = key;
        const configSource = config[attr];
        if (configSource === void 0) {
            continue;
        }
        // Merge objects
        const customSource = custom[attr];
        for (const key2 in customSource) {
            const attr2 = key2;
            if (configSource[attr2] !== void 0) {
                // Overwrite entry
                configSource[attr2] = customSource[attr2];
            }
        }
    }
}
exports.mergeConfig = mergeConfig;
/**
 * Create configuration object
 */
function createConfig(customValues = {}) {
    const config = objects_1.cloneObject(defaultConfig);
    if (customValues) {
        mergeConfig(config, customValues);
    }
    return config;
}
exports.createConfig = createConfig;
/**
 * Get customised configuration values
 */
function customisedConfig(config) {
    const customised = {};
    for (const key in config) {
        const attr = key;
        const defaultSource = defaultConfig[attr];
        const configSource = config[attr];
        const child = {};
        let found = false;
        for (const key2 in configSource) {
            const attr2 = key2;
            if (configSource[attr2] !== defaultSource[attr2]) {
                child[attr2] = configSource[attr2];
                found = true;
            }
        }
        if (found) {
            customised[attr] = child;
        }
    }
    return customised;
}
exports.customisedConfig = customisedConfig;
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/data/custom-sets.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/data/custom-sets.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeCollections = exports.convertCustomSets = exports.emptyConvertedSet = void 0;
const iconify_1 = __webpack_require__(/*! ../iconify */ "./node_modules/@iconify/search-core/lib/iconify/index.js");
const collection_1 = __webpack_require__(/*! ../converters/collection */ "./node_modules/@iconify/search-core/lib/converters/collection.js");
const collections_1 = __webpack_require__(/*! ../converters/collections */ "./node_modules/@iconify/search-core/lib/converters/collections.js");
/**
 * TypeScript guard
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function
function assertNever(s) { }
/**
 * Empty
 */
exports.emptyConvertedSet = {
    merge: 'custom-last',
    providers: Object.create(null),
};
/**
 * Convert custom icon sets, return empty set on failure
 */
function convertCustomSets(data, importIcons = true) {
    if (!data.iconSets || !data.iconSets.length) {
        return exports.emptyConvertedSet;
    }
    // Merge
    let merge = 'only-custom';
    switch (data.merge) {
        case 'custom-first':
        case 'custom-last':
        case 'only-custom':
            merge = data.merge;
            break;
        case void 0:
            break;
        default:
            assertNever(data.merge);
    }
    // Set basic data
    const result = {
        merge,
        providers: Object.create(null),
    };
    // Info to parse later
    const rawInfo = Object.create(null);
    // Get all providers, add icon sets to Iconify.
    data.iconSets.forEach((item) => {
        if (typeof item.prefix !== 'string') {
            return;
        }
        // Get/set provider
        if (typeof data.provider === 'string') {
            item.provider = data.provider;
        }
        const provider = typeof item.provider === 'string' ? item.provider : '';
        // Custom info block
        if (!item.info && data.info && data.info[item.prefix]) {
            item.info = data.info[item.prefix];
        }
        // Convert data
        const convertedData = collection_1.rawDataToCollection(item);
        if (!convertedData) {
            return;
        }
        // Add data to result
        if (result.providers[provider] === void 0) {
            result.providers[provider] = {
                total: 0,
                data: Object.create(null),
                collections: {},
            };
        }
        const providerData = result.providers[provider];
        if (providerData.data[convertedData.prefix] !== void 0) {
            // Already exists
            return;
        }
        // Add data
        providerData.data[convertedData.prefix] = convertedData;
        providerData.total++;
        // Store raw info block to convert to collections list later, overwrite count
        if (rawInfo[provider] === void 0) {
            rawInfo[provider] = Object.create(null);
        }
        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */
        const rawItemInfo = Object.assign({}, item.info);
        rawItemInfo.total = convertedData.total;
        rawInfo[provider][convertedData.prefix] = rawItemInfo;
        // Add icons to Iconify
        if (importIcons && iconify_1.Iconify.addCollection) {
            iconify_1.Iconify.addCollection(item);
        }
    });
    // Parse collections lists
    Object.keys(rawInfo).forEach((provider) => {
        result.providers[provider].collections = collections_1.dataToCollections(rawInfo[provider]);
    });
    return result;
}
exports.convertCustomSets = convertCustomSets;
/**
 * Merge icon sets from API and custom icon sets
 */
function mergeCollections(provider, defaultSets, customSets) {
    // Get list of parsed data
    const parsedData = [];
    if (defaultSets) {
        parsedData.push({
            isCustom: false,
            categories: defaultSets,
        });
    }
    if (customSets) {
        const customCollections = customSets.providers[provider].collections;
        // Unshift or push it, depending on merge order
        parsedData[customSets.merge === 'custom-first' ? 'unshift' : 'push']({
            isCustom: true,
            categories: customCollections,
        });
    }
    // Setup result as empty object
    const results = Object.create(null);
    // Store prefixes map to avoid duplicates
    const usedPrefixes = Object.create(null);
    // Parse all data
    parsedData.forEach((item) => {
        // Parse all categories
        const collectionsList = item.categories;
        Object.keys(collectionsList).forEach((category) => {
            const categoryItems = collectionsList[category];
            Object.keys(categoryItems).forEach((prefix) => {
                if (usedPrefixes[prefix] !== void 0) {
                    // Prefix has already been parsed
                    if (item.isCustom) {
                        // Remove previous entry
                        delete results[usedPrefixes[prefix]][prefix];
                    }
                    else {
                        // Do not overwrite: always show set from API in case of duplicate entries
                        return;
                    }
                }
                // Add item
                usedPrefixes[prefix] = category;
                if (results[category] === void 0) {
                    results[category] = Object.create(null);
                }
                results[category][prefix] = categoryItems[prefix];
            });
        });
    });
    return results;
}
exports.mergeCollections = mergeCollections;
//# sourceMappingURL=custom-sets.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/data/providers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/data/providers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.listProviders = exports.addProvider = exports.getProvider = exports.convertProviderData = exports.internalSourceCache = void 0;
const iconify_1 = __webpack_require__(/*! ../iconify */ "./node_modules/@iconify/search-core/lib/iconify/index.js");
const icon_1 = __webpack_require__(/*! @iconify/utils/lib/icon */ "./node_modules/@iconify/utils/lib/icon/index.js");
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function
function assertNever(s) { }
/**
 * Default values
 */
const defaultAPIDataLinks = {
    home: '',
    collection: '',
    icon: '',
};
const defaultAPIDataNPM = {
    package: '',
    icon: '',
};
const defaultAPIData = {
    // These variables will be automatically set if empty
    provider: '',
    title: '',
    api: '',
    // Optional
    links: defaultAPIDataLinks,
    npm: defaultAPIDataNPM,
    svg: '',
};
/**
 * Local cache
 */
// Exported to allow quick manipulation of links. Not meant to be used in any other way
exports.internalSourceCache = Object.create(null);
const configuredCache = Object.create(null);
// Add default provider
const iconifyRoot = 'https://icon-sets.iconify.design/';
const iconifyPackage = '@iconify/icons-{prefix}';
exports.internalSourceCache[""] = {
    config: {},
    title: 'Iconify',
    links: {
        home: iconifyRoot,
        collection: iconifyRoot + '{prefix}/',
        icon: iconifyRoot + '{prefix}/{name}/',
    },
    npm: {
        package: iconifyPackage,
        icon: iconifyPackage + '/{name}',
    },
    svg: 'https://api.iconify.design/{prefix}/{name}.svg',
};
/**
 * Defaults
 */
const defaults = {
    title: '',
    links: defaultAPIDataLinks,
    npm: defaultAPIDataNPM,
    svg: '',
};
/**
 * Convert data returned from API
 */
function convertProviderData(host, raw) {
    const provider = raw.provider;
    if (typeof provider !== 'string' ||
        // Allow empty string
        (provider !== '' && !provider.match(icon_1.matchName))) {
        return null;
    }
    // Clean up raw data
    const data = {};
    for (const key in defaultAPIData) {
        const attr = key;
        switch (attr) {
            case 'title':
                data.title =
                    typeof raw.title === 'string' ? raw.title : provider;
                break;
            case 'provider':
                data.provider = provider;
                break;
            case 'api':
                if (typeof raw.api === 'string' && raw.api !== '') {
                    data.api = [raw.api];
                }
                else if (raw.api instanceof Array) {
                    data.api = raw.api;
                }
                else if (host === '') {
                    // Missing host
                    return null;
                }
                else {
                    data.api = [host];
                }
                break;
            case 'npm':
            case 'links': {
                const defaultValue = defaultAPIData[attr];
                let resultValue;
                if (typeof raw[attr] !== 'object' || !raw[attr]) {
                    // Copy default value
                    resultValue = defaultValue;
                }
                else {
                    const rawValue = raw[attr];
                    // Merge values
                    resultValue = {};
                    for (const nestedKey in defaultValue) {
                        const nestedAttr = nestedKey;
                        if (typeof rawValue[nestedAttr] === 'string') {
                            resultValue[nestedAttr] = rawValue[nestedAttr];
                        }
                        else {
                            resultValue[nestedAttr] = defaultValue[nestedAttr];
                        }
                    }
                }
                data[attr] = resultValue;
                break;
            }
            case 'svg':
                data[attr] =
                    typeof raw[attr] === 'string'
                        ? raw[attr]
                        : defaultAPIData[attr];
                break;
            default:
                assertNever(attr);
        }
    }
    const fullData = data;
    // Create API config
    const config = {
        resources: fullData.api,
    };
    // Create data
    const result = {
        config,
        title: fullData.title,
        links: fullData.links,
        npm: fullData.npm,
        svg: '',
    };
    return result;
}
exports.convertProviderData = convertProviderData;
/**
 * Get API provider
 */
function getProvider(provider) {
    if (configuredCache[provider] === void 0) {
        if (exports.internalSourceCache[provider] === void 0) {
            // Missing provider
            return null;
        }
        const source = exports.internalSourceCache[provider];
        // Get Redundancy instance from Iconify
        const data = iconify_1.Iconify.getAPI ? iconify_1.Iconify.getAPI(provider) : void 0;
        if (data === void 0) {
            // Failed again - something is wrong with config
            configuredCache[provider] = null;
        }
        else {
            configuredCache[provider] = {
                config: data.config,
                redundancy: data.redundancy,
            };
            // Add missing fields
            const cache = configuredCache[provider];
            const src = source;
            for (const key in defaults) {
                if (src[key] !== void 0) {
                    cache[key] = src[key];
                }
                else {
                    cache[key] = defaults[key];
                }
            }
        }
    }
    return configuredCache[provider];
}
exports.getProvider = getProvider;
/**
 * Add provider
 */
function addProvider(provider, config) {
    if (!iconify_1.Iconify.addAPIProvider || exports.internalSourceCache[provider] !== void 0) {
        // addAPIProvider is not set or cannot overwrite provider
        return;
    }
    if (config.title === void 0) {
        // Use provider as name
        config.title = provider;
    }
    exports.internalSourceCache[provider] = config;
    iconify_1.Iconify.addAPIProvider(provider, config.config);
}
exports.addProvider = addProvider;
/**
 * Get all providers
 */
function listProviders() {
    return Object.keys(exports.internalSourceCache).sort();
}
exports.listProviders = listProviders;
//# sourceMappingURL=providers.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/events.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Events = void 0;
/**
 * Events class
 */
class Events {
    constructor() {
        this._subscribers = Object.create(null);
    }
    /**
     * Subscribe to event
     *
     * @param event Event name
     * @param callback Callback function
     * @param key Optional unique key for unsubscribe. If key is set, any other event listener with same key will be removed
     */
    subscribe(event, callback, key) {
        if (this._subscribers[event] === void 0) {
            // Create new array
            this._subscribers[event] = [];
        }
        else if (typeof key === 'string') {
            // Remove previous subscribers with same key
            this._subscribers[event] = this._subscribers[event].filter((item) => item.key !== key);
        }
        // Add new subscriber
        this._subscribers[event].push({
            callback,
            key,
        });
    }
    /**
     * Unsubscribe from event
     *
     * @param event Event name
     * @param value Callback or key
     */
    unsubscribe(event, value) {
        if (this._subscribers[event] === void 0) {
            return;
        }
        let key;
        switch (typeof value) {
            case 'function':
                key = 'callback';
                break;
            case 'string':
                key = 'key';
                break;
            default:
                return;
        }
        this._subscribers[event] = this._subscribers[event].filter((item) => item[key] !== value);
    }
    /**
     * Check if event has listeners
     *
     * @param event Event name
     */
    hasListeners(event) {
        return (this._subscribers[event] !== void 0 &&
            this._subscribers[event].length > 0);
    }
    /**
     * Fire event
     *
     * @param event Event name
     * @param data Payload
     * @param delay True if event should fire on next tick
     */
    fire(event, data, delay = false) {
        if (!this.hasListeners(event)) {
            return;
        }
        if (delay) {
            setTimeout(() => {
                this._fire(event, data);
            });
        }
        else {
            this._fire(event, data);
        }
    }
    /**
     * Fire event
     *
     * @param event
     * @param data
     */
    _fire(event, data) {
        this._subscribers[event].forEach((item) => {
            item.callback(data, event);
        });
    }
}
exports.Events = Events;
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/iconify/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/iconify/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setIconify = exports.Iconify = void 0;
exports.Iconify = {};
/**
 * Set Iconify functions
 *
 * Use this to set Iconify module before doing anything
 */
function setIconify(functions) {
    // Merge all functions
    [functions, functions._api].forEach((items) => {
        if (typeof items === 'object') {
            for (const key in items) {
                const value = items[key];
                if (typeof value === 'function') {
                    exports.Iconify[key] = value;
                }
            }
        }
    });
}
exports.setIconify = setIconify;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCoreInstance = exports.IconFinderCore = exports.cloneObject = exports.compareObjects = exports.stringToIcon = exports.compareIcons = exports.validateIcon = exports.iconToString = exports.setComponentsConfig = exports.mergeConfig = exports.customisedConfig = exports.getCollectionTitle = exports.getCollectionInfo = exports.objectToRoute = exports.listProviders = exports.convertProviderData = exports.getProvider = exports.addProvider = exports.setIconify = exports.maxPage = exports.showPagination = exports.iterateCollectionsBlock = exports.getCollectionsBlockPrefixes = exports.getCollectionsBlockCategories = exports.isBlockEmpty = void 0;
const registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/@iconify/search-core/lib/registry/index.js");
const storage_1 = __webpack_require__(/*! ./registry/storage */ "./node_modules/@iconify/search-core/lib/registry/storage.js");
const custom_sets_1 = __webpack_require__(/*! ./data/custom-sets */ "./node_modules/@iconify/search-core/lib/data/custom-sets.js");
const collections_1 = __webpack_require__(/*! ./data/collections */ "./node_modules/@iconify/search-core/lib/data/collections.js");
Object.defineProperty(exports, "getCollectionInfo", ({ enumerable: true, get: function () { return collections_1.getCollectionInfo; } }));
/**
 * Export data for various blocks
 */
var types_1 = __webpack_require__(/*! ./blocks/types */ "./node_modules/@iconify/search-core/lib/blocks/types.js");
Object.defineProperty(exports, "isBlockEmpty", ({ enumerable: true, get: function () { return types_1.isBlockEmpty; } }));
var collections_list_1 = __webpack_require__(/*! ./blocks/collections-list */ "./node_modules/@iconify/search-core/lib/blocks/collections-list.js");
Object.defineProperty(exports, "getCollectionsBlockCategories", ({ enumerable: true, get: function () { return collections_list_1.getCollectionsBlockCategories; } }));
Object.defineProperty(exports, "getCollectionsBlockPrefixes", ({ enumerable: true, get: function () { return collections_list_1.getCollectionsBlockPrefixes; } }));
Object.defineProperty(exports, "iterateCollectionsBlock", ({ enumerable: true, get: function () { return collections_list_1.iterateCollectionsBlock; } }));
var pagination_1 = __webpack_require__(/*! ./blocks/pagination */ "./node_modules/@iconify/search-core/lib/blocks/pagination.js");
Object.defineProperty(exports, "showPagination", ({ enumerable: true, get: function () { return pagination_1.showPagination; } }));
Object.defineProperty(exports, "maxPage", ({ enumerable: true, get: function () { return pagination_1.maxPage; } }));
/**
 * Export various types and functions that do not depend on core instance
 */
// Iconify wrapper
var iconify_1 = __webpack_require__(/*! ./iconify */ "./node_modules/@iconify/search-core/lib/iconify/index.js");
Object.defineProperty(exports, "setIconify", ({ enumerable: true, get: function () { return iconify_1.setIconify; } }));
var providers_1 = __webpack_require__(/*! ./data/providers */ "./node_modules/@iconify/search-core/lib/data/providers.js");
Object.defineProperty(exports, "addProvider", ({ enumerable: true, get: function () { return providers_1.addProvider; } }));
Object.defineProperty(exports, "getProvider", ({ enumerable: true, get: function () { return providers_1.getProvider; } }));
Object.defineProperty(exports, "convertProviderData", ({ enumerable: true, get: function () { return providers_1.convertProviderData; } }));
Object.defineProperty(exports, "listProviders", ({ enumerable: true, get: function () { return providers_1.listProviders; } }));
var convert_1 = __webpack_require__(/*! ./route/convert */ "./node_modules/@iconify/search-core/lib/route/convert.js");
Object.defineProperty(exports, "objectToRoute", ({ enumerable: true, get: function () { return convert_1.objectToRoute; } }));
var collections_2 = __webpack_require__(/*! ./data/collections */ "./node_modules/@iconify/search-core/lib/data/collections.js");
Object.defineProperty(exports, "getCollectionTitle", ({ enumerable: true, get: function () { return collections_2.getCollectionTitle; } }));
var config_1 = __webpack_require__(/*! ./data/config */ "./node_modules/@iconify/search-core/lib/data/config.js");
Object.defineProperty(exports, "customisedConfig", ({ enumerable: true, get: function () { return config_1.customisedConfig; } }));
Object.defineProperty(exports, "mergeConfig", ({ enumerable: true, get: function () { return config_1.mergeConfig; } }));
Object.defineProperty(exports, "setComponentsConfig", ({ enumerable: true, get: function () { return config_1.setComponentsConfig; } }));
var icon_1 = __webpack_require__(/*! ./misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
Object.defineProperty(exports, "iconToString", ({ enumerable: true, get: function () { return icon_1.iconToString; } }));
Object.defineProperty(exports, "validateIcon", ({ enumerable: true, get: function () { return icon_1.validateIcon; } }));
Object.defineProperty(exports, "compareIcons", ({ enumerable: true, get: function () { return icon_1.compareIcons; } }));
Object.defineProperty(exports, "stringToIcon", ({ enumerable: true, get: function () { return icon_1.stringToIcon; } }));
// Objects
var objects_1 = __webpack_require__(/*! ./misc/objects */ "./node_modules/@iconify/search-core/lib/misc/objects.js");
Object.defineProperty(exports, "compareObjects", ({ enumerable: true, get: function () { return objects_1.compareObjects; } }));
Object.defineProperty(exports, "cloneObject", ({ enumerable: true, get: function () { return objects_1.cloneObject; } }));
/**
 * Icon Finder Core class
 */
class IconFinderCore {
    constructor(params) {
        this.params = params;
        // Get Registry instance
        const registry = (this.registry = new registry_1.Registry(params));
        this.id = registry.id;
        registry.setCustom('core', this, true);
        // Set custom icon sets
        if (params.iconSets) {
            registry.customIconSets = custom_sets_1.convertCustomSets(params.iconSets);
            // console.log('Custom sets:', registry.customIconSets);
        }
        // Get other required classes from Registry
        const router = (this.router = registry.router);
        const events = registry.events;
        // Subscribe to events
        events.subscribe('render', this._routerEvent.bind(this));
        if (typeof params.custom === 'object' && params.custom !== null) {
            Object.keys(params.custom).forEach((customType) => {
                events.subscribe('load-' + customType, this._loadCustomIconsEvent.bind(this, customType));
            });
        }
        // Change route on next tick, so callback would be called asynchronously
        setTimeout(() => {
            if (router.fullRoute === null) {
                if (params.route !== void 0) {
                    // Set route. On null or failure router will call home()
                    router.partialRoute = params.route;
                }
                else {
                    router.home();
                }
            }
        });
    }
    /**
     * Get collection information
     */
    getCollection(provider, prefix) {
        return collections_1.getCollectionInfo(this.registry.collections, provider, prefix);
    }
    /**
     * Event was fired by router
     */
    _routerEvent(data) {
        this.params.callback(data, this);
    }
    /**
     * Load data
     */
    _loadCustomIconsEvent(customType, callback) {
        if (this.params.custom === void 0) {
            return;
        }
        this.params.custom[customType](callback);
    }
    /**
     * Destroy instance
     */
    destroy() {
        this.registry.destroy();
    }
}
exports.IconFinderCore = IconFinderCore;
/**
 * Find Icon Finder Core instance for id
 */
function getCoreInstance(id) {
    const registry = storage_1.getRegistry(id);
    return registry
        ? registry.getCustom('core', true)
        : void 0;
}
exports.getCoreInstance = getCoreInstance;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/misc/capitalize.js":
/*!******************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/misc/capitalize.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.capitalize = void 0;
// Split numbers
const unitsSplit = /([0-9]+[0-9.]*)/g;
/**
 * Capitalize string: split by dash and numbers
 */
function capitalize(str, split = '-') {
    return str
        .split(split)
        .map((item) => {
        return item
            .split(unitsSplit)
            .filter((item) => item.length > 0)
            .map((item) => item.slice(0, 1).toUpperCase() + item.slice(1))
            .join(' ');
    })
        .join(' ');
}
exports.capitalize = capitalize;
//# sourceMappingURL=capitalize.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/misc/color-keywords.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/misc/color-keywords.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendedColorKeywords = exports.baseColorKeywords = void 0;
/**
 * List of base colors. From https://www.w3.org/TR/css3-color/
 */
exports.baseColorKeywords = {
    silver: [192, 192, 192],
    gray: [128, 128, 128],
    white: [255, 255, 255],
    maroon: [128, 0, 0],
    red: [255, 0, 0],
    purple: [128, 0, 128],
    fuchsia: [255, 0, 255],
    green: [0, 128, 0],
    lime: [0, 255, 0],
    olive: [128, 128, 0],
    yellow: [255, 255, 0],
    navy: [0, 0, 128],
    blue: [0, 0, 255],
    teal: [0, 128, 128],
    aqua: [0, 255, 255],
};
/**
 * List of extended colors. From https://www.w3.org/TR/css3-color/
 */
exports.extendedColorKeywords = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
    // Color module level 4
    rebeccapurple: [102, 51, 153],
};
//# sourceMappingURL=color-keywords.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/misc/colors.js":
/*!**************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/misc/colors.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.colorToString = exports.stringToColor = void 0;
const color_keywords_1 = __webpack_require__(/*! ./color-keywords */ "./node_modules/@iconify/search-core/lib/misc/color-keywords.js");
/**
 * Attempt to convert color to keyword.
 *
 * Assumes that check for alpha === 1 has been completed
 */
function colorToKeyword(color) {
    // Test all keyword lists
    const lists = [color_keywords_1.baseColorKeywords, color_keywords_1.extendedColorKeywords];
    for (let i = 0; i < lists.length; i++) {
        const list = lists[i];
        const keys = Object.keys(list);
        let key;
        while ((key = keys.shift()) !== void 0) {
            const rgb = list[key];
            if (rgb[0] === color.r &&
                rgb[1] === color.g &&
                rgb[2] === color.b) {
                return key;
            }
        }
    }
    return null;
}
/**
 * Convert array to object
 */
function valueToKeyword(value) {
    return {
        r: value[0],
        g: value[1],
        b: value[2],
        a: 1,
    };
}
/**
 * Convert hex color to object
 */
function hexToColor(value) {
    if (value.slice(0, 1) === '#') {
        value = value.slice(1);
    }
    if (!/^[\da-f]+$/i.test(value)) {
        return null;
    }
    let alphaStr = '';
    let redStr, greenStr, blueStr;
    let start = 0;
    switch (value.length) {
        case 4:
            alphaStr = value.slice(-1);
            alphaStr += alphaStr;
        // eslint-disable-next-line no-fallthrough
        case 3:
            redStr = value.slice(start, ++start);
            redStr += redStr;
            greenStr = value.slice(start, ++start);
            greenStr += greenStr;
            blueStr = value.slice(start, ++start);
            blueStr += blueStr;
            break;
        case 8:
            alphaStr = value.slice(-2);
        // eslint-disable-next-line no-fallthrough
        case 6:
            redStr = value.slice(start++, ++start);
            greenStr = value.slice(start++, ++start);
            blueStr = value.slice(start++, ++start);
            break;
        default:
            return null;
    }
    return {
        r: parseInt(redStr, 16),
        g: parseInt(greenStr, 16),
        b: parseInt(blueStr, 16),
        a: alphaStr === '' ? 1 : parseInt(alphaStr, 16) / 255,
    };
}
/**
 * Convert string to color
 */
function stringToColor(value) {
    value = value.toLowerCase();
    // Test keywords
    if (color_keywords_1.baseColorKeywords[value] !== void 0) {
        return valueToKeyword(color_keywords_1.baseColorKeywords[value]);
    }
    if (color_keywords_1.extendedColorKeywords[value] !== void 0) {
        return valueToKeyword(color_keywords_1.extendedColorKeywords[value]);
    }
    // Test for function
    if (value.indexOf('(') === -1) {
        // Not a function: test hex string
        return hexToColor(value);
    }
    // Remove whitespace
    value = value.replace(/\s+/g, '');
    if (value.slice(-1) !== ')') {
        return null;
    }
    // Remove ')' at the end
    value = value.slice(0, value.length - 1);
    // Split by '('
    const parts = value.split('(');
    if (parts.length !== 2 || /[^\d.,%-]/.test(parts[1])) {
        return null;
    }
    const keyword = parts[0];
    const colors = parts[1].split(',');
    if (colors.length !== 3 && colors.length !== 4) {
        return null;
    }
    let alpha = 1;
    // Get alpha
    if (colors.length === 4) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const lastItem = colors.pop();
        alpha = parseFloat(lastItem) * (lastItem.slice(-1) === '%' ? 0.01 : 1);
        if (isNaN(alpha)) {
            return null;
        }
        alpha = alpha < 0 ? 0 : alpha > 1 ? 1 : alpha;
    }
    // Parse
    let color1; // red or hue
    let color2; // green or saturation
    let color3; // blue or lightness
    let isPercentages;
    let multiplier;
    switch (keyword) {
        case 'rgb':
        case 'rgba':
            // Either all or no components can be percentages
            isPercentages = colors[0].slice(-1) === '%';
            if ((colors[1].slice(-1) === '%') !== isPercentages ||
                (colors[2].slice(-1) === '%') !== isPercentages) {
                return null;
            }
            // Convert to numbers and normalize colors
            multiplier = isPercentages ? 2.55 : 1;
            color1 = parseFloat(colors[0]) * multiplier;
            color2 = parseFloat(colors[1]) * multiplier;
            color3 = parseFloat(colors[2]) * multiplier;
            return {
                r: isNaN(color1) || color1 < 0
                    ? 0
                    : color1 > 255
                        ? 255
                        : color1,
                g: isNaN(color2) || color2 < 0
                    ? 0
                    : color2 > 255
                        ? 255
                        : color2,
                b: isNaN(color3) || color3 < 0
                    ? 0
                    : color3 > 255
                        ? 255
                        : color3,
                a: alpha,
            };
        case 'hsl':
        case 'hsla':
            if (colors[0].indexOf('%') !== -1 ||
                colors[1].slice(-1) !== '%' ||
                colors[2].slice(-1) !== '%') {
                // Hue cannot be percentage, saturation and lightness must be percentage
                return null;
            }
            // Convert to numbers and normalize colors
            color1 = parseFloat(colors[0]);
            color2 = parseFloat(colors[1]);
            color3 = parseFloat(colors[2]);
            return {
                h: isNaN(color1)
                    ? 0
                    : color1 < 0
                        ? (color1 % 360) + 360
                        : color1 >= 360
                            ? color1 % 360
                            : color1,
                s: isNaN(color2) || color2 < 0
                    ? 0
                    : color2 > 100
                        ? 100
                        : color2,
                l: isNaN(color3) || color3 < 0
                    ? 0
                    : color3 > 100
                        ? 100
                        : color3,
                a: alpha,
            };
    }
    return null;
}
exports.stringToColor = stringToColor;
/**
 * Convert HSL to RGB
 */
function hslToRGB(value, round = false) {
    function valore(n1, n2, hue) {
        hue = hue < 0 ? (hue % 360) + 360 : hue >= 360 ? hue % 360 : hue;
        if (hue >= 240) {
            return n1;
        }
        if (hue < 60) {
            return n1 + ((n2 - n1) * hue) / 60;
        }
        if (hue < 180) {
            return n2;
        }
        return n1 + ((n2 - n1) * (240 - hue)) / 60;
    }
    const hue = value.h < 0
        ? (value.h % 360) + 360
        : value.h >= 360
            ? value.h % 360
            : value.h;
    const sat = value.s < 0 ? 0 : value.s > 100 ? 1 : value.s / 100;
    const lum = value.l < 0 ? 0 : value.l > 100 ? 1 : value.l / 100;
    let m2;
    if (lum <= 0.5) {
        m2 = lum * (1 + sat);
    }
    else {
        m2 = lum + sat * (1 - lum);
    }
    const m1 = 2 * lum - m2;
    let c1, c2, c3;
    if (sat === 0 && hue === 0) {
        c1 = lum;
        c2 = lum;
        c3 = lum;
    }
    else {
        c1 = valore(m1, m2, hue + 120);
        c2 = valore(m1, m2, hue);
        c3 = valore(m1, m2, hue - 120);
    }
    return {
        r: round ? Math.round(c1 * 255) : c1 * 255,
        g: round ? Math.round(c2 * 255) : c2 * 255,
        b: round ? Math.round(c3 * 255) : c3 * 255,
        a: value.a,
    };
}
/**
 * Convert color to string
 */
function colorToString(color) {
    // Attempt to convert to RGB
    let rgbColor;
    try {
        rgbColor =
            color.r !== void 0
                ? color
                : hslToRGB(color);
    }
    catch (err) {
        return '';
    }
    // Check precision
    const rgbRounded = rgbColor.r === Math.round(rgbColor.r) &&
        rgbColor.g === Math.round(rgbColor.g) &&
        rgbColor.b === Math.round(rgbColor.b);
    // Check for keyword and hexadecimal color
    if (rgbRounded && color.a === 1) {
        // Keyword?
        const keyword = colorToKeyword(rgbColor);
        if (typeof keyword === 'string') {
            return keyword;
        }
        // Hex color
        let result = '';
        let canShorten = true;
        try {
            ['r', 'g', 'b'].forEach((attr) => {
                const value = rgbColor[attr];
                if (value < 0 || value > 255) {
                    throw new Error('Invalid color');
                }
                const str = (value < 16 ? '0' : '') + value.toString(16);
                result += str;
                canShorten = canShorten && str[0] === str[1];
            });
        }
        catch (err) {
            return '';
        }
        return '#' + (canShorten ? result[0] + result[2] + result[4] : result);
    }
    // RGB(A) or HSL(A)
    if (!rgbRounded && color.h !== void 0) {
        // HSL(A)
        const hslColor = color;
        const list = [];
        try {
            // Hue
            let hue = hslColor.h % 360;
            while (hue < 0) {
                hue += 360;
            }
            list.push(hue + '');
            // Saturation, lightness
            ['s', 'l'].forEach((attr) => {
                const value = hslColor[attr];
                if (value < 0 || value > 100) {
                    throw new Error('Invalid color');
                }
                list.push(value + '%');
            });
        }
        catch (err) {
            return '';
        }
        if (hslColor.a !== 1) {
            list.push(hslColor.a + '');
        }
        return (hslColor.a === 1 ? 'hsl(' : 'hsla(') + list.join(', ') + ')';
    }
    // RGB(A)
    const list = [];
    try {
        ['r', 'g', 'b'].forEach((attr) => {
            const value = rgbColor[attr];
            if (value < 0 || value > 255) {
                throw new Error('Invalid color');
            }
            list.push(value + '');
        });
    }
    catch (err) {
        return '';
    }
    if (rgbColor.a !== 1) {
        list.push(rgbColor.a + '');
    }
    return (rgbColor.a === 1 ? 'rgb(' : 'rgba(') + list.join(', ') + ')';
}
exports.colorToString = colorToString;
//# sourceMappingURL=colors.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/misc/customisations.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/misc/customisations.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filterCustomisations = exports.mergeCustomisations = exports.defaultCustomisations = exports.emptyCustomisations = void 0;
const customisations_1 = __webpack_require__(/*! @iconify/utils/lib/customisations */ "./node_modules/@iconify/utils/lib/customisations/index.js");
/**
 * Custom values
 */
const emptyCustomValues = {
    color: '',
};
/**
 * Empty values
 */
exports.emptyCustomisations = {
    ...customisations_1.defaults,
    ...emptyCustomValues,
};
/**
 * Default values
 */
exports.defaultCustomisations = {
    ...exports.emptyCustomisations,
};
/**
 * Add missing values to customisations, creating new object. Function does type checking
 */
function mergeCustomisations(defaults, values) {
    // Merge default properties
    const result = customisations_1.mergeCustomisations(defaults, values);
    // Merge custom properties
    for (const key in emptyCustomValues) {
        const attr = key;
        // Match type
        result[attr] =
            values && typeof values[attr] === typeof defaults[attr]
                ? values[attr]
                : defaults[attr];
    }
    return result;
}
exports.mergeCustomisations = mergeCustomisations;
/**
 * Export only customised attributes
 */
function filterCustomisations(values) {
    // Function can handle any properties, just needs some type hinting
    const result = {};
    for (const key in exports.defaultCustomisations) {
        const attr = key;
        if (values[attr] !== exports.defaultCustomisations[attr] &&
            values[attr] !== exports.emptyCustomisations[attr]) {
            result[attr] = values[attr];
        }
    }
    return result;
}
exports.filterCustomisations = filterCustomisations;
//# sourceMappingURL=customisations.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/misc/icon.js":
/*!************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/misc/icon.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconToString = exports.compareIcons = exports.validateIcon = exports.stringToIcon = exports.match = void 0;
const name_1 = __webpack_require__(/*! @iconify/utils/lib/icon/name */ "./node_modules/@iconify/utils/lib/icon/name.js");
Object.defineProperty(exports, "validateIcon", ({ enumerable: true, get: function () { return name_1.validateIcon; } }));
/**
 * Expression to test part of icon name.
 */
exports.match = /^[a-z0-9]+(-[a-z0-9]+)*$/;
/**
 * Convert string to Icon object.
 */
const stringToIcon = (value, validate = false, provider = '') => {
    return name_1.stringToIcon(value, validate, false, provider);
};
exports.stringToIcon = stringToIcon;
/**
 * Compare Icon objects.
 *
 * Note: null means icon is invalid, so null to null comparison = false.
 */
const compareIcons = (icon1, icon2) => {
    return (icon1 !== null &&
        icon2 !== null &&
        icon1.provider === icon2.provider &&
        icon1.name === icon2.name &&
        icon1.prefix === icon2.prefix);
};
exports.compareIcons = compareIcons;
/**
 * Convert icon to string.
 */
const iconToString = (icon) => {
    return ((icon.provider === '' ? '' : '@' + icon.provider + ':') +
        icon.prefix +
        ':' +
        icon.name);
};
exports.iconToString = iconToString;
//# sourceMappingURL=icon.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/misc/objects.js":
/*!***************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/misc/objects.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.match = exports.compareObjects = exports.cloneObject = void 0;
/**
 * Deep clone simple object.
 *
 * This function does not handle anything other than primitive types + Arrays.
 * This function is on average 10 times faster than JSON.parse(JSON.stringify(obj)) on small objects, several times faster on big objects
 */
function cloneObject(obj) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    if (obj instanceof Array) {
        return obj.map((item) => {
            if (typeof item === 'object') {
                return cloneObject(item);
            }
            else {
                return item;
            }
        });
    }
    const result = {};
    let key;
    for (key in obj) {
        if (typeof obj[key] !== 'object') {
            result[key] = obj[key];
        }
        else {
            result[key] = cloneObject(obj[key]);
        }
    }
    return result;
}
exports.cloneObject = cloneObject;
/**
 * Compare two objects.
 *
 * This function does not handle anything other than primitive types + Arrays.
 */
function compareObjects(obj1, obj2) {
    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {
        return obj1 === obj2;
    }
    if (obj1 === obj2) {
        // Same object or both are null
        return true;
    }
    if (obj1 === null || obj2 === null) {
        // One of objects is null
        return false;
    }
    // Check for arrays
    if (obj1 instanceof Array) {
        if (!(obj2 instanceof Array)) {
            return false;
        }
        if (obj1.length !== obj2.length) {
            return false;
        }
        for (let i = 0; i < obj1.length; i++) {
            const value1 = obj1[i];
            const value2 = obj2[i];
            if (value1 !== value2) {
                // Different values. If both are objects, do deep comparison, otherwise return false
                if (typeof value1 !== 'object' ||
                    typeof value2 !== 'object' ||
                    !compareObjects(value1, value2)) {
                    return false;
                }
            }
        }
        return true;
    }
    else if (obj2 instanceof Array) {
        return false;
    }
    // Not array
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    for (let i = 0; i < keys1.length; i++) {
        const key = keys1[i];
        if (typeof obj1[key] !==
            typeof obj2[key]) {
            return false;
        }
        if (typeof obj1[key] === 'object') {
            if (!compareObjects(obj1[key], obj2[key])) {
                return false;
            }
        }
        else if (obj1[key] !==
            obj2[key]) {
            return false;
        }
    }
    return true;
}
exports.compareObjects = compareObjects;
/**
 * Find match of keyword in data.
 *
 * Comparison is case insensitive.
 */
function match(data, keyword) {
    if (typeof data === 'number') {
        data = '' + data;
    }
    if (typeof data === 'string') {
        return data.toLowerCase().indexOf(keyword) !== -1;
    }
    if (typeof data !== 'object' || data === null) {
        return false;
    }
    if (data instanceof Array) {
        for (let i = 0; i < data.length; i++) {
            if (match(data[i], keyword)) {
                return true;
            }
        }
        return false;
    }
    for (const key in data) {
        if (match(data[key], keyword)) {
            return true;
        }
    }
    return false;
}
exports.match = match;
//# sourceMappingURL=objects.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/registry/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/registry/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Registry = void 0;
const config_1 = __webpack_require__(/*! ../data/config */ "./node_modules/@iconify/search-core/lib/data/config.js");
const events_1 = __webpack_require__(/*! ../events */ "./node_modules/@iconify/search-core/lib/events.js");
const fetch_1 = __webpack_require__(/*! ../api/fetch */ "./node_modules/@iconify/search-core/lib/api/fetch.js");
const router_1 = __webpack_require__(/*! ../route/router */ "./node_modules/@iconify/search-core/lib/route/router.js");
const storage_1 = __webpack_require__(/*! ./storage */ "./node_modules/@iconify/search-core/lib/registry/storage.js");
const custom_sets_1 = __webpack_require__(/*! ../data/custom-sets */ "./node_modules/@iconify/search-core/lib/data/custom-sets.js");
/**
 * Registry class
 */
class Registry {
    constructor(params) {
        this._data = Object.create(null);
        const namespace = typeof params === 'string'
            ? params
            : typeof params === 'object' &&
                typeof params.namespace === 'string'
                ? params.namespace
                : 'iconify';
        this.namespace = namespace;
        // Get unique id based on namespace
        this.id = storage_1.uniqueId(namespace);
        // Add namespace
        this.initialised = storage_1.addRegistry(this);
        // Copy shared data
        this._sharedData = storage_1.getSharedData(namespace);
        // Params
        this.params = typeof params === 'object' ? params : {};
        // Add instance
        this._save();
    }
    /**
     * Save instance in registry list
     */
    _save() {
        storage_1.saveRegistry(this);
    }
    /**
     * Get/set config
     */
    get config() {
        if (this._sharedData.config === void 0) {
            this._sharedData.config = config_1.createConfig(this.params.config);
        }
        return this._sharedData.config;
    }
    set config(value) {
        this._sharedData.config = value;
    }
    /**
     * Get/set events
     */
    get events() {
        if (this._data.events === void 0) {
            this._data.events = new events_1.Events();
        }
        return this._data.events;
    }
    set events(value) {
        this._data.events = value;
    }
    /**
     * Get/set API
     */
    get api() {
        if (this._sharedData.api === void 0) {
            this._sharedData.api = new fetch_1.API(this);
        }
        return this._sharedData.api;
    }
    set api(value) {
        this._sharedData.api = value;
    }
    /**
     * Get/set custom icon sets
     */
    get customIconSets() {
        if (this._data.customIconSets === void 0) {
            this._data.customIconSets = custom_sets_1.emptyConvertedSet;
        }
        return this._data.customIconSets;
    }
    set customIconSets(value) {
        this._data.customIconSets = value;
    }
    /**
     * Get/set collections
     */
    get collections() {
        if (this._sharedData.collections === void 0) {
            this._sharedData.collections = Object.create(null);
        }
        return this._sharedData.collections;
    }
    set collections(value) {
        this._sharedData.collections = value;
    }
    /**
     * Set/set router
     */
    get router() {
        if (this._data.router === void 0) {
            this._data.router = new router_1.Router(this.id);
        }
        return this._data.router;
    }
    set router(value) {
        this._data.router = value;
    }
    /**
     * Set/set route
     */
    get fullRoute() {
        return this.router.fullRoute;
    }
    set fullRoute(value) {
        this.router.fullRoute = value;
    }
    get partialRoute() {
        return this.router.partialRoute;
    }
    set partialRoute(value) {
        this.router.partialRoute = value;
    }
    /**
     * Get/set custom data
     */
    getCustom(key, local = true) {
        const data = local ? this._data : this._sharedData;
        if (data.custom === void 0) {
            return void 0;
        }
        return data.custom[key];
    }
    setCustom(key, value, local = true) {
        const data = local ? this._data : this._sharedData;
        if (data.custom === void 0) {
            data.custom = Object.create(null);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const custom = data.custom;
        // Create getter and setter for local properties
        if (local && custom[key] === void 0) {
            Object.defineProperty(this, key, {
                get() {
                    return custom[key];
                },
                set(value) {
                    custom[key] = value;
                },
            });
        }
        custom[key] = value;
    }
    /**
     * Destroy instance
     */
    destroy() {
        storage_1.destroyRegistry(this);
    }
}
exports.Registry = Registry;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/registry/storage.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/registry/storage.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRegistry = exports.destroyRegistry = exports.getSharedData = exports.saveRegistry = exports.addRegistry = exports.uniqueId = void 0;
const namespaces = Object.create(null);
const registry = Object.create(null);
/**
 * Get unique id
 */
function uniqueId(namespace) {
    let counter = 0, id;
    while (registry[(id = namespace + counter)] !== void 0) {
        counter++;
    }
    return id;
}
exports.uniqueId = uniqueId;
/**
 * Add registry to storage
 */
function addRegistry(registry) {
    const namespace = registry.namespace, id = registry.id;
    if (namespaces[namespace] === void 0) {
        namespaces[namespace] = {
            ids: [id],
            data: Object.create(null),
        };
        return true;
    }
    namespaces[namespace].ids.push(id);
    return false;
}
exports.addRegistry = addRegistry;
/**
 * Save registry
 */
function saveRegistry(item) {
    registry[item.id] = item;
}
exports.saveRegistry = saveRegistry;
/**
 * Get shared data
 */
function getSharedData(namespace) {
    return namespaces[namespace].data;
}
exports.getSharedData = getSharedData;
/**
 * Delete registry entries
 */
function destroyRegistry(item) {
    if (registry[item.id] === void 0) {
        return;
    }
    // Delete registry from index
    delete registry[item.id];
    // Remove id from shared namespaces
    namespaces[item.namespace].ids = namespaces[item.namespace].ids.filter((id) => id !== item.id);
}
exports.destroyRegistry = destroyRegistry;
/**
 * Get Registry instance for id.
 *
 * This is used to pass registry as constant string in React/Svelte, so changes in Registry instance won't trigger refresh of entire UI.
 */
const getRegistry = (id) => registry[id];
exports.getRegistry = getRegistry;
//# sourceMappingURL=storage.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/route/convert.js":
/*!****************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/route/convert.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectToRoute = exports.objectToRouteParams = exports.routeToObject = exports.routeParamsToObject = void 0;
const defaults_1 = __webpack_require__(/*! ./defaults */ "./node_modules/@iconify/search-core/lib/route/defaults.js");
/**
 * TypeScript guard
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function
function assertNever(s) { }
/**
 * Get required and default values
 */
function getValues(type) {
    let defaults;
    let required;
    switch (type) {
        case 'collections':
            defaults = defaults_1.collectionsRouteDefaults;
            required = defaults_1.collectionsRouteMinimum;
            break;
        case 'collection':
            defaults = defaults_1.collectionRouteDefaults;
            required = defaults_1.collectionRouteMinimum;
            break;
        case 'search':
            defaults = defaults_1.searchRouteDefaults;
            required = defaults_1.searchRouteMinimum;
            break;
        case 'custom':
            defaults = defaults_1.customRouteDefaults;
            required = defaults_1.customRouteMinimum;
            break;
        case 'empty':
            defaults = defaults_1.emptyRouteDefaults;
            required = defaults_1.emptyRouteMinimum;
            break;
        default:
            assertNever(type);
            throw new Error(`Unknown route type: ${type}`);
    }
    return {
        defaults,
        required,
    };
}
/**
 * Remove default values from route
 */
const routeParamsToObject = (type, params) => {
    const result = {};
    const { defaults, required } = getValues(type);
    for (const key in defaults) {
        const value = params[key];
        if (
        // Save value if it is required
        required[key] !== void 0 ||
            // Save value if it is different
            value !== defaults[key]) {
            result[key] = value;
        }
    }
    return result;
};
exports.routeParamsToObject = routeParamsToObject;
/**
 * Convert route to object for export, ignoring default values
 */
const routeToObject = (route) => {
    const result = {
        type: route.type,
    };
    const params = exports.routeParamsToObject(route.type, route.params);
    if (Object.keys(params).length > 0) {
        result.params = params;
    }
    if (route.parent) {
        const parent = exports.routeToObject(route.parent);
        if (parent) {
            result.parent = parent;
        }
    }
    return result;
};
exports.routeToObject = routeToObject;
/**
 * List of parameters to change to lower case
 */
const toLowerCaseStrings = ['filter', 'search', 'provider'];
/**
 * Convert object to RouteParams
 */
const objectToRouteParams = (type, params) => {
    const result = {};
    const { defaults, required } = getValues(type);
    // Check for required properties
    for (const key in required) {
        if (typeof params[key] !== typeof required[key] ||
            params[key] === required[key]) {
            // Cannot have different type or empty value
            throw new Error(`Missing required route parameter "${key}" in objectToRouteParams()`);
        }
    }
    // Copy all values
    for (const key in defaults) {
        const defaultValue = defaults[key];
        if (params[key] === void 0) {
            // Use default
            result[key] = defaultValue;
            continue;
        }
        let value = params[key];
        const allowedType = defaultValue === null ? 'string' : typeof defaultValue;
        if (typeof value === allowedType) {
            // Matching type
            if (allowedType === 'string' &&
                toLowerCaseStrings.indexOf(key) !== -1) {
                // Change to lower case
                value = value.toLowerCase();
            }
            result[key] = value;
            continue;
        }
        // Exception: null where default value is not null
        if (value === null) {
            if (key === 'page' && type === 'collection') {
                result[key] = value;
                continue;
            }
        }
        // Invalid value
        result[key] = defaultValue;
    }
    return result;
};
exports.objectToRouteParams = objectToRouteParams;
/**
 * Convert object to Route, adding missing values
 */
const objectToRoute = (data, defaultRoute = null) => {
    // Check for valid object
    if (data === null ||
        typeof data !== 'object' ||
        typeof data.type !== 'string') {
        return defaultRoute;
    }
    // Check if route is valid
    const type = data.type;
    switch (type) {
        case 'collections':
        case 'collection':
        case 'custom':
        case 'search':
        case 'empty':
            break;
        default:
            assertNever(type);
            return defaultRoute;
    }
    // Get parameters
    let params;
    try {
        params = exports.objectToRouteParams(type, typeof data.params === 'object'
            ? data.params
            : {});
    }
    catch (err) {
        return defaultRoute;
    }
    // Get parent
    let parent = null;
    if (typeof data.parent === 'object' && data.parent !== null) {
        parent = exports.objectToRoute(data.parent, null);
        if (parent === null) {
            // Error in child route
            return defaultRoute;
        }
    }
    // Return result
    return {
        type,
        params,
        parent,
    };
};
exports.objectToRoute = objectToRoute;
//# sourceMappingURL=convert.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/route/defaults.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/route/defaults.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emptyRouteMinimum = exports.customRouteMinimum = exports.searchRouteMinimum = exports.collectionRouteMinimum = exports.collectionsRouteMinimum = exports.emptyRouteDefaults = exports.customRouteDefaults = exports.searchRouteDefaults = exports.collectionRouteDefaults = exports.collectionsRouteDefaults = void 0;
/**
 * Default values for route parameters
 */
exports.collectionsRouteDefaults = {
    provider: '',
    filter: '',
    category: null,
};
exports.collectionRouteDefaults = {
    provider: '',
    prefix: '',
    filter: '',
    icon: '',
    page: 0,
    tag: null,
    themePrefix: null,
    themeSuffix: null,
};
exports.searchRouteDefaults = {
    provider: '',
    search: '',
    short: true,
    page: 0,
};
exports.customRouteDefaults = {
    customType: '',
    filter: '',
    page: 0,
};
exports.emptyRouteDefaults = {};
/**
 * Partial default values, used to validate parameters in partial routes
 */
exports.collectionsRouteMinimum = {};
exports.collectionRouteMinimum = {
    prefix: '',
};
exports.searchRouteMinimum = {
    search: '',
};
exports.customRouteMinimum = {
    customType: '',
};
exports.emptyRouteMinimum = {};
//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/route/router.js":
/*!***************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/route/router.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Router = void 0;
const storage_1 = __webpack_require__(/*! ../registry/storage */ "./node_modules/@iconify/search-core/lib/registry/storage.js");
const convert_1 = __webpack_require__(/*! ./convert */ "./node_modules/@iconify/search-core/lib/route/convert.js");
const collections_1 = __webpack_require__(/*! ../views/collections */ "./node_modules/@iconify/search-core/lib/views/collections.js");
const collection_1 = __webpack_require__(/*! ../views/collection */ "./node_modules/@iconify/search-core/lib/views/collection.js");
const search_1 = __webpack_require__(/*! ../views/search */ "./node_modules/@iconify/search-core/lib/views/search.js");
const custom_1 = __webpack_require__(/*! ../views/custom */ "./node_modules/@iconify/search-core/lib/views/custom.js");
const empty_1 = __webpack_require__(/*! ../views/empty */ "./node_modules/@iconify/search-core/lib/views/empty.js");
const providers_1 = __webpack_require__(/*! ../data/providers */ "./node_modules/@iconify/search-core/lib/data/providers.js");
/**
 * TypeScript guard
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function
function assertNever(s) { }
/**
 * Change provider in home route
 */
function changeProvider(route, provider) {
    switch (route.type) {
        case 'collections':
        case 'collection':
        case 'search':
            if (route.params === void 0) {
                route.params = {};
            }
            route.params.provider = provider;
    }
    if (route.parent) {
        changeProvider(route.parent, provider);
    }
}
/**
 * Router class
 */
class Router {
    /**
     * Constructor
     *
     * @param instance
     * @param callback
     */
    constructor(instance) {
        // Current view
        this._view = null;
        // Currently visible view, could be different than current view
        this._visibleView = null;
        // Timer for replacing view
        this._timer = null;
        // Default API provider
        this.defaultProvider = '';
        this._instance = instance;
        const registry = storage_1.getRegistry(this._instance);
        // Subscribe to view events, handle them in the same handler
        const events = registry.events;
        events.subscribe('view-loaded', (view) => {
            this._viewEvent(view);
        });
        events.subscribe('view-updated', (view) => {
            this._viewEvent(view);
        });
    }
    /**
     * Get current error message
     */
    error() {
        return this._visibleView === null || this._visibleView.loading
            ? 'loading'
            : this._visibleView.error;
    }
    /**
     * Render currently visible view
     */
    render() {
        return this._visibleView === null ? null : this._visibleView.render();
    }
    /**
     * Set or get current route
     *
     * Route cannot be set to null. Setting route to null will result in home route.
     * Route could be null when reading it for the first time, so value null.
     */
    set partialRoute(route) {
        this._setRoute(route ? convert_1.objectToRoute(route) : null);
    }
    get partialRoute() {
        return this._visibleView
            ? convert_1.routeToObject(this._visibleView.route)
            : null;
    }
    set fullRoute(route) {
        this._setRoute(route);
    }
    get fullRoute() {
        return this._visibleView ? this._visibleView.route : null;
    }
    /**
     * Navigate to home
     */
    home(provider = null) {
        const registry = storage_1.getRegistry(this._instance);
        const config = registry.config;
        // Generate route
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const defaultRouteString = config.router.home;
        let route = null;
        if (defaultRouteString !== '') {
            // Use configured route
            route = convert_1.objectToRoute(JSON.parse(defaultRouteString));
        }
        else {
            // Detect route. Check custom icon sets first
            const customIconSets = registry.customIconSets;
            const currentProvider = typeof provider === 'string' ? provider : this.defaultProvider;
            if (customIconSets.providers[currentProvider] === void 0) {
                // No custom icon sets, use collections
                route = convert_1.objectToRoute({
                    type: 'collections',
                });
            }
            else {
                const customSetsData = customIconSets.providers[currentProvider];
                // Custom icon set exists
                let showCollections = customSetsData.total > 1;
                if (!showCollections &&
                    customIconSets.merge !== 'only-custom') {
                    // Show collections if API provider is valid
                    showCollections = this._checkProvider(currentProvider, false);
                }
                route = convert_1.objectToRoute(showCollections
                    ? {
                        type: 'collections',
                        params: {
                            provider: currentProvider,
                        },
                    }
                    : {
                        type: 'collection',
                        params: {
                            provider: currentProvider,
                            prefix: Object.keys(customSetsData.data).shift(),
                        },
                    });
            }
        }
        if (route === null) {
            throw new Error('Error resetting route');
        }
        // Change default provider
        changeProvider(route, provider === null || !this._checkProvider(provider)
            ? this.defaultProvider
            : provider);
        // Generate view
        const view = this._viewFromRoute(route);
        if (view === null) {
            throw new Error('Error resetting route');
        }
        // Change view
        this._setView(view, true);
    }
    /**
     * Apply action to currently visible view
     */
    action(action, value) {
        if (this._visibleView === null) {
            return;
        }
        // If visible view does not match current view, reset pending view. Action overrides previous view change
        this._changeCurrentView();
        // Apply action to current view
        this._visibleView.action(action, value);
    }
    /**
     * Set icons to view with matching customType
     *
     * View must be visible or pending
     */
    setCustomIcons(customType, icons) {
        const view = this._getCustomView(customType);
        if (view !== null) {
            view.setIcons(icons);
            return true;
        }
        return false;
    }
    /**
     * Get custom icons
     */
    getCustomIcons(customType) {
        const view = this._getCustomView(customType);
        return view === null ? null : view.getIcons();
    }
    /**
     * Set route
     */
    _setRoute(route) {
        let view;
        // Check provider
        if (route && route.params) {
            const provider = route.params
                .provider;
            if (typeof provider === 'string' &&
                provider !== '' &&
                !this._checkProvider(provider)) {
                route = null;
            }
        }
        // Attempt to create view
        if (route !== null && (view = this._viewFromRoute(route)) !== null) {
            this._setView(view, true);
            return;
        }
        // Error - navigate to home
        this.home();
    }
    /**
     * Find custom view
     */
    _getCustomView(customType) {
        if (this._visibleView === null || this._view === null) {
            return null;
        }
        // Check visible view
        if (this._visibleView.type === 'custom' &&
            this._visibleView.type === customType) {
            return this._visibleView;
        }
        // Check pending view
        if (this._view.type === 'custom' &&
            this._view.type === customType) {
            return this._view;
        }
        return null;
    }
    /**
     * Create child view
     */
    createChildView(route, parentLevels = 0) {
        const cleanRoute = route === null ? null : convert_1.objectToRoute(route);
        if (cleanRoute === null) {
            return;
        }
        // Set parent view
        let parentView = this._visibleView;
        for (let i = 0; i < parentLevels; i++) {
            if (parentView !== null) {
                parentView = parentView.parent;
            }
        }
        // Create view
        const view = this._viewFromRoute(cleanRoute, parentView);
        if (view === null) {
            return;
        }
        // Reset pending view
        this._changeCurrentView();
        // Set it as new view, but not immediately
        this._setView(view, false);
    }
    /**
     * Go up in parent views tree by "levels"
     */
    setParentView(levels = 1) {
        let view = this._visibleView;
        for (let i = 0; i < levels; i++) {
            if (view === null || view.parent === null) {
                return;
            }
            view = view.parent;
        }
        if (view !== this._visibleView) {
            this._setView(view, true);
        }
    }
    /**
     * Set view
     */
    _setView(view, immediate) {
        this._view = view;
        view.startLoading();
        if (this._visibleView !== view) {
            if (immediate || !view.loading || this._visibleView === null) {
                // Change visible view immediately and trigger event
                this._visibleView = view;
                this._triggerChange(true);
            }
            else {
                // Start timer that will change visible view and trigger event after delay
                this._startTimer();
            }
        }
    }
    /**
     * Reset current view to visible view
     */
    _changeCurrentView() {
        if (this._view !== this._visibleView) {
            this._view = this._visibleView;
            this._stopTimer();
            return true;
        }
        return false;
    }
    /**
     * Change visible view to current view
     */
    _changeVisibleView() {
        if (this._view !== this._visibleView) {
            this._visibleView = this._view;
            this._stopTimer();
            this._triggerChange(true);
            return true;
        }
        return false;
    }
    /**
     * Create view from route
     */
    _viewFromRoute(route, parentView = void 0) {
        // Get parent view
        let parent = null;
        if (parentView !== void 0) {
            parent = parentView;
            route.parent = parentView === null ? null : parentView.route;
        }
        else if (route.parent !== null) {
            parent = this._viewFromRoute(route.parent);
            if (parent === null) {
                return null;
            }
        }
        // Create view
        switch (route.type) {
            case 'collections':
                return new collections_1.CollectionsView(this._instance, route, parent);
            case 'collection':
                return new collection_1.CollectionView(this._instance, route, parent);
            case 'search':
                return new search_1.SearchView(this._instance, route, parent);
            case 'custom':
                return new custom_1.CustomView(this._instance, route, parent);
            case 'empty':
                return new empty_1.EmptyView(this._instance, route, parent);
            default:
                assertNever(route);
                return null;
        }
    }
    /**
     * Handle event from view
     */
    _viewEvent(view) {
        if (view !== this._view) {
            // Action for different view - ignore it
            return;
        }
        // Change visible view if it doesn't match view.
        // Function also calls _triggerChange(true)
        if (this._changeVisibleView()) {
            return;
        }
        // Something changed in visible view
        this._triggerChange(false);
    }
    /**
     * Something has changed in visible view
     */
    _triggerChange(viewChanged) {
        const registry = storage_1.getRegistry(this._instance);
        const events = registry.events;
        // Render blocks first, it might change error or route
        const blocks = this.render();
        // Create item
        const item = {
            viewChanged,
            error: this.error(),
            route: this.partialRoute,
            blocks,
        };
        events.fire('render', item);
    }
    /**
     * Start timer to change visible view
     */
    _startTimer() {
        this._stopTimer();
        const registry = storage_1.getRegistry(this._instance);
        const config = registry.config;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const timeout = config.ui.viewUpdateDelay;
        if (!timeout) {
            this._changeVisibleView();
        }
        else {
            // Store current view, change it on timer
            const view = this._view;
            this._timer = setTimeout(() => {
                if (this._view === view) {
                    this._changeVisibleView();
                }
            }, timeout);
        }
    }
    /**
     * Stop loading timer
     */
    _stopTimer() {
        if (this._timer !== null) {
            clearTimeout(this._timer);
            this._timer = null;
        }
    }
    /**
     * Check if provider exists
     */
    _checkProvider(provider, checkCustom = true) {
        // Get provider
        const result = providers_1.getProvider(provider);
        if (result !== null) {
            return true;
        }
        // Test custom icon sets. Allow invalid provider if it has custom data
        if (!checkCustom) {
            return false;
        }
        const registry = storage_1.getRegistry(this._instance);
        const customIconSets = registry.customIconSets;
        return customIconSets.providers[provider] !== void 0;
    }
}
exports.Router = Router;
//# sourceMappingURL=router.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/views/base.js":
/*!*************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/views/base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseView = void 0;
const storage_1 = __webpack_require__(/*! ../registry/storage */ "./node_modules/@iconify/search-core/lib/registry/storage.js");
const providers_1 = __webpack_require__(/*! ../data/providers */ "./node_modules/@iconify/search-core/lib/data/providers.js");
/**
 * Base view class
 */
class BaseView {
    constructor() {
        this.type = '';
        this.parent = null;
        this.updating = false;
        this.error = '';
        this.blocksRequireUpdate = true;
        // Loading status
        this.loading = true;
        this._loadingTimer = null;
        this._alreadyLoaded = false;
        this._startedLoading = false;
        // Loading control: waiting for parent view
        this.onLoad = null;
        this._mustWaitForParent = false;
        this._isSync = null;
    }
    /**
     * Set _isSync variable
     */
    _checkSync() {
        if (this._isSync === null) {
            this._isSync = !!storage_1.getRegistry(this._instance).config.router
                .syncRender;
        }
        return this._isSync;
    }
    /**
     * Change parent view
     */
    _parentAction(value) {
        if (this.parent === null) {
            return;
        }
        const levels = typeof value === 'number' && value > 0 ? value : 1;
        const registry = storage_1.getRegistry(this._instance);
        const router = registry.router;
        router.setParentView(levels);
    }
    /**
     * Change provider
     */
    _providerAction(value) {
        if (typeof value !== 'string') {
            return;
        }
        const providerData = providers_1.getProvider(value);
        if (!providerData) {
            return;
        }
        const registry = storage_1.getRegistry(this._instance);
        const router = registry.router;
        router.home(value);
    }
    /**
     * Start loading
     */
    startLoading() {
        if (this._startedLoading) {
            return;
        }
        // Already loaded somehow (by setting data directly)
        if (!this.loading) {
            this._startedLoading = true;
            return;
        }
        // Start loading
        if (this._mustWaitForParent && this.parent !== null) {
            this.parent.startLoading();
        }
        this._startLoading();
    }
    /**
     * Start loading
     */
    _startLoading() {
        this._startedLoading = true;
        if (this._checkSync()) {
            this._startLoadingData();
        }
        else {
            setTimeout(() => {
                this._startLoadingData();
            });
        }
    }
    _startLoadingData() {
        throw new Error('startLoading should not be called on base view');
    }
    /**
     * Search action
     */
    _searchAction(provider, value) {
        if (typeof value !== 'string' || value.trim() === '') {
            return;
        }
        const keyword = value.trim().toLowerCase();
        // Check for collections
        let view = this;
        let levels = 0;
        while (view.type !== 'collections') {
            if (view.parent === null) {
                return;
            }
            view = view.parent;
            levels++;
        }
        // Apply action to collections
        const registry = storage_1.getRegistry(this._instance);
        const router = registry.router;
        router.createChildView({
            type: 'search',
            params: {
                provider,
                search: keyword,
            },
        }, levels);
    }
    /**
     * Load data from API
     */
    _loadAPI(provider, query, params, cacheKey = true) {
        const registry = storage_1.getRegistry(this._instance);
        const api = registry.api;
        // Send query
        api.query(provider, query, params, (data, error) => {
            if (data === void 0) {
                // Error
                if (this.loading) {
                    this.error = error === 404 ? 'not_found' : 'timeout';
                    this.loading = false;
                    this._triggerLoaded();
                }
                return;
            }
            if (data === null || !this._mustWaitForParent) {
                // Parse immediately
                this._parseAPIData(data);
                return;
            }
            // Parse data after parent view has finished loading
            this._waitForParent(() => {
                this._parseAPIData(data);
            });
        }, cacheKey);
    }
    /**
     * Wait for parent view to load
     */
    _waitForParent(callback) {
        if (!this._mustWaitForParent ||
            this.parent === null ||
            !this.parent.loading) {
            callback();
            return;
        }
        // Wait for parent
        this.parent.onLoad = callback;
    }
    /**
     * Parse data from API
     *
     * Should be overwritten by child classes
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-unused-vars
    _parseAPIData(data) {
        throw new Error('_parseAPIData should not be called on base view');
    }
    /**
     * Send event when view has been loaded
     *
     * Can be sent synchronously
     */
    _triggerLoaded() {
        if (this._alreadyLoaded) {
            // Do not trigger event twice
            this._triggerUpdated();
            return;
        }
        this._alreadyLoaded = true;
        const registry = storage_1.getRegistry(this._instance);
        const events = registry.events;
        events.fire('view-loaded', this);
        // Trigger onLoad event for child view
        if (this.onLoad !== null) {
            const onLoad = this.onLoad;
            this.onLoad = null;
            onLoad();
        }
    }
    /**
     * Send event when view has been updated
     *
     * Must be sent asynchronously to consume multiple updates
     */
    _triggerUpdated() {
        if (!this.updating) {
            this.updating = true;
            const update = () => {
                this.updating = false;
                const registry = storage_1.getRegistry(this._instance);
                const events = registry.events;
                events.fire('view-updated', this);
            };
            if (this._checkSync()) {
                update();
            }
            else {
                setTimeout(update);
            }
        }
    }
}
exports.BaseView = BaseView;
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/views/collection.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/views/collection.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectionView = void 0;
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@iconify/search-core/lib/views/base.js");
const collection_info_1 = __webpack_require__(/*! ../blocks/collection-info */ "./node_modules/@iconify/search-core/lib/blocks/collection-info.js");
const filters_1 = __webpack_require__(/*! ../blocks/filters */ "./node_modules/@iconify/search-core/lib/blocks/filters.js");
const collection_1 = __webpack_require__(/*! ../converters/collection */ "./node_modules/@iconify/search-core/lib/converters/collection.js");
const icons_list_1 = __webpack_require__(/*! ../blocks/icons-list */ "./node_modules/@iconify/search-core/lib/blocks/icons-list.js");
const pagination_1 = __webpack_require__(/*! ../blocks/pagination */ "./node_modules/@iconify/search-core/lib/blocks/pagination.js");
const storage_1 = __webpack_require__(/*! ../registry/storage */ "./node_modules/@iconify/search-core/lib/registry/storage.js");
const search_1 = __webpack_require__(/*! ../blocks/search */ "./node_modules/@iconify/search-core/lib/blocks/search.js");
const collections_list_1 = __webpack_require__(/*! ../blocks/collections-list */ "./node_modules/@iconify/search-core/lib/blocks/collections-list.js");
const collections_1 = __webpack_require__(/*! ../data/collections */ "./node_modules/@iconify/search-core/lib/data/collections.js");
const base_2 = __webpack_require__(/*! ../api/base */ "./node_modules/@iconify/search-core/lib/api/base.js");
const filterKeys = [
    'tags',
    'themePrefixes',
    'themeSuffixes',
];
/**
 * Class
 */
class CollectionView extends base_1.BaseView {
    /**
     * Create view
     */
    constructor(instance, route, parent = null) {
        super();
        this._data = null;
        this._blocks = null;
        this.type = 'collection';
        this._instance = instance;
        this.route = route;
        this.provider = route.params.provider;
        this.parent = parent;
        this.prefix = route.params.prefix;
        // Check if custom icon set is used
        const registry = storage_1.getRegistry(this._instance);
        const customSets = registry.customIconSets;
        if (customSets.providers[this.provider] !== void 0 &&
            customSets.providers[this.provider].data[this.prefix] !== void 0) {
            this._isCustom = true;
            this._data = customSets.providers[this.provider].data[this.prefix];
        }
        else {
            this._isCustom = false;
        }
        // Wait for parent to load if parent view is search or collections list
        this._mustWaitForParent =
            parent !== null &&
                (parent.type === 'search' || parent.type === 'collections');
        // Check for cache
        if (!this._data) {
            const cache = registry.getCustom('core-cache');
            if (typeof cache === 'object' && cache[this.provider]) {
                const collectionCache = cache[this.provider].collection;
                if (collectionCache && collectionCache[this.prefix]) {
                    this._data = collectionCache[this.prefix];
                }
            }
        }
    }
    /**
     * Start loading
     */
    _startLoadingData() {
        if (!this._data) {
            const params = {
                prefix: this.prefix,
                info: 'true',
                chars: 'true',
                aliases: 'true',
            };
            if (this.route.params.icon !== '') {
                // Ask for hidden icons (icons that were removed from icon set) if route has a
                // reference icon, in case if reference icon is hidden.
                params.hidden = 'true';
            }
            this._loadAPI(this.provider, '/collection', params, base_2.collectionCacheKey(this.prefix));
        }
        else {
            this._parseAPIData(null);
        }
    }
    /**
     * Run action on view
     */
    action(action, value) {
        switch (action) {
            // Select parent view
            case 'parent':
                this._parentAction(value);
                return;
            // Change provider
            case 'provider':
                if (value !== this.provider) {
                    this._providerAction(value);
                }
                return;
            // Global search
            case 'search':
                this._searchAction(this.provider, value);
                return;
            // Search icons
            case 'filter':
                if (typeof value !== 'string') {
                    return;
                }
                value = value.trim().toLowerCase();
                if (value === this.route.params.filter) {
                    return;
                }
                this.route.params.filter = value;
                this.blocksRequireUpdate = true;
                break;
            // Change current page
            case 'pagination':
                if (typeof value === 'string') {
                    value = parseInt(value);
                }
                // Check number
                if (typeof value !== 'number' ||
                    isNaN(value) ||
                    value < 0 ||
                    value === this.route.params.page) {
                    return;
                }
                // Change page
                this.route.params.page = value;
                this.blocksRequireUpdate = true;
                break;
            // Change reference icon
            case 'icon':
                if (value === '' || value === null) {
                    // Reset
                    this.route.params.icon = '';
                    break;
                }
                // Check type
                if (typeof value !== 'string') {
                    return;
                }
                // Change reference icon and automatically set page
                this.route.params.icon = value;
                this.route.params.page = null;
                this.blocksRequireUpdate = true;
                break;
            // Filters
            case 'tags':
                this._filterAction('tag', value);
                return;
            case 'themePrefixes':
                this._filterAction('themePrefix', value);
                return;
            case 'themeSuffixes':
                this._filterAction('themeSuffix', value);
                return;
            // Parent view's filter
            case 'collections':
                this._collectionsAction(value);
                return;
            default:
                return;
        }
        // Action has changed something - trigger update event
        this._triggerUpdated();
    }
    /**
     * Filter action
     */
    _filterAction(key, value) {
        if (value !== null && typeof value !== 'string') {
            return;
        }
        if (this.route.params[key] === value) {
            return;
        }
        this.route.params[key] = value;
        this.blocksRequireUpdate = true;
        this._triggerUpdated();
    }
    /**
     * Change active collection
     */
    _collectionsAction(value) {
        if (this.parent === null ||
            (this.parent.type !== 'search' &&
                this.parent.type !== 'collections')) {
            return;
        }
        // If value matches this collection, navigate to parent view
        if (value === this.prefix || value === null) {
            this._parentAction(1);
            return;
        }
        // Run action on parent view
        if (typeof value === 'string') {
            this.parent.action('collections-internal', value);
        }
    }
    /**
     * Find icon in icons list
     *
     * Returns false on failure
     */
    _getIconIndex(icons, name) {
        for (let i = 0; i < icons.length; i++) {
            const icon = icons[i];
            if (icon.name === name) {
                return i;
            }
            if (icon.aliases) {
                const aliases = icon.aliases;
                for (let j = 0; j < aliases.length; j++) {
                    if (aliases[j] === name) {
                        return i;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Render blocks
     */
    render() {
        if (this.loading || this._blocks === null || this._data === null) {
            return null;
        }
        // Check if blocks have been cached or if there is a error
        if (!this.blocksRequireUpdate || this.error !== '') {
            return this._blocks;
        }
        this.blocksRequireUpdate = false;
        // Apply route to blocks
        const blocks = this._blocks;
        // Copy icons
        blocks.icons.icons = this._data.icons.slice(0);
        // Set active filters
        blocks.filter.keyword = this.route.params.filter;
        if (blocks.tags !== null) {
            blocks.tags.active = this.route.params.tag;
        }
        if (blocks.themePrefixes !== null) {
            blocks.themePrefixes.active = this.route.params.themePrefix;
        }
        if (blocks.themeSuffixes !== null) {
            blocks.themeSuffixes.active = this.route.params.themeSuffix;
        }
        // Apply search
        icons_list_1.applyIconFilters(blocks.icons, blocks.filter, filterKeys
            .filter((key) => blocks[key] !== null)
            .map((key) => blocks[key]));
        const iconsBlock = blocks.icons;
        const iconsList = iconsBlock.icons;
        // Get current page
        const perPage = blocks.pagination.perPage;
        const referenceIcon = this.route.params.icon;
        let page;
        if (this.route.params.page !== null) {
            page = this.route.params.page;
        }
        else if (referenceIcon === '') {
            page = 0;
        }
        else {
            const iconIndex = this._getIconIndex(iconsList, referenceIcon);
            page =
                iconIndex === false ? 0 : pagination_1.getPageForIndex(perPage, iconIndex);
        }
        // Check pagination
        blocks.pagination.length = iconsBlock.icons.length;
        blocks.pagination.page = page;
        const maximumPage = pagination_1.maxPage(blocks.pagination);
        if (maximumPage < blocks.pagination.page) {
            this.route.params.page = blocks.pagination.page = maximumPage;
        }
        // Apply pagination
        const startIndex = blocks.pagination.page * perPage;
        const nextIndex = Math.min(startIndex + perPage, iconsList.length + 1);
        iconsBlock.icons = iconsList.slice(startIndex, nextIndex);
        // Navigation
        if (iconsList.length > 1) {
            // Add first/last icon
            iconsBlock.first = iconsList[0];
            iconsBlock.last = iconsList[iconsList.length - 1];
            // Add previous/next icon
            iconsBlock.prev =
                startIndex > 0 ? iconsList[startIndex - 1] : iconsBlock.last;
            iconsBlock.next =
                iconsList[nextIndex] === void 0
                    ? iconsBlock.first
                    : iconsList[nextIndex];
        }
        else {
            // Nothing to navigate
            delete iconsBlock.first;
            delete iconsBlock.last;
            delete iconsBlock.prev;
            delete iconsBlock.next;
        }
        return this._blocks;
    }
    /**
     * Parse data from API
     *
     * Should be overwritten by child classes
     */
    _parseAPIData(data) {
        if (!this._data && !this._isCustom) {
            this._data = collection_1.dataToCollection(this.provider, data);
        }
        // Mark as loaded, mark blocks for re-render and reset error
        this.loading = false;
        this.blocksRequireUpdate = true;
        this.error = '';
        // Create empty blocks
        this._blocks = {
            // Info
            info: collection_info_1.defaultCollectionInfoBlock(),
            // Search
            filter: Object.assign(search_1.defaultSearchBlock(), {
                keyword: this.route.params.filter,
                searchType: 'collection',
                title: this.prefix,
            }),
            // Filters
            collections: null,
            tags: null,
            themePrefixes: null,
            themeSuffixes: null,
            // Icons and pagination
            icons: icons_list_1.defaultIconsListBlock(),
            pagination: pagination_1.defaultPaginationBlock(),
        };
        const initialisedBlocks = this._blocks;
        // Check if data was valid
        if (this._data === null) {
            this.error = data === null ? 'not_found' : 'invalid_data';
            this._triggerLoaded();
            return;
        }
        const parsedData = this._data;
        // Validate prefix
        if (this.prefix !== parsedData.prefix) {
            this.error = 'invalid_data';
            this._triggerLoaded();
            return;
        }
        // Get registry and modules
        const registry = storage_1.getRegistry(this._instance);
        const config = registry.config;
        const collections = registry.collections;
        // Set info
        initialisedBlocks.info.prefix = this.prefix;
        if (parsedData.info !== void 0) {
            // Store info in collections storage
            collections_1.setCollectionInfo(collections, this.provider, this.prefix, parsedData.info);
        }
        // Get info from collections storage because it might include index for color scheme
        initialisedBlocks.info.info = collections_1.getCollectionInfo(collections, this.provider, this.prefix);
        if (initialisedBlocks.info.info !== null) {
            initialisedBlocks.filter.title = initialisedBlocks.info.info.name;
        }
        // Check if there are any icons
        if (parsedData.total < 1) {
            this.error = 'empty';
        }
        else {
            // Create pagination
            const pagination = initialisedBlocks.pagination;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            pagination.perPage = config.ui.itemsPerPage;
            pagination.fullLength = pagination.length = parsedData.icons.length;
            const page = this.route.params.page;
            pagination.page =
                page === null ? 0 : Math.min(page, pagination_1.maxPage(pagination));
            // Copy full icons list for possible use in UI
            this._blocks.icons.allIcons = parsedData.icons;
            // Copy collections filter from parent view
            if (this.parent && !this.parent.loading) {
                if (this.parent.type === 'search') {
                    // Get copy of block from parent view
                    const collectionsBlock = this
                        .parent.getCollectionsBlock();
                    if (collectionsBlock !== null) {
                        // Copy block and set active filter
                        this._blocks.collections = collectionsBlock;
                        this._blocks.collections.active = this.prefix;
                    }
                }
                else if (this.parent.type === 'collections') {
                    // Find previous / next items
                    this._blocks.collections = this._findSiblingCollections();
                }
            }
            // Icon filters
            let startIndex = 0;
            filterKeys.forEach((key) => {
                const dataKey = key;
                if (parsedData[dataKey] !== void 0) {
                    const item = parsedData[dataKey];
                    const isArray = item instanceof Array;
                    const list = (isArray
                        ? item
                        : Object.values(item));
                    const listKeys = isArray
                        ? []
                        : Object.keys(item);
                    if (list instanceof Array && list.length > 1) {
                        // Create empty filters block
                        const filter = filters_1.defaultFiltersBlock();
                        filter.filterType = key;
                        initialisedBlocks[key] = filter;
                        // Copy all filters
                        list.forEach((tag, index) => {
                            const item = filters_1.defaultFilter(tag);
                            if (!isArray) {
                                item.match = listKeys[index];
                            }
                            filter.filters[tag] = item;
                        });
                        // Apply index
                        startIndex = filters_1.autoIndexFilters(filter, startIndex);
                    }
                }
            });
        }
        // Send event
        this._triggerLoaded();
    }
    /**
     * Find sibling collections from collections list, return them as block
     */
    _findSiblingCollections() {
        const collectionsBlock = this
            .parent.getCollectionsBlock();
        if (collectionsBlock === null) {
            return null;
        }
        const collections = collections_list_1.collectionsPrefixesWithInfo(collectionsBlock);
        const match = collections.find((item) => item.prefix === this.prefix);
        if (match === void 0 || collections.length < 2) {
            return null;
        }
        // Get limit
        const registry = storage_1.getRegistry(this._instance);
        const config = registry.config;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const limit = config.ui.showSiblingCollections;
        // Get items before and after current prefix
        let display = [];
        if (collections.length < limit * 2 + 2) {
            // Display all collections
            display = collections.slice(0);
        }
        else {
            const index = collections.indexOf(match);
            // few items before current
            for (let i = index - limit; i < index; i++) {
                display.push(collections[(i + collections.length) % collections.length]);
            }
            // Current item
            display.push(match);
            // few items after current
            for (let i = index + 1; i <= index + limit; i++) {
                display.push(collections[i % collections.length]);
            }
        }
        // Create block
        const block = filters_1.defaultFiltersBlock();
        block.filterType = 'collections';
        block.active = this.prefix;
        display.forEach((item) => {
            const filter = filters_1.defaultFilter(item.name);
            filter.index = item.index;
            block.filters[item.prefix] = filter;
        });
        return block;
    }
}
exports.CollectionView = CollectionView;
//# sourceMappingURL=collection.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/views/collections.js":
/*!********************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/views/collections.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectionsView = void 0;
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@iconify/search-core/lib/views/base.js");
const collections_filter_1 = __webpack_require__(/*! ../blocks/collections-filter */ "./node_modules/@iconify/search-core/lib/blocks/collections-filter.js");
const collections_list_1 = __webpack_require__(/*! ../blocks/collections-list */ "./node_modules/@iconify/search-core/lib/blocks/collections-list.js");
const filters_1 = __webpack_require__(/*! ../blocks/filters */ "./node_modules/@iconify/search-core/lib/blocks/filters.js");
const collections_1 = __webpack_require__(/*! ../converters/collections */ "./node_modules/@iconify/search-core/lib/converters/collections.js");
const storage_1 = __webpack_require__(/*! ../registry/storage */ "./node_modules/@iconify/search-core/lib/registry/storage.js");
const collections_2 = __webpack_require__(/*! ../data/collections */ "./node_modules/@iconify/search-core/lib/data/collections.js");
const custom_sets_1 = __webpack_require__(/*! ../data/custom-sets */ "./node_modules/@iconify/search-core/lib/data/custom-sets.js");
const base_2 = __webpack_require__(/*! ../api/base */ "./node_modules/@iconify/search-core/lib/api/base.js");
/**
 * Class
 */
class CollectionsView extends base_1.BaseView {
    /**
     * Create view
     */
    constructor(instance, route, parent = null) {
        super();
        this._data = null;
        this._blocks = null;
        this.type = 'collections';
        this._instance = instance;
        this.route = route;
        this.provider = route.params.provider;
        this.parent = parent;
        // Check if custom icon set is used
        const registry = storage_1.getRegistry(this._instance);
        const customSets = registry.customIconSets;
        if (customSets.providers[this.provider] !== void 0) {
            this._sources = {
                custom: true,
                api: customSets.merge !== 'only-custom',
                merge: customSets.merge,
            };
        }
        else {
            this._sources = {
                custom: false,
                api: true,
            };
        }
        // Check for cache
        const cache = registry.getCustom('core-cache');
        if (typeof cache === 'object') {
            const providerCache = cache[this.provider];
            if (providerCache && providerCache.collections) {
                this._data = providerCache.collections;
            }
        }
    }
    /**
     * Start loading
     */
    _startLoadingData() {
        if (this._data || !this._sources.api) {
            this._parseAPIData(null);
            return;
        }
        this._loadAPI(this.provider, '/collections', {}, base_2.collectionsCacheKey());
    }
    /**
     * Run action on view
     */
    action(action, value) {
        switch (action) {
            // Parent view
            case 'parent':
                this._parentAction(value);
                return;
            // Change provider
            case 'provider':
                if (value !== this.provider) {
                    this._providerAction(value);
                }
                return;
            // Global search
            case 'search':
                if (this._sources.api) {
                    this._searchAction(this.provider, value);
                }
                return;
            // Filter collections
            case 'filter':
                if (typeof value !== 'string') {
                    return;
                }
                value = value.trim().toLowerCase();
                if (this.route.params.filter !== value) {
                    this.route.params.filter = value;
                    this.blocksRequireUpdate = true;
                }
                else {
                    return;
                }
                break;
            // Filter categories
            case 'categories':
                if ((value === null || typeof value === 'string') &&
                    value !== this.route.params.category) {
                    this.route.params.category = value;
                    this.blocksRequireUpdate = true;
                }
                else {
                    return;
                }
                break;
            // Select collection, called from child view
            case 'collections-internal':
                if (typeof value !== 'string' || value === '') {
                    return;
                }
                this._triggerCollectionAction(value, 1);
                return;
            // Select collection
            case 'collections':
                if (typeof value !== 'string' || value === '') {
                    return;
                }
                this._triggerCollectionAction(value, 0);
                return;
            default:
                return;
        }
        // Action has changed something - trigger update event
        this._triggerUpdated();
    }
    /**
     * Create child view for prefix
     */
    _triggerCollectionAction(prefix, levels) {
        // Try to find prefix in collections list
        if (!this.loading && this._data !== null && this.error === '') {
            // Find matching prefix
            const categories = Object.keys(this._data);
            let found = false;
            for (let i = 0; i < categories.length; i++) {
                if (this._data[categories[i]][prefix] !== void 0) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return;
            }
        }
        // Create child view
        const registry = storage_1.getRegistry(this._instance);
        const router = registry.router;
        router.createChildView({
            type: 'collection',
            params: {
                provider: this.provider,
                prefix: prefix,
            },
        }, levels);
    }
    /**
     * Render blocks
     */
    render() {
        if (this.loading || this._blocks === null || this._data === null) {
            return null;
        }
        // Check if blocks have been cached or if there is a error
        if (!this.blocksRequireUpdate || this.error !== '') {
            return this._blocks;
        }
        this.blocksRequireUpdate = false;
        // Apply route to blocks
        const blocks = this._blocks;
        const keyword = typeof this.route.params.filter === 'string'
            ? this.route.params.filter
            : '';
        const category = typeof this.route.params.category === 'string'
            ? this.route.params.category
            : null;
        // Set keyword and active category
        blocks.filter.keyword = keyword;
        blocks.categories.active = category;
        // Set collections
        blocks.collections.collections = this._data;
        // Apply search filter and change disabled categories in categories filter
        blocks.collections = collections_list_1.applyCollectionsFilter(blocks.collections, blocks.filter, blocks.categories);
        // Apply category filter
        if (category !== null) {
            blocks.collections = collections_list_1.disableInactiveCategories(blocks.collections, category);
        }
        return blocks;
    }
    /**
     * Get collections block.
     *
     * Used by child view.
     */
    getCollectionsBlock() {
        if (this.loading || this.error !== '') {
            return null;
        }
        const blocks = this.render();
        return blocks !== null && blocks.collections !== null
            ? blocks.collections
            : null;
    }
    /**
     * Parse data from API
     *
     * Should be overwritten by child classes
     */
    _parseAPIData(data) {
        if (this._sources.api && !data && !this._data) {
            // Error
            this._data = null;
        }
        else if (!this._data) {
            // Convert and merge data
            this._data = custom_sets_1.mergeCollections(this.route.params.provider, this._sources.api
                ? collections_1.dataToCollections(data)
                : null, this._sources.custom
                ? storage_1.getRegistry(this._instance).customIconSets
                : null);
        }
        // Mark as loaded and mark blocks for re-render
        this.loading = false;
        this.blocksRequireUpdate = true;
        this.error = '';
        // Create blocks
        this._blocks = {
            filter: collections_filter_1.defaultCollectionsFilterBlock(),
            categories: filters_1.defaultFiltersBlock(),
            collections: collections_list_1.defaultCollectionsListBlock(),
        };
        this._blocks.categories.filterType = 'categories';
        // Parse data
        if (this._data === null) {
            this.error = data === null ? 'not_found' : 'invalid_data';
        }
        else {
            // Add indexes to collections
            collections_1.autoIndexCollections(this._data);
            // Set collections
            this._blocks.collections.collections = this._data;
            // Get categories
            const categories = collections_list_1.getCollectionsBlockCategories(this._blocks.collections, true);
            if (categories.length === 0) {
                this.error = 'empty';
            }
            else {
                if (categories.length > 1) {
                    // Set category filters
                    this._blocks.collections.showCategories = true;
                    const filters = this._blocks.categories.filters;
                    categories.forEach((category) => {
                        filters[category] = filters_1.defaultFilter(category);
                    });
                    filters_1.autoIndexFilters(this._blocks.categories);
                }
                else {
                    // Disable category filters
                    this._blocks.collections.showCategories = false;
                }
                // Store collections in global data
                const registry = storage_1.getRegistry(this._instance);
                const collections = registry.collections;
                collections_list_1.iterateCollectionsBlock(this._blocks.collections, (item, prefix) => {
                    collections_2.setCollectionInfo(collections, this.provider, prefix, item);
                });
            }
        }
        // Send event
        this._triggerLoaded();
    }
}
exports.CollectionsView = CollectionsView;
//# sourceMappingURL=collections.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/views/custom.js":
/*!***************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/views/custom.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomView = void 0;
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@iconify/search-core/lib/views/base.js");
const icons_list_1 = __webpack_require__(/*! ../blocks/icons-list */ "./node_modules/@iconify/search-core/lib/blocks/icons-list.js");
const pagination_1 = __webpack_require__(/*! ../blocks/pagination */ "./node_modules/@iconify/search-core/lib/blocks/pagination.js");
const storage_1 = __webpack_require__(/*! ../registry/storage */ "./node_modules/@iconify/search-core/lib/registry/storage.js");
const icon_1 = __webpack_require__(/*! ../misc/icon */ "./node_modules/@iconify/search-core/lib/misc/icon.js");
const search_1 = __webpack_require__(/*! ../blocks/search */ "./node_modules/@iconify/search-core/lib/blocks/search.js");
const objects_1 = __webpack_require__(/*! ../misc/objects */ "./node_modules/@iconify/search-core/lib/misc/objects.js");
/**
 * Class
 */
class CustomView extends base_1.BaseView {
    /**
     * Create view
     */
    constructor(instance, route, parent = null) {
        super();
        this._data = null;
        this._blocks = null;
        this.type = 'custom';
        this._instance = instance;
        this.route = route;
        this.parent = parent;
        this.customType = route.params.customType;
        this._mustWaitForParent = true;
    }
    /**
     * Start loading
     */
    _startLoadingData() {
        if (this._data !== null) {
            return;
        }
        const registry = storage_1.getRegistry(this._instance);
        const events = registry.events;
        // Fire public event, exposed to external code
        events.fire('load-' + this.customType, this.setIcons.bind(this));
    }
    /**
     * Run action on view
     */
    action(action, value) {
        switch (action) {
            // Change view
            case 'parent':
                this._parentAction(value);
                return;
            // Change provider
            case 'provider':
                this._providerAction(value);
                return;
            // Set icons
            case 'set':
                this.setIcons(value);
                // Returning because setIcons will trigger event
                return;
            // Search icons
            case 'filter':
                if (typeof value !== 'string') {
                    return;
                }
                value = value.trim().toLowerCase();
                if (value === this.route.params.filter) {
                    return;
                }
                this.route.params.filter = value;
                this.blocksRequireUpdate = true;
                break;
            // Change current page
            case 'pagination':
                if (typeof value === 'string') {
                    value = parseInt(value);
                }
                // Check number
                if (typeof value !== 'number' ||
                    isNaN(value) ||
                    value < 0 ||
                    value === this.route.params.page) {
                    return;
                }
                // Change page
                this.route.params.page = value;
                this.blocksRequireUpdate = true;
                break;
            default:
                return;
        }
        // Action has changed something - trigger update event
        this._triggerUpdated();
    }
    /**
     * Render blocks
     */
    render() {
        if (this.loading || this._blocks === null || this._data === null) {
            return null;
        }
        // Check if blocks have been cached or if there is a error
        if (!this.blocksRequireUpdate || this.error !== '') {
            return this._blocks;
        }
        this.blocksRequireUpdate = false;
        // Apply route to blocks
        const blocks = this._blocks;
        // Copy icons
        blocks.icons.icons = this._data.slice(0);
        // Search icons
        blocks.filter.keyword = this.route.params.filter;
        icons_list_1.applyIconFilters(blocks.icons, blocks.filter, [], true);
        // Get items per page
        const registry = storage_1.getRegistry(this._instance);
        const config = registry.config;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const itemsPerPage = config.ui.itemsPerPage;
        // Check pagination
        blocks.pagination.length = blocks.icons.icons.length;
        blocks.pagination.page = this.route.params.page;
        const maximumPage = pagination_1.maxPage(blocks.pagination);
        if (maximumPage < blocks.pagination.page) {
            this.route.params.page = blocks.pagination.page = maximumPage;
        }
        // Apply pagination
        const startIndex = blocks.pagination.page * itemsPerPage;
        blocks.icons.icons = blocks.icons.icons.slice(startIndex, startIndex + itemsPerPage);
        return this._blocks;
    }
    /**
     * Set icons
     */
    setIcons(data) {
        this._waitForParent(() => {
            if (!this._checkSync()) {
                // Make sure its async unless synchronous loading is enabled
                setTimeout(() => {
                    this._setIcons(data);
                });
            }
            else {
                this._setIcons(data);
            }
        });
    }
    _setIcons(data) {
        // Check if data is valid
        let dataArray = data;
        let invalidData = false;
        if (!(dataArray instanceof Array)) {
            invalidData = true;
            dataArray = [];
        }
        // Filter data
        const parsedData = dataArray
            .map((item) => {
            // Convert strings
            if (typeof item === 'string') {
                item = icon_1.stringToIcon(item);
            }
            // Validate object
            if (typeof item === 'object' && icon_1.validateIcon(item)) {
                const icon = item;
                return {
                    provider: icon.provider,
                    prefix: icon.prefix,
                    name: icon.name,
                };
            }
            // Invalid icon
            return null;
        })
            .filter((icon) => icon !== null);
        // Save data
        this._data = parsedData;
        // Mark as loaded, mark blocks for re-render and reset error
        this.loading = false;
        this.blocksRequireUpdate = true;
        this.error = '';
        // Create empty blocks
        this._blocks = {
            // Search
            filter: Object.assign(search_1.defaultSearchBlock(), {
                keyword: this.route.params.filter,
                searchType: 'custom',
                title: this.customType,
            }),
            // Icons and pagination
            icons: icons_list_1.defaultIconsListBlock(),
            pagination: pagination_1.defaultPaginationBlock(),
        };
        const initialisedBlocks = this._blocks;
        // Check if data was valid
        if (invalidData) {
            this.error = data === null ? 'not_found' : 'invalid_data';
            this._triggerLoaded();
            return;
        }
        // Check if there are any icons
        if (parsedData.length < 1) {
            this.error = 'empty';
        }
        else {
            // Get registry and modules
            const registry = storage_1.getRegistry(this._instance);
            const config = registry.config;
            // Create pagination
            const pagination = initialisedBlocks.pagination;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            pagination.perPage = config.ui.itemsPerPage;
            pagination.fullLength = pagination.length = parsedData.length;
            pagination.page = Math.min(this.route.params.page, pagination_1.maxPage(pagination));
            // Copy full icons list for possible use in UI
            this._blocks.icons.allIcons = parsedData;
        }
        // Send event
        this._triggerLoaded();
    }
    /**
     * Get icons list
     */
    getIcons() {
        if (this.loading || this._blocks === null || this._data === null) {
            return null;
        }
        return objects_1.cloneObject(this._data);
    }
}
exports.CustomView = CustomView;
//# sourceMappingURL=custom.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/views/empty.js":
/*!**************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/views/empty.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmptyView = void 0;
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@iconify/search-core/lib/views/base.js");
/**
 * Class
 */
class EmptyView extends base_1.BaseView {
    /**
     * Create view
     */
    constructor(instance, route, parent = null) {
        super();
        this.type = 'empty';
        this._instance = instance;
        this.route = route;
        this.parent = parent;
    }
    /**
     * Start loading
     */
    _startLoadingData() {
        this.loading = false;
        this._triggerLoaded();
    }
    /**
     * Run action on view
     */
    action(action, value) {
        switch (action) {
            // Navigate to parent view
            case 'parent':
                this._parentAction(value);
                return;
            // Change provider
            case 'provider':
                this._providerAction(value);
                return;
        }
    }
    /**
     * Render blocks
     */
    render() {
        return {};
    }
}
exports.EmptyView = EmptyView;
//# sourceMappingURL=empty.js.map

/***/ }),

/***/ "./node_modules/@iconify/search-core/lib/views/search.js":
/*!***************************************************************!*\
  !*** ./node_modules/@iconify/search-core/lib/views/search.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchView = void 0;
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@iconify/search-core/lib/views/base.js");
const filters_1 = __webpack_require__(/*! ../blocks/filters */ "./node_modules/@iconify/search-core/lib/blocks/filters.js");
const search_1 = __webpack_require__(/*! ../converters/search */ "./node_modules/@iconify/search-core/lib/converters/search.js");
const icons_list_1 = __webpack_require__(/*! ../blocks/icons-list */ "./node_modules/@iconify/search-core/lib/blocks/icons-list.js");
const pagination_1 = __webpack_require__(/*! ../blocks/pagination */ "./node_modules/@iconify/search-core/lib/blocks/pagination.js");
const storage_1 = __webpack_require__(/*! ../registry/storage */ "./node_modules/@iconify/search-core/lib/registry/storage.js");
const objects_1 = __webpack_require__(/*! ../misc/objects */ "./node_modules/@iconify/search-core/lib/misc/objects.js");
const collections_1 = __webpack_require__(/*! ../data/collections */ "./node_modules/@iconify/search-core/lib/data/collections.js");
const base_2 = __webpack_require__(/*! ../api/base */ "./node_modules/@iconify/search-core/lib/api/base.js");
/**
 * Class
 */
class SearchView extends base_1.BaseView {
    /**
     * Create view
     */
    constructor(instance, route, parent = null) {
        super();
        this._data = null;
        this._blocks = null;
        this.type = 'search';
        this._instance = instance;
        this.route = route;
        this.provider = route.params.provider;
        this.parent = parent;
        this.keyword = route.params.search;
        // Get number of items per page
        const registry = storage_1.getRegistry(this._instance);
        const config = registry.config;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.itemsPerPage = config.ui.itemsPerPage;
        // Check if full results need to be shown
        if (this.route.params.page > 1) {
            this.route.params.short = false;
        }
        // Check for cache
        const cache = registry.getCustom('core-cache');
        if (typeof cache === 'object' && cache[this.provider]) {
            const searchCache = cache[this.provider].search;
            if (searchCache && searchCache[this.keyword]) {
                this._data = searchCache[this.keyword];
                // Only full pages can be cached
                this.route.params.short = false;
            }
        }
        // Set items limit for query
        this.itemsLimit = this.route.params.short ? this.itemsPerPage * 2 : 999;
    }
    /**
     * Start loading
     */
    _startLoadingData() {
        if (!this._data) {
            const query = this.keyword;
            const limit = this.itemsLimit;
            this._loadAPI(this.provider, '/search', {
                query,
                limit,
            }, base_2.searchCacheKey(query, limit));
        }
        else {
            this._parseAPIData(null);
        }
    }
    /**
     * Run action on view
     */
    action(action, value) {
        switch (action) {
            // Change to parent view
            case 'parent':
                this._parentAction(value);
                return;
            // Change provider
            case 'provider':
                if (value !== this.provider) {
                    this._providerAction(value);
                }
                return;
            // Global search
            case 'search':
                if (typeof value !== 'string') {
                    return;
                }
                value = value.trim().toLowerCase();
                if (value === this.keyword) {
                    return;
                }
                this._searchAction(this.provider, value);
                return;
            // Change current page
            case 'pagination':
                if (value === 'more' && this._showMoreButton()) {
                    // Change to current page + 1
                    value = this.route.params.page + 1;
                }
                // Check number
                if (typeof value === 'string') {
                    value = parseInt(value);
                }
                if (typeof value !== 'number' ||
                    isNaN(value) ||
                    value === this.route.params.page ||
                    value < 0) {
                    return;
                }
                // Check for "more"
                if (value > 0 && this._showMoreButton()) {
                    // Create sibling route
                    this._triggerFullResults(value);
                    return;
                }
                this.route.params.page = value;
                this.blocksRequireUpdate = true;
                break;
            // Collections filter
            case 'collections':
                this._collectionsAction(value, 0);
                return;
            // Collections filter, called from child view
            case 'collections-internal':
                this._collectionsAction(value, 1);
                return;
            default:
                return;
        }
        // Action has changed something - trigger update event
        this._triggerUpdated();
    }
    /**
     * Change active collection
     */
    _collectionsAction(value, levels) {
        if (value !== null && typeof value !== 'string') {
            return;
        }
        if (this.loading ||
            this._blocks === null ||
            this._blocks.collections === null) {
            return;
        }
        const registry = storage_1.getRegistry(this._instance);
        const router = registry.router;
        if (value === null) {
            // Change view to search results
            router.setParentView(levels);
            return;
        }
        // Create child view
        const prefix = value;
        router.createChildView({
            type: 'collection',
            params: {
                provider: this.provider,
                prefix,
                filter: this.keyword,
            },
        }, levels);
    }
    /**
     * Show full results
     */
    _triggerFullResults(page) {
        // Create sibling view
        const registry = storage_1.getRegistry(this._instance);
        const router = registry.router;
        router.createChildView({
            type: 'search',
            params: Object.assign({}, this.route.params, {
                page: page,
                short: false,
            }),
        }, 1);
    }
    /**
     * Render blocks
     */
    render() {
        if (this.loading || this._blocks === null || this._data === null) {
            return null;
        }
        // Check if blocks have been cached or if there is a error
        if (!this.blocksRequireUpdate || this.error !== '') {
            return this._blocks;
        }
        this.blocksRequireUpdate = false;
        // Apply route to blocks
        const blocks = this._blocks;
        // Copy icons
        blocks.icons.icons = this._data.icons.slice(0);
        // Set active filters
        if (blocks.collections !== null) {
            blocks.collections.active = null;
        }
        // Check pagination
        blocks.pagination.length = blocks.icons.icons.length;
        blocks.pagination.page = this.route.params.page;
        const maximumPage = pagination_1.maxPage(blocks.pagination);
        if (maximumPage < blocks.pagination.page) {
            this.route.params.page = blocks.pagination.page = maximumPage;
        }
        // Apply pagination
        const startIndex = blocks.pagination.page * this.itemsPerPage;
        blocks.icons.icons = blocks.icons.icons.slice(startIndex, startIndex + this.itemsPerPage);
        return this._blocks;
    }
    /**
     * Get collections block.
     *
     * Used by child views. Result is copied, ready to be modified
     */
    getCollectionsBlock() {
        if (this.loading || this.error !== '') {
            return null;
        }
        const blocks = this.render();
        return blocks !== null && blocks.collections !== null
            ? objects_1.cloneObject(blocks.collections)
            : null;
    }
    /**
     * Check if more results are available
     */
    _showMoreButton() {
        return this._data === null
            ? false
            : this.route.params.short && this._data.total === this._data.limit;
    }
    /**
     * Parse data from API
     *
     * Should be overwritten by child classes
     */
    _parseAPIData(data) {
        if (!this._data) {
            this._data = search_1.dataToSearchResults(this.provider, data);
        }
        // Mark as loaded, mark blocks for re-render and reset error
        this.loading = false;
        this.blocksRequireUpdate = true;
        this.error = '';
        // Create empty blocks
        this._blocks = {
            // Filters
            collections: null,
            // Icons and pagination
            icons: icons_list_1.defaultIconsListBlock(),
            pagination: pagination_1.defaultPaginationBlock(),
        };
        const initialisedBlocks = this._blocks;
        // Check if data was valid
        if (this._data === null) {
            this.error = data === null ? 'not_found' : 'invalid_data';
            this._triggerLoaded();
            return;
        }
        const parsedData = this._data;
        // Validate parameters
        if (this.keyword !== parsedData.query) {
            this.error = 'invalid_data';
            this._triggerLoaded();
            return;
        }
        // Overwrite limit
        if (parsedData.limit) {
            this.itemsLimit = parsedData.limit;
        }
        // Check if there are any icons
        if (parsedData.total < 1) {
            this.error = 'empty';
        }
        else {
            // Create pagination
            const pagination = initialisedBlocks.pagination;
            pagination.perPage = this.itemsPerPage;
            pagination.fullLength = pagination.length = parsedData.icons.length;
            pagination.page = Math.min(this.route.params.page, pagination_1.maxPage(pagination));
            // Check if more results are available
            pagination.more = this._showMoreButton();
            // Get all collections
            const prefixes = Object.keys(parsedData.collections);
            // Store collections in global data
            const registry = storage_1.getRegistry(this._instance);
            const collections = registry.collections;
            prefixes.forEach((prefix) => {
                collections_1.setCollectionInfo(collections, this.provider, prefix, parsedData.collections[prefix]);
            });
            // Collections filter
            if (prefixes.length > 1) {
                const block = filters_1.defaultFiltersBlock();
                this._blocks.collections = block;
                block.filterType = 'collections';
                prefixes.forEach((prefix) => {
                    block.filters[prefix] = filters_1.defaultFilter(parsedData.collections[prefix].name);
                });
                filters_1.autoIndexFilters(block);
            }
        }
        // Send event
        this._triggerLoaded();
    }
}
exports.SearchView = SearchView;
//# sourceMappingURL=search.js.map

/***/ }),

/***/ "./node_modules/@iconify/utils/lib/customisations/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@iconify/utils/lib/customisations/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeCustomisations = exports.defaults = void 0;
/**
 * Default icon customisations values
 */
exports.defaults = Object.freeze({
    // Display mode
    inline: false,
    // Dimensions
    width: null,
    height: null,
    // Alignment
    hAlign: 'center',
    vAlign: 'middle',
    slice: false,
    // Transformations
    hFlip: false,
    vFlip: false,
    rotate: 0,
});
/**
 * TypeScript
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-unused-vars
function assertNever(v) {
    //
}
/**
 * Convert IconifyIconCustomisations to FullIconCustomisations
 */
function mergeCustomisations(defaults, item) {
    const result = {};
    for (const key in defaults) {
        const attr = key;
        // Copy old value
        result[attr] = defaults[attr];
        if (item[attr] === void 0) {
            continue;
        }
        // Validate new value
        const value = item[attr];
        switch (attr) {
            // Boolean attributes that override old value
            case 'inline':
            case 'slice':
                if (typeof value === 'boolean') {
                    result[attr] = value;
                }
                break;
            // Boolean attributes that are merged
            case 'hFlip':
            case 'vFlip':
                if (value === true) {
                    result[attr] = !result[attr];
                }
                break;
            // Non-empty string
            case 'hAlign':
            case 'vAlign':
                if (typeof value === 'string' && value !== '') {
                    result[attr] = value;
                }
                break;
            // Non-empty string / non-zero number / null
            case 'width':
            case 'height':
                if ((typeof value === 'string' && value !== '') ||
                    (typeof value === 'number' && value) ||
                    value === null) {
                    result[attr] = value;
                }
                break;
            // Rotation
            case 'rotate':
                if (typeof value === 'number') {
                    result[attr] += value;
                }
                break;
            default:
                assertNever(attr);
        }
    }
    return result;
}
exports.mergeCustomisations = mergeCustomisations;


/***/ }),

/***/ "./node_modules/@iconify/utils/lib/icon/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@iconify/utils/lib/icon/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fullIcon = exports.iconDefaults = exports.matchName = void 0;
/**
 * Expression to test part of icon name.
 */
exports.matchName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
/**
 * Default values for all optional IconifyIcon properties
 */
exports.iconDefaults = Object.freeze({
    left: 0,
    top: 0,
    width: 16,
    height: 16,
    rotate: 0,
    vFlip: false,
    hFlip: false,
});
/**
 * Add optional properties to icon
 */
function fullIcon(data) {
    return { ...exports.iconDefaults, ...data };
}
exports.fullIcon = fullIcon;


/***/ }),

/***/ "./node_modules/@iconify/utils/lib/icon/name.js":
/*!******************************************************!*\
  !*** ./node_modules/@iconify/utils/lib/icon/name.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateIcon = exports.stringToIcon = void 0;
const index_1 = __webpack_require__(/*! ./index */ "./node_modules/@iconify/utils/lib/icon/index.js");
/**
 * Convert string to Icon object.
 */
const stringToIcon = (value, validate, allowSimpleName, provider = '') => {
    const colonSeparated = value.split(':');
    // Check for provider with correct '@' at start
    if (value.slice(0, 1) === '@') {
        // First part is provider
        if (colonSeparated.length < 2 || colonSeparated.length > 3) {
            // "@provider:prefix:name" or "@provider:prefix-name"
            return null;
        }
        provider = colonSeparated.shift().slice(1);
    }
    // Check split by colon: "prefix:name", "provider:prefix:name"
    if (colonSeparated.length > 3 || !colonSeparated.length) {
        return null;
    }
    if (colonSeparated.length > 1) {
        // "prefix:name"
        const name = colonSeparated.pop();
        const prefix = colonSeparated.pop();
        const result = {
            // Allow provider without '@': "provider:prefix:name"
            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
            prefix,
            name,
        };
        return validate && !(0, exports.validateIcon)(result) ? null : result;
    }
    // Attempt to split by dash: "prefix-name"
    const name = colonSeparated[0];
    const dashSeparated = name.split('-');
    if (dashSeparated.length > 1) {
        const result = {
            provider: provider,
            prefix: dashSeparated.shift(),
            name: dashSeparated.join('-'),
        };
        return validate && !(0, exports.validateIcon)(result) ? null : result;
    }
    // If allowEmpty is set, allow empty provider and prefix, allowing names like "home"
    if (allowSimpleName && provider === '') {
        const result = {
            provider: provider,
            prefix: '',
            name,
        };
        return validate && !(0, exports.validateIcon)(result, allowSimpleName)
            ? null
            : result;
    }
    return null;
};
exports.stringToIcon = stringToIcon;
/**
 * Check if icon is valid.
 *
 * This function is not part of stringToIcon because validation is not needed for most code.
 */
const validateIcon = (icon, allowSimpleName) => {
    if (!icon) {
        return false;
    }
    return !!((icon.provider === '' || icon.provider.match(index_1.matchName)) &&
        ((allowSimpleName && icon.prefix === '') ||
            icon.prefix.match(index_1.matchName)) &&
        icon.name.match(index_1.matchName));
};
exports.validateIcon = validateIcon;


/***/ }),

/***/ "./node_modules/@iconify/utils/lib/svg/build.js":
/*!******************************************************!*\
  !*** ./node_modules/@iconify/utils/lib/svg/build.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iconToSVG = void 0;
const size_1 = __webpack_require__(/*! ./size */ "./node_modules/@iconify/utils/lib/svg/size.js");
/**
 * Get preserveAspectRatio value
 */
function preserveAspectRatio(props) {
    let result = '';
    switch (props.hAlign) {
        case 'left':
            result += 'xMin';
            break;
        case 'right':
            result += 'xMax';
            break;
        default:
            result += 'xMid';
    }
    switch (props.vAlign) {
        case 'top':
            result += 'YMin';
            break;
        case 'bottom':
            result += 'YMax';
            break;
        default:
            result += 'YMid';
    }
    result += props.slice ? ' slice' : ' meet';
    return result;
}
/**
 * Get SVG attributes and content from icon + customisations
 *
 * Does not generate style to make it compatible with frameworks that use objects for style, such as React.
 * Instead, it generates 'inline' value. If true, rendering engine should add verticalAlign: -0.125em to icon.
 *
 * Customisations should be normalised by platform specific parser.
 * Result should be converted to <svg> by platform specific parser.
 * Use replaceIDs to generate unique IDs for body.
 */
function iconToSVG(icon, customisations) {
    // viewBox
    const box = {
        left: icon.left,
        top: icon.top,
        width: icon.width,
        height: icon.height,
    };
    // Body
    let body = icon.body;
    // Apply transformations
    [icon, customisations].forEach((props) => {
        const transformations = [];
        const hFlip = props.hFlip;
        const vFlip = props.vFlip;
        let rotation = props.rotate;
        // Icon is flipped first, then rotated
        if (hFlip) {
            if (vFlip) {
                rotation += 2;
            }
            else {
                // Horizontal flip
                transformations.push('translate(' +
                    (box.width + box.left) +
                    ' ' +
                    (0 - box.top) +
                    ')');
                transformations.push('scale(-1 1)');
                box.top = box.left = 0;
            }
        }
        else if (vFlip) {
            // Vertical flip
            transformations.push('translate(' +
                (0 - box.left) +
                ' ' +
                (box.height + box.top) +
                ')');
            transformations.push('scale(1 -1)');
            box.top = box.left = 0;
        }
        let tempValue;
        if (rotation < 0) {
            rotation -= Math.floor(rotation / 4) * 4;
        }
        rotation = rotation % 4;
        switch (rotation) {
            case 1:
                // 90deg
                tempValue = box.height / 2 + box.top;
                transformations.unshift('rotate(90 ' + tempValue + ' ' + tempValue + ')');
                break;
            case 2:
                // 180deg
                transformations.unshift('rotate(180 ' +
                    (box.width / 2 + box.left) +
                    ' ' +
                    (box.height / 2 + box.top) +
                    ')');
                break;
            case 3:
                // 270deg
                tempValue = box.width / 2 + box.left;
                transformations.unshift('rotate(-90 ' + tempValue + ' ' + tempValue + ')');
                break;
        }
        if (rotation % 2 === 1) {
            // Swap width/height and x/y for 90deg or 270deg rotation
            if (box.left !== 0 || box.top !== 0) {
                tempValue = box.left;
                box.left = box.top;
                box.top = tempValue;
            }
            if (box.width !== box.height) {
                tempValue = box.width;
                box.width = box.height;
                box.height = tempValue;
            }
        }
        if (transformations.length) {
            body =
                '<g transform="' +
                    transformations.join(' ') +
                    '">' +
                    body +
                    '</g>';
        }
    });
    // Calculate dimensions
    let width, height;
    if (customisations.width === null && customisations.height === null) {
        // Set height to '1em', calculate width
        height = '1em';
        width = (0, size_1.calculateSize)(height, box.width / box.height);
    }
    else if (customisations.width !== null &&
        customisations.height !== null) {
        // Values are set
        width = customisations.width;
        height = customisations.height;
    }
    else if (customisations.height !== null) {
        // Height is set
        height = customisations.height;
        width = (0, size_1.calculateSize)(height, box.width / box.height);
    }
    else {
        // Width is set
        width = customisations.width;
        height = (0, size_1.calculateSize)(width, box.height / box.width);
    }
    // Check for 'auto'
    if (width === 'auto') {
        width = box.width;
    }
    if (height === 'auto') {
        height = box.height;
    }
    // Convert to string
    width = typeof width === 'string' ? width : width + '';
    height = typeof height === 'string' ? height : height + '';
    // Result
    const result = {
        attributes: {
            width,
            height,
            preserveAspectRatio: preserveAspectRatio(customisations),
            viewBox: box.left + ' ' + box.top + ' ' + box.width + ' ' + box.height,
        },
        body,
    };
    if (customisations.inline) {
        result.inline = true;
    }
    return result;
}
exports.iconToSVG = iconToSVG;


/***/ }),

/***/ "./node_modules/@iconify/utils/lib/svg/size.js":
/*!*****************************************************!*\
  !*** ./node_modules/@iconify/utils/lib/svg/size.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.calculateSize = void 0;
/**
 * Regular expressions for calculating dimensions
 */
const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
/**
 * Calculate second dimension when only 1 dimension is set
 */
function calculateSize(size, ratio, precision) {
    if (ratio === 1) {
        return size;
    }
    precision = precision === void 0 ? 100 : precision;
    if (typeof size === 'number') {
        return Math.ceil(size * ratio * precision) / precision;
    }
    if (typeof size !== 'string') {
        return size;
    }
    // Split code into sets of strings and numbers
    const oldParts = size.split(unitsSplit);
    if (oldParts === null || !oldParts.length) {
        return size;
    }
    const newParts = [];
    let code = oldParts.shift();
    let isNumber = unitsTest.test(code);
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (isNumber) {
            const num = parseFloat(code);
            if (isNaN(num)) {
                newParts.push(code);
            }
            else {
                newParts.push(Math.ceil(num * ratio * precision) / precision);
            }
        }
        else {
            newParts.push(code);
        }
        // next
        code = oldParts.shift();
        if (code === void 0) {
            return newParts.join('');
        }
        isNumber = !isNumber;
    }
}
exports.calculateSize = calculateSize;


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classCallCheck)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _defineProperty)
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_iconify_search-core_lib_code-samples_code_js-node_modules_iconify_search-af5f03.min.js.map