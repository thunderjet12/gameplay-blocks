{"version":3,"file":"vendors-node_modules_iconify_search-core_lib_code-samples_code_js-node_modules_iconify_search-af5f03.min.js","mappings":";;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,0BAA0B,GAAG,2BAA2B,GAAG,eAAe,GAAG,kBAAkB;AACxH,oBAAoB,mBAAO,CAAC,oFAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;;;;AC/La;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW,GAAG,gBAAgB;AAC9B,eAAe,mBAAO,CAAC,mEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;;;;;;;;;;ACpFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kCAAkC,GAAG,kCAAkC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;;;;;;;;;ACrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qCAAqC,GAAG,qCAAqC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,iCAAiC,GAAG,8BAA8B,GAAG,+BAA+B,GAAG,mCAAmC,GAAG,mCAAmC,GAAG,qCAAqC,GAAG,+BAA+B,GAAG,mCAAmC;AACjU,sBAAsB,mBAAO,CAAC,oGAA2B;AACzD,kBAAkB,mBAAO,CAAC,4EAAW;AACrC,kBAAkB,mBAAO,CAAC,gFAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,8BAA8B;AAC9B;;;;;;;;;;ACvKa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,qBAAqB,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,qBAAqB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;ACzDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,6BAA6B,GAAG,6BAA6B;AACxF,kBAAkB,mBAAO,CAAC,4EAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;AChJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,uBAAuB,GAAG,eAAe,GAAG,yBAAyB,GAAG,8BAA8B;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,qCAAqC;AAChH;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,WAAW;AAClF;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;;;;AC/Ea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;;;ACpBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB,0BAA0B,mBAAO,CAAC,4FAAmB;AACrD,6BAA6B,mBAAO,CAAC,kGAAsB;AAC3D,2BAA2B,mBAAO,CAAC,8FAAoB;AACvD,kBAAkB,mBAAO,CAAC,4EAAW;AACrC,qBAAqB,mBAAO,CAAC,kFAAc;AAC3C,qBAAqB,mBAAO,CAAC,kFAAc;AAC3C,iBAAiB,mBAAO,CAAC,0EAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;;;AC5Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,+BAA+B;AACrD,cAAc,mBAAO,CAAC,0FAAe;AACrC,gBAAgB,mBAAO,CAAC,8FAAiB;AACzC,gBAAgB,mBAAO,CAAC,8FAAiB;AACzC,iBAAiB,mBAAO,CAAC,gGAAkB;AAC3C,cAAc,mBAAO,CAAC,0FAAe;AACrC,wBAAwB,mBAAO,CAAC,8GAAyB;AACzD,cAAc,mBAAO,CAAC,0FAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;ACzFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,gBAAgB,mBAAO,CAAC,oFAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;ACrDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,eAAe,GAAG,qBAAqB,GAAG,6BAA6B,GAAG,gBAAgB,GAAG,kCAAkC,GAAG,gBAAgB,GAAG,eAAe,GAAG,gBAAgB,GAAG,qBAAqB;AACzV,yBAAyB,mBAAO,CAAC,iGAA2B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,2CAA2C,IAAI,GAAG,OAAO;AACzD;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI,GAAG,MAAM;AACzD;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI,IAAI,QAAQ;AAC5D;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,GAAG,MAAM;AACjC,2BAA2B,IAAI;AAC/B,2BAA2B,MAAM;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB;AACvB;;;;;;;;;;AC9Oa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,iBAAiB,mBAAO,CAAC,wFAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,KAAK;AACxB;AACA;AACA,8EAA8E;AAC9E,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;;;ACtFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,eAAe,mBAAO,CAAC,6EAAiB;AACxC,mBAAmB,mBAAO,CAAC,qFAAa;AACxC,iBAAiB,mBAAO,CAAC,wFAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;ACjDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,mBAAmB;AAChD,eAAe,mBAAO,CAAC,6EAAiB;AACxC,mBAAmB,mBAAO,CAAC,qFAAa;AACxC,iBAAiB,mBAAO,CAAC,wFAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO,uDAAuD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;;;ACzFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,oBAAoB;AAClD,eAAe,mBAAO,CAAC,6EAAiB;AACxC,mBAAmB,mBAAO,CAAC,qFAAa;AACxC,iBAAiB,mBAAO,CAAC,wFAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;;;ACzFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,kBAAkB,mBAAO,CAAC,+EAAe;AACzC,eAAe,mBAAO,CAAC,6EAAiB;AACxC,mBAAmB,mBAAO,CAAC,qFAAa;AACxC,iBAAiB,mBAAO,CAAC,wFAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,MAAM;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;;;AClGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,kBAAkB,mBAAO,CAAC,+EAAe;AACzC,eAAe,mBAAO,CAAC,6EAAiB;AACxC,eAAe,mBAAO,CAAC,6EAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;;;ACxDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,iBAAiB;AAC5C,eAAe,mBAAO,CAAC,6EAAiB;AACxC,mBAAmB,mBAAO,CAAC,qFAAa;AACxC,iBAAiB,mBAAO,CAAC,wFAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,sDAAsD;AAC3F,8BAA8B,OAAO,sDAAsD;AAC3F,oCAAoC,iBAAiB,gBAAgB,IAAI,EAAE;AAC3E,2CAA2C,iBAAiB,gBAAgB,aAAa,cAAc,gBAAgB,WAAW,QAAQ,UAAU,SAAS,KAAK,IAAI,EAAE;AACxK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;AC3Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,GAAG,iCAAiC,GAAG,wBAAwB;AAChG,qBAAqB,mBAAO,CAAC,sFAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;;;;;;;;;AC5Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B;AAC1B,kBAAkB,mBAAO,CAAC,kFAAW;AACrC,kBAAkB,mBAAO,CAAC,4EAAY;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;;;ACxIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,yBAAyB,GAAG,sBAAsB;AAChF;AACA,sBAAsB;AACtB,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;;;ACrCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,wBAAwB;AACtD,eAAe,mBAAO,CAAC,0EAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjkBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,yBAAyB;AAClH,eAAe,mBAAO,CAAC,0EAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,4BAA4B;AAC5B;;;;;;;;;;AC/Fa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B;AAC5B;;;;;;;;;;ACzKa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B,eAAe,mBAAO,CAAC,0EAAc;AACrC,eAAe,mBAAO,CAAC,0EAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;;;;ACnEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,yBAAyB,GAAG,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;;;ACpCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,2BAA2B;AACnG,kBAAkB,mBAAO,CAAC,gFAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;ACxGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,yBAAyB,GAAG,yBAAyB;AAChF,kBAAkB,mBAAO,CAAC,4EAAY;AACtC,qBAAqB,mBAAO,CAAC,kGAA0B;AACvD,sBAAsB,mBAAO,CAAC,oGAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;;;;;;;;;;AC1Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,2BAA2B,GAAG,2BAA2B;AAC7H,kBAAkB,mBAAO,CAAC,4EAAY;AACtC,eAAe,mBAAO,CAAC,gFAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C,+BAA+B;AAC/B,cAAc;AACd;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C,8BAA8B,OAAO,EAAE,KAAK;AAC5C,KAAK;AACL;AACA;AACA,kCAAkC,KAAK;AACvC,KAAK;AACL,sCAAsC,OAAO,EAAE,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;ACjNa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,cAAc;AACd;;;;;;;;;;ACjGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,eAAe;AACpC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB;AAClB;;;;;;;;;;ACvBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,sBAAsB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,2BAA2B,GAAG,mBAAmB,GAAG,wBAAwB,GAAG,0BAA0B,GAAG,yBAAyB,GAAG,qBAAqB,GAAG,qBAAqB,GAAG,2BAA2B,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,eAAe,GAAG,sBAAsB,GAAG,+BAA+B,GAAG,mCAAmC,GAAG,qCAAqC,GAAG,oBAAoB;AACpoB,mBAAmB,mBAAO,CAAC,6EAAY;AACvC,kBAAkB,mBAAO,CAAC,uFAAoB;AAC9C,sBAAsB,mBAAO,CAAC,uFAAoB;AAClD,sBAAsB,mBAAO,CAAC,uFAAoB;AAClD,qDAAoD,EAAE,qCAAqC,2CAA2C,EAAC;AACvI;AACA;AACA;AACA,cAAc,mBAAO,CAAC,+EAAgB;AACtC,gDAA+C,EAAE,qCAAqC,gCAAgC,EAAC;AACvH,yBAAyB,mBAAO,CAAC,qGAA2B;AAC5D,iEAAgE,EAAE,qCAAqC,4DAA4D,EAAC;AACpK,+DAA8D,EAAE,qCAAqC,0DAA0D,EAAC;AAChK,2DAA0D,EAAE,qCAAqC,sDAAsD,EAAC;AACxJ,mBAAmB,mBAAO,CAAC,yFAAqB;AAChD,kDAAiD,EAAE,qCAAqC,uCAAuC,EAAC;AAChI,2CAA0C,EAAE,qCAAqC,gCAAgC,EAAC;AAClH;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,2EAAW;AACnC,8CAA6C,EAAE,qCAAqC,gCAAgC,EAAC;AACrH,kBAAkB,mBAAO,CAAC,mFAAkB;AAC5C,+CAA8C,EAAE,qCAAqC,mCAAmC,EAAC;AACzH,+CAA8C,EAAE,qCAAqC,mCAAmC,EAAC;AACzH,uDAAsD,EAAE,qCAAqC,2CAA2C,EAAC;AACzI,iDAAgD,EAAE,qCAAqC,qCAAqC,EAAC;AAC7H,gBAAgB,mBAAO,CAAC,iFAAiB;AACzC,iDAAgD,EAAE,qCAAqC,mCAAmC,EAAC;AAC3H,oBAAoB,mBAAO,CAAC,uFAAoB;AAChD,sDAAqD,EAAE,qCAAqC,4CAA4C,EAAC;AACzI,eAAe,mBAAO,CAAC,6EAAe;AACtC,oDAAmD,EAAE,qCAAqC,qCAAqC,EAAC;AAChI,+CAA8C,EAAE,qCAAqC,gCAAgC,EAAC;AACtH,uDAAsD,EAAE,qCAAqC,wCAAwC,EAAC;AACtI,aAAa,mBAAO,CAAC,yEAAa;AAClC,gDAA+C,EAAE,qCAAqC,+BAA+B,EAAC;AACtH,gDAA+C,EAAE,qCAAqC,+BAA+B,EAAC;AACtH,gDAA+C,EAAE,qCAAqC,+BAA+B,EAAC;AACtH,gDAA+C,EAAE,qCAAqC,+BAA+B,EAAC;AACtH;AACA,gBAAgB,mBAAO,CAAC,+EAAgB;AACxC,kDAAiD,EAAE,qCAAqC,oCAAoC,EAAC;AAC7H,+CAA8C,EAAE,qCAAqC,iCAAiC,EAAC;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;;;;;;;;;AC7Ha;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;ACrBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,yBAAyB;AACzD;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,qBAAqB;AAC7C,yBAAyB,mBAAO,CAAC,wFAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;ACzVa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,2BAA2B,GAAG,6BAA6B,GAAG,2BAA2B;AACxH,yBAAyB,mBAAO,CAAC,oGAAmC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;;;;;;;;;;ACzDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,aAAa;AACzG,eAAe,mBAAO,CAAC,oFAA8B;AACrD,gDAA+C,EAAE,qCAAqC,+BAA+B,EAAC;AACtH;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;;;;;;;;;ACvCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,sBAAsB,GAAG,mBAAmB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;ACtIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,iBAAiB,mBAAO,CAAC,8EAAgB;AACzC,iBAAiB,mBAAO,CAAC,oEAAW;AACpC,gBAAgB,mBAAO,CAAC,0EAAc;AACtC,iBAAiB,mBAAO,CAAC,gFAAiB;AAC1C,kBAAkB,mBAAO,CAAC,8EAAW;AACrC,sBAAsB,mBAAO,CAAC,wFAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;ACpKa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,gBAAgB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;;;;AClEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,2BAA2B,GAAG,qBAAqB,GAAG,2BAA2B;AACzG,mBAAmB,mBAAO,CAAC,6EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA,iEAAiE,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;;;;;;;;ACzLa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,0BAA0B,GAAG,0BAA0B,GAAG,8BAA8B,GAAG,+BAA+B,GAAG,0BAA0B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,+BAA+B,GAAG,gCAAgC;AACpT;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,yBAAyB;AACzB;;;;;;;;;;AC/Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,kBAAkB,mBAAO,CAAC,wFAAqB;AAC/C,kBAAkB,mBAAO,CAAC,2EAAW;AACrC,sBAAsB,mBAAO,CAAC,0FAAsB;AACpD,qBAAqB,mBAAO,CAAC,wFAAqB;AAClD,iBAAiB,mBAAO,CAAC,gFAAiB;AAC1C,iBAAiB,mBAAO,CAAC,gFAAiB;AAC1C,gBAAgB,mBAAO,CAAC,8EAAgB;AACxC,oBAAoB,mBAAO,CAAC,oFAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;;;;;;;;AChba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,kBAAkB,mBAAO,CAAC,wFAAqB;AAC/C,oBAAoB,mBAAO,CAAC,oFAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;;AC9Na;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,eAAe,mBAAO,CAAC,qEAAQ;AAC/B,0BAA0B,mBAAO,CAAC,oGAA2B;AAC7D,kBAAkB,mBAAO,CAAC,oFAAmB;AAC7C,qBAAqB,mBAAO,CAAC,kGAA0B;AACvD,qBAAqB,mBAAO,CAAC,0FAAsB;AACnD,qBAAqB,mBAAO,CAAC,0FAAsB;AACnD,kBAAkB,mBAAO,CAAC,wFAAqB;AAC/C,iBAAiB,mBAAO,CAAC,kFAAkB;AAC3C,2BAA2B,mBAAO,CAAC,sGAA4B;AAC/D,sBAAsB,mBAAO,CAAC,wFAAqB;AACnD,eAAe,mBAAO,CAAC,wEAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;;;;AClea;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,eAAe,mBAAO,CAAC,qEAAQ;AAC/B,6BAA6B,mBAAO,CAAC,0GAA8B;AACnE,2BAA2B,mBAAO,CAAC,sGAA4B;AAC/D,kBAAkB,mBAAO,CAAC,oFAAmB;AAC7C,sBAAsB,mBAAO,CAAC,oGAA2B;AACzD,kBAAkB,mBAAO,CAAC,wFAAqB;AAC/C,sBAAsB,mBAAO,CAAC,wFAAqB;AACnD,sBAAsB,mBAAO,CAAC,wFAAqB;AACnD,eAAe,mBAAO,CAAC,wEAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;;;;;;;;;ACpRa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,eAAe,mBAAO,CAAC,qEAAQ;AAC/B,qBAAqB,mBAAO,CAAC,0FAAsB;AACnD,qBAAqB,mBAAO,CAAC,0FAAsB;AACnD,kBAAkB,mBAAO,CAAC,wFAAqB;AAC/C,eAAe,mBAAO,CAAC,0EAAc;AACrC,iBAAiB,mBAAO,CAAC,kFAAkB;AAC3C,kBAAkB,mBAAO,CAAC,gFAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;ACpOa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,eAAe,mBAAO,CAAC,qEAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;;;;AChDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,eAAe,mBAAO,CAAC,qEAAQ;AAC/B,kBAAkB,mBAAO,CAAC,oFAAmB;AAC7C,iBAAiB,mBAAO,CAAC,0FAAsB;AAC/C,qBAAqB,mBAAO,CAAC,0FAAsB;AACnD,qBAAqB,mBAAO,CAAC,0FAAsB;AACnD,kBAAkB,mBAAO,CAAC,wFAAqB;AAC/C,kBAAkB,mBAAO,CAAC,gFAAiB;AAC3C,sBAAsB,mBAAO,CAAC,wFAAqB;AACnD,eAAe,mBAAO,CAAC,wEAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;;;;;;;;AClTa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,gBAAgB;AAC9C;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACrFd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,oBAAoB,GAAG,iBAAiB;AAC3D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB;;;;;;;;;;;ACzBH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,oBAAoB;AAC3C,gBAAgB,mBAAO,CAAC,gEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;ACzEP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,eAAe,mBAAO,CAAC,6DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACnLJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;;;;;;;;;;;;;;ACpDN;AACf;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;;;;;;;;;;;;;;ACde;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACbe;AACf;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA","sources":["webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/api/base.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/api/fetch.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/blocks/collection-info.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/blocks/collections-filter.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/blocks/collections-list.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/blocks/filters.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/blocks/icons-list.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/blocks/pagination.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/blocks/search.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/blocks/types.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/code.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/html.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/parsers/common.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/parsers/css.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/parsers/ember.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/parsers/react.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/parsers/svelte.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/parsers/svg-framework.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/parsers/svg.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/parsers/vue.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/phrases.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/tree.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/code-samples/versions.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/converters/collection.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/converters/collections.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/converters/info.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/converters/search.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/data/collections.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/data/config.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/data/custom-sets.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/data/providers.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/events.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/iconify/index.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/index.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/misc/capitalize.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/misc/color-keywords.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/misc/colors.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/misc/customisations.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/misc/icon.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/misc/objects.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/registry/index.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/registry/storage.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/route/convert.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/route/defaults.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/route/router.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/views/base.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/views/collection.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/views/collections.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/views/custom.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/views/empty.js","webpack://gameplay-blocks/./node_modules/@iconify/search-core/lib/views/search.js","webpack://gameplay-blocks/./node_modules/@iconify/utils/lib/customisations/index.js","webpack://gameplay-blocks/./node_modules/@iconify/utils/lib/icon/index.js","webpack://gameplay-blocks/./node_modules/@iconify/utils/lib/icon/name.js","webpack://gameplay-blocks/./node_modules/@iconify/utils/lib/svg/build.js","webpack://gameplay-blocks/./node_modules/@iconify/utils/lib/svg/size.js","webpack://gameplay-blocks/./node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack://gameplay-blocks/./node_modules/@babel/runtime/helpers/esm/createClass.js","webpack://gameplay-blocks/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://gameplay-blocks/./node_modules/@babel/runtime/helpers/esm/typeof.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.searchCacheKey = exports.collectionCacheKey = exports.collectionsCacheKey = exports.BaseAPI = exports.mergeQuery = void 0;\nconst providers_1 = require(\"../data/providers\");\n/**\n * Add parameters to query\n */\nfunction mergeQuery(base, params) {\n    let result = base, hasParams = result.indexOf('?') !== -1;\n    /**\n     * Convertion of parameters to string, only allows simple types used by Iconify API\n     */\n    function paramToString(value, nested) {\n        switch (typeof value) {\n            case 'boolean':\n                if (nested) {\n                    throw new Error('Nested boolean items are not allowed');\n                }\n                return value ? 'true' : 'false';\n            case 'number':\n                return encodeURIComponent(value);\n            case 'string':\n                return encodeURIComponent(value);\n            case 'object':\n                if (nested) {\n                    throw new Error('Nested objects are not allowed');\n                }\n                if (value instanceof Array) {\n                    return value\n                        .map((item) => paramToString(item, true))\n                        .join(',');\n                }\n                throw new Error('Objects are not allowed');\n            default:\n                throw new Error('Invalid type');\n        }\n    }\n    Object.keys(params).forEach((key) => {\n        let value;\n        try {\n            value = paramToString(params[key], false);\n        }\n        catch (err) {\n            return;\n        }\n        result +=\n            (hasParams ? '&' : '?') + encodeURIComponent(key) + '=' + value;\n        hasParams = true;\n    });\n    return result;\n}\nexports.mergeQuery = mergeQuery;\n/**\n * Base API class\n */\nclass BaseAPI {\n    /**\n     * Constructor\n     *\n     * @param registry\n     */\n    constructor(registry) {\n        // Provider specific cache\n        this._cache = Object.create(null);\n        this._registry = registry;\n        this._query = this._query.bind(this);\n    }\n    /**\n     * Send query\n     *\n     * @param provider Provider\n     * @param endpoint End point string\n     * @param params Query parameters as object\n     * @param callback Callback to call when data is available\n     * @param cacheKey Key to store provider specific cache, true if key should be generated, false if cache should be ignored\n     */\n    query(provider, endpoint, params, callback, cacheKey = true) {\n        const uri = mergeQuery(endpoint, params);\n        const cacheKeyStr = typeof cacheKey === 'string' ? cacheKey : uri;\n        // Check for cache\n        if (this._cache[provider] === void 0) {\n            this._cache[provider] = Object.create(null);\n        }\n        const providerCache = this._cache[provider];\n        if (cacheKey !== false && providerCache[cacheKeyStr] !== void 0) {\n            // Return cached data\n            const cached = providerCache[cacheKeyStr];\n            callback(cached === null ? null : JSON.parse(cached), void 0, true);\n            return;\n        }\n        // Init redundancy\n        const redundancy = this._getRedundancy(provider);\n        if (!redundancy) {\n            // Error\n            callback(null, false);\n            return;\n        }\n        // Send query\n        const query = redundancy.find((item) => {\n            const status = item();\n            return status.status === 'pending' && status.payload === uri;\n        });\n        if (query !== null) {\n            // Attach callback to existing query\n            query().subscribe((data, error) => {\n                callback(data, error, false);\n            });\n            return;\n        }\n        // Create new query\n        redundancy.query(uri, this._query.bind(this, provider, cacheKey === false ? null : cacheKeyStr), (data, error) => {\n            callback(data, error, false);\n        });\n    }\n    /**\n     * Check if query is cached\n     */\n    isCached(provider, endpoint, params) {\n        const uri = mergeQuery(endpoint, params);\n        return (this._cache[provider] !== void 0 &&\n            this._cache[provider][uri] !== void 0);\n    }\n    /**\n     * Check if query is pending\n     */\n    isPending(provider, endpoint, params) {\n        // Init redundancy\n        const redundancy = this._getRedundancy(provider);\n        if (!redundancy) {\n            // Error\n            return false;\n        }\n        const uri = mergeQuery(endpoint, params);\n        const query = redundancy.find((item) => {\n            const status = item();\n            return status.status === 'pending' && status.payload === uri;\n        });\n        return query !== null;\n    }\n    /**\n     * Send query, callback from Redundancy\n     */\n    _query(provider, cacheKey, host, params, item) {\n        // Should be implemented by child classes\n        throw new Error('_query() should not be called on base API class');\n    }\n    /**\n     * Store cached data\n     */\n    storeCache(provider, cacheKey, data) {\n        if (this._cache[provider] === void 0) {\n            this._cache[provider] = Object.create(null);\n        }\n        this._cache[provider][cacheKey] =\n            data === null ? null : JSON.stringify(data);\n    }\n    /**\n     * Clear all cache\n     */\n    clearCache() {\n        this._cache = Object.create(null);\n    }\n    /**\n     * Get Redundancy instance\n     */\n    _getRedundancy(provider) {\n        // Init redundancy\n        const providerData = providers_1.getProvider(provider);\n        if (!providerData) {\n            // Error\n            return null;\n        }\n        return providerData.redundancy;\n    }\n}\nexports.BaseAPI = BaseAPI;\n/**\n * Various cache keys\n */\nfunction collectionsCacheKey() {\n    return 'collections';\n}\nexports.collectionsCacheKey = collectionsCacheKey;\nfunction collectionCacheKey(prefix) {\n    return 'collection.' + prefix;\n}\nexports.collectionCacheKey = collectionCacheKey;\nfunction searchCacheKey(query, limit) {\n    return 'search.' + query + '.' + limit;\n}\nexports.searchCacheKey = searchCacheKey;\n//# sourceMappingURL=base.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.API = exports.setFetch = void 0;\nconst base_1 = require(\"./base\");\n/**\n * Fetch function\n *\n * Use this to set 'cross-fetch' in node.js environment if you are retrieving icons on server side.\n * Not needed when using stuff like Next.js or SvelteKit because components use API only on client side.\n */\nlet fetchModule = null;\ntry {\n    fetchModule = fetch;\n}\ncatch (err) {\n    //\n}\nfunction setFetch(fetch) {\n    fetchModule = fetch;\n}\nexports.setFetch = setFetch;\n/**\n * API class\n */\nclass API extends base_1.BaseAPI {\n    /**\n     * Send API query without provider\n     *\n     * @param host Host string\n     * @param params End point and parameters as string\n     * @param callback Callback\n     */\n    sendQuery(host, params, callback) {\n        if (!fetchModule) {\n            // Fail: return 424 Failed Dependency (its not meant to be used like that, but it is the best match)\n            callback(void 0, 424);\n            return;\n        }\n        fetchModule(host + params)\n            .then((response) => {\n            if (response.status !== 200) {\n                callback(void 0, response.status);\n                return;\n            }\n            return response.json();\n        })\n            .then((data) => {\n            if (data === void 0) {\n                // Return from previous then() without Promise\n                return;\n            }\n            if (typeof data !== 'object' || data === null) {\n                // Error\n                callback(void 0, null);\n                return;\n            }\n            // Store cache and complete\n            callback(data);\n        })\n            .catch((err) => {\n            callback(void 0, err === null || err === void 0 ? void 0 : err.errno);\n        });\n    }\n    /**\n     * Send query, callback from Redundancy\n     *\n     * @param provider Provider string\n     * @param cacheKey API cache key, null if data should not be cached\n     * @param host Host string\n     * @param params End point and parameters as string\n     * @param item Query item\n     */\n    _query(provider, cacheKey, host, params, item) {\n        // console.log('API request: ' + host + params);\n        this.sendQuery(host, params, (data, error) => {\n            if (data !== void 0 && cacheKey !== null) {\n                // Store cache on success\n                this.storeCache(provider, cacheKey, data);\n            }\n            item.done(data, error);\n        });\n    }\n}\nexports.API = API;\n//# sourceMappingURL=fetch.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCollectionInfoBlockEmpty = exports.defaultCollectionInfoBlock = void 0;\n/**\n * Default block values\n */\nconst defaultCollectionInfoBlock = () => {\n    return {\n        type: 'collection-info',\n        prefix: '',\n        info: null,\n    };\n};\nexports.defaultCollectionInfoBlock = defaultCollectionInfoBlock;\n/**\n * Check if block is empty\n */\nfunction isCollectionInfoBlockEmpty(block) {\n    return block === void 0 || block === null || block.info === null;\n}\nexports.isCollectionInfoBlockEmpty = isCollectionInfoBlockEmpty;\n//# sourceMappingURL=collection-info.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCollectionsFilterBlockEmpty = exports.defaultCollectionsFilterBlock = void 0;\n/**\n * Default block values\n */\nconst defaultCollectionsFilterBlock = () => {\n    return {\n        type: 'collections-filter',\n        keyword: '',\n    };\n};\nexports.defaultCollectionsFilterBlock = defaultCollectionsFilterBlock;\n/**\n * Check if block is empty\n */\nfunction isCollectionsFilterBlockEmpty(block) {\n    return block === void 0 || block === null || block.keyword.trim() === '';\n}\nexports.isCollectionsFilterBlockEmpty = isCollectionsFilterBlockEmpty;\n//# sourceMappingURL=collections-filter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyCollectionsFilter = exports.disableInactiveCategories = exports.filterCollectionsBlock = exports.iterateCollectionsBlock = exports.collectionsPrefixesWithInfo = exports.getCollectionsBlockPrefixes = exports.getCollectionsBlockCategories = exports.isCollectionsBlockEmpty = exports.defaultCollectionsListBlock = void 0;\nconst collections_1 = require(\"../converters/collections\");\nconst filters_1 = require(\"./filters\");\nconst objects_1 = require(\"../misc/objects\");\n/**\n * Default values\n */\nconst defaultCollectionsListBlock = () => {\n    return {\n        type: 'collections-list',\n        showCategories: true,\n        collections: Object.create(null),\n    };\n};\nexports.defaultCollectionsListBlock = defaultCollectionsListBlock;\n/**\n * Check if block is empty\n */\nfunction isCollectionsBlockEmpty(block) {\n    if (block === void 0 || block === null) {\n        return true;\n    }\n    const categories = Object.keys(block.collections);\n    for (let i = 0; i < categories.length; i++) {\n        if (Object.keys(block.collections[categories[i]]).length > 0) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isCollectionsBlockEmpty = isCollectionsBlockEmpty;\n/**\n * Get categories\n */\nfunction getCollectionsBlockCategories(block, ignoreEmpty = false) {\n    let categories = Object.keys(block.collections);\n    if (ignoreEmpty) {\n        categories = categories.filter((category) => Object.keys(block.collections[category]).length > 0);\n    }\n    return categories;\n}\nexports.getCollectionsBlockCategories = getCollectionsBlockCategories;\n/**\n * Get all prefixes\n */\nfunction getCollectionsBlockPrefixes(block) {\n    return collections_1.collectionsPrefixes(block.collections);\n}\nexports.getCollectionsBlockPrefixes = getCollectionsBlockPrefixes;\n/**\n * Get all collections info as array\n */\nfunction collectionsPrefixesWithInfo(block) {\n    const info = [];\n    Object.keys(block.collections).forEach((category) => {\n        const items = block.collections[category];\n        Object.keys(items).forEach((prefix) => {\n            if (items[prefix] !== null) {\n                info.push(items[prefix]);\n            }\n        });\n    });\n    return info;\n}\nexports.collectionsPrefixesWithInfo = collectionsPrefixesWithInfo;\n/**\n * Iterate collections block\n */\nfunction iterateCollectionsBlock(block, callback) {\n    Object.keys(block.collections).forEach((category) => {\n        const items = block.collections[category];\n        Object.keys(items).forEach((prefix) => {\n            callback(items[prefix], prefix, category);\n        });\n    });\n}\nexports.iterateCollectionsBlock = iterateCollectionsBlock;\n/**\n * Filter collections list (creates new block)\n */\nfunction filterCollectionsBlock(block, callback, keepEmptyCategories = false) {\n    const result = {\n        type: 'collections-list',\n        showCategories: block.showCategories,\n        collections: collections_1.filterCollections(block.collections, callback, keepEmptyCategories),\n    };\n    return result;\n}\nexports.filterCollectionsBlock = filterCollectionsBlock;\n/**\n * Remove all inactive categories\n */\nfunction disableInactiveCategories(block, category) {\n    if (category === null) {\n        return block;\n    }\n    const result = {\n        type: 'collections-list',\n        showCategories: block.showCategories,\n        collections: Object.create(null),\n    };\n    if (block.collections[category] !== void 0) {\n        result.collections[category] = block.collections[category];\n    }\n    return result;\n}\nexports.disableInactiveCategories = disableInactiveCategories;\n/**\n * List of keys to apply filter to\n */\nconst filterKeys = [\n    'prefix',\n    'name',\n    'author',\n    'license',\n    'category',\n    'palette',\n    'height',\n];\n/**\n * Apply filter to collections list and to collections filters\n */\nfunction applyCollectionsFilter(block, filter, filters) {\n    const keyword = filter.keyword.trim();\n    const hasFilters = filters !== null && filters.filterType === 'categories';\n    const filtersList = filters;\n    if (keyword === '') {\n        // Empty\n        if (hasFilters) {\n            // Enable all filters\n            filters_1.enableFilters(filtersList, true);\n        }\n        return block;\n    }\n    // Disable all filters, will re-enable them again during filter process\n    const activeCategories = {};\n    if (hasFilters) {\n        filters_1.enableFilters(filtersList, false);\n    }\n    // Filter collections block\n    return filterCollectionsBlock(block, (item, category) => {\n        for (let i = filterKeys.length - 1; i >= 0; i--) {\n            // Get key\n            const key = filterKeys[i];\n            if (item[key] === void 0) {\n                continue;\n            }\n            // Test value\n            if (objects_1.match(item[key], keyword)) {\n                // Enable category in category filters\n                if (hasFilters) {\n                    if (activeCategories[category] !== true) {\n                        activeCategories[category] = true;\n                        if (filtersList.filters[category] !== void 0) {\n                            filtersList.filters[category].disabled = false;\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }, false);\n}\nexports.applyCollectionsFilter = applyCollectionsFilter;\n//# sourceMappingURL=collections-list.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.autoIndexFilters = exports.enableFilters = exports.isFiltersBlockEmpty = exports.defaultFiltersBlock = exports.defaultFilter = void 0;\n/**\n * Default values for filter\n */\nconst defaultFilter = (title) => {\n    return {\n        title,\n        index: 0,\n        disabled: false,\n    };\n};\nexports.defaultFilter = defaultFilter;\n/**\n * Default value\n */\nconst defaultFiltersBlock = () => {\n    return {\n        type: 'filters',\n        filterType: '',\n        active: null,\n        filters: Object.create(null),\n    };\n};\nexports.defaultFiltersBlock = defaultFiltersBlock;\n/**\n * Check if block is empty\n */\nfunction isFiltersBlockEmpty(block) {\n    return (block === void 0 ||\n        block === null ||\n        Object.keys(block.filters).length < 2);\n}\nexports.isFiltersBlockEmpty = isFiltersBlockEmpty;\n/**\n * Enable or disable all filters in block\n */\nfunction enableFilters(block, enable = true) {\n    Object.keys(block.filters).forEach((filter) => {\n        block.filters[filter].disabled = !enable;\n    });\n}\nexports.enableFilters = enableFilters;\n/**\n * Set indexes to all filters\n *\n * Returns next start index to chain index multiple sets of filters\n */\nfunction autoIndexFilters(block, start = 0) {\n    let index = start;\n    Object.keys(block.filters).forEach((filter) => {\n        block.filters[filter].index = index++;\n    });\n    return index;\n}\nexports.autoIndexFilters = autoIndexFilters;\n//# sourceMappingURL=filters.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyIconFilters = exports.isIconsListBlockEmpty = exports.defaultIconsListBlock = void 0;\nconst filters_1 = require(\"./filters\");\n/**\n * Default block values\n */\nconst defaultIconsListBlock = () => {\n    return {\n        type: 'icons-list',\n        icons: [],\n    };\n};\nexports.defaultIconsListBlock = defaultIconsListBlock;\n/**\n * Check if block is empty\n */\nfunction isIconsListBlockEmpty(block) {\n    return block === void 0 || block === null || block.icons.length < 1;\n}\nexports.isIconsListBlockEmpty = isIconsListBlockEmpty;\n/**\n * Icon attributes to search\n */\nconst searchableIconAttributes = ['name', 'chars', 'aliases'];\nconst searchableIconAttributesWithPrefixes = [\n    'prefix',\n    'name',\n    'chars',\n    'aliases',\n];\n/**\n * Apply filters to icons list\n */\nfunction applyIconFilters(block, search, filters = [], searchPrefixes = false) {\n    let icons = block.icons.slice(0);\n    const searchableAttributes = searchPrefixes\n        ? searchableIconAttributesWithPrefixes\n        : searchableIconAttributes;\n    // Get Icon attribute matching filter (legacy from when attributes didn't match, but kept in case things change again)\n    function iconAttr(key) {\n        return key;\n    }\n    // Search\n    const keyword = search ? search.keyword.trim() : '';\n    if (keyword !== '') {\n        // Find all icons that match keyword\n        const keywords = keyword\n            .toLowerCase()\n            .split(/[\\s:]/)\n            .map((keyword) => keyword.trim())\n            .filter((keyword) => keyword.length > 0);\n        if (keywords.length) {\n            const searches = searchableAttributes.slice(0);\n            keywords.forEach((keyword) => {\n                let exclude = false;\n                if (keyword.slice(0, 1) === '-') {\n                    exclude = true;\n                    keyword = keyword.slice(1);\n                    if (!keyword.length) {\n                        return;\n                    }\n                }\n                icons = icons.filter((item) => {\n                    const icon = item;\n                    let match = false;\n                    searches.forEach((attr) => {\n                        if (match || icon[attr] === void 0) {\n                            return;\n                        }\n                        if (typeof icon[attr] === 'string') {\n                            match =\n                                icon[attr].indexOf(keyword) !== -1;\n                            return;\n                        }\n                        if (icon[attr] instanceof Array) {\n                            icon[attr].forEach((value) => {\n                                match = match || value.indexOf(keyword) !== -1;\n                            });\n                        }\n                    });\n                    return exclude ? !match : match;\n                });\n            });\n        }\n    }\n    // Toggle filter visibility\n    const isSearched = icons.length !== block.icons.length;\n    filters.forEach((filter) => {\n        filters_1.enableFilters(filter, true);\n        if (!isSearched) {\n            return;\n        }\n        const attr = iconAttr(filter.filterType);\n        if (attr === null) {\n            return;\n        }\n        Object.keys(filter.filters).forEach((match) => {\n            for (let i = icons.length - 1; i >= 0; i--) {\n                const value = icons[i][attr];\n                if (value === void 0 || value === null) {\n                    continue;\n                }\n                if (typeof value === 'string') {\n                    if (value === match) {\n                        return;\n                    }\n                    continue;\n                }\n                if (value instanceof Array && value.indexOf(match) !== -1) {\n                    return;\n                }\n            }\n            // No matches\n            filter.filters[match].disabled = true;\n        });\n    });\n    // Apply filters\n    filters.forEach((filter) => {\n        if (filter.active === null) {\n            return;\n        }\n        const match = filter.active;\n        const attr = iconAttr(filter.filterType);\n        if (attr === null) {\n            return;\n        }\n        icons = icons.filter((icon) => {\n            const value = icon[attr];\n            if (value === void 0 || value === null) {\n                return false;\n            }\n            if (typeof value === 'string') {\n                return value === match;\n            }\n            if (value instanceof Array) {\n                return value.indexOf(match) !== -1;\n            }\n            return false;\n        });\n    });\n    block.icons = icons;\n}\nexports.applyIconFilters = applyIconFilters;\n//# sourceMappingURL=icons-list.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.showPagination = exports.getPageForIndex = exports.maxPage = exports.isPaginationEmpty = exports.defaultPaginationBlock = void 0;\n/**\n * Default values\n */\nconst defaultPaginationBlock = () => {\n    return {\n        type: 'pagination',\n        page: 0,\n        length: 0,\n        perPage: 24,\n        more: false,\n    };\n};\nexports.defaultPaginationBlock = defaultPaginationBlock;\n/**\n * Check if pagination is empty\n */\nfunction isPaginationEmpty(block) {\n    return block === void 0 || block === null || block.length <= block.perPage;\n}\nexports.isPaginationEmpty = isPaginationEmpty;\n/**\n * Get maximum page number\n */\nfunction maxPage(block) {\n    return block.perPage && block.length > 0\n        ? Math.floor((block.length - 1) / block.perPage)\n        : 0;\n}\nexports.maxPage = maxPage;\n/**\n * Calculate page where item at index \"index\" is located\n */\nfunction getPageForIndex(perPage, index) {\n    return perPage && index > 0 ? Math.floor(index / perPage) : 0;\n}\nexports.getPageForIndex = getPageForIndex;\n/**\n * Get list of pages to show\n */\nfunction showPagination(block) {\n    const total = block.length ? maxPage(block) + 1 : 0;\n    const pagination = [];\n    let i, min;\n    // Less than 2 pages\n    if (total < 2) {\n        return pagination;\n    }\n    // Show all pages\n    // 3 first + total+-2 + 3 last + 2 spacers = 13\n    if (total < 14) {\n        for (i = 0; i < total; i++) {\n            pagination.push(i);\n        }\n        return pagination;\n    }\n    // First 3 pages\n    for (i = 0; i < Math.min(total, 3); i++) {\n        pagination.push(i);\n    }\n    if ((min = i) >= total) {\n        return pagination;\n    }\n    // Current +- 2 (or - 3 if only 1 page is skipped)\n    for (i = min === block.page - 3 ? min : Math.max(block.page - 2, min); i < Math.min(block.page + 3, total); i++) {\n        pagination.push(i);\n    }\n    if ((min = i) >= total) {\n        return pagination;\n    }\n    // Last 3 (or 4 if only 1 page is skipped)\n    for (i = min === total - 4 ? total - 4 : Math.max(total - 3, min); i < total; i++) {\n        pagination.push(i);\n    }\n    return pagination;\n}\nexports.showPagination = showPagination;\n//# sourceMappingURL=pagination.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSearchBlockEmpty = exports.defaultSearchBlock = void 0;\n/**\n * Default block values\n */\nconst defaultSearchBlock = () => {\n    return {\n        type: 'search',\n        keyword: '',\n    };\n};\nexports.defaultSearchBlock = defaultSearchBlock;\n/**\n * Check if block is empty\n */\nfunction isSearchBlockEmpty(block) {\n    return block === void 0 || block === null || block.keyword.trim() === '';\n}\nexports.isSearchBlockEmpty = isSearchBlockEmpty;\n//# sourceMappingURL=search.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isBlockEmpty = void 0;\nconst collection_info_1 = require(\"./collection-info\");\nconst collections_filter_1 = require(\"./collections-filter\");\nconst collections_list_1 = require(\"./collections-list\");\nconst filters_1 = require(\"./filters\");\nconst icons_list_1 = require(\"./icons-list\");\nconst pagination_1 = require(\"./pagination\");\nconst search_1 = require(\"./search\");\n/**\n * TypeScript guard\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function\nfunction assertNever(s) { }\n/**\n * Check if block is empty\n */\nfunction isBlockEmpty(block) {\n    if (block === void 0 || block === null) {\n        return true;\n    }\n    const type = block.type;\n    switch (type) {\n        case 'collection-info':\n            return collection_info_1.isCollectionInfoBlockEmpty(block);\n        case 'collections-filter':\n            return collections_filter_1.isCollectionsFilterBlockEmpty(block);\n        case 'collections-list':\n            return collections_list_1.isCollectionsBlockEmpty(block);\n        case 'filters':\n            return filters_1.isFiltersBlockEmpty(block);\n        case 'icons-list':\n            return icons_list_1.isIconsListBlockEmpty(block);\n        case 'pagination':\n            return pagination_1.isPaginationEmpty(block);\n        case 'search':\n            return search_1.isSearchBlockEmpty(block);\n        default:\n            assertNever(type);\n            return true;\n    }\n}\nexports.isBlockEmpty = isBlockEmpty;\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIconCode = exports.codeOutputComponentKeys = void 0;\nconst css_1 = require(\"./parsers/css\");\nconst ember_1 = require(\"./parsers/ember\");\nconst react_1 = require(\"./parsers/react\");\nconst svelte_1 = require(\"./parsers/svelte\");\nconst svg_1 = require(\"./parsers/svg\");\nconst svg_framework_1 = require(\"./parsers/svg-framework\");\nconst vue_1 = require(\"./parsers/vue\");\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental\nfunction assertNever(v) {\n    //\n}\n/**\n * Output\n */\nexports.codeOutputComponentKeys = [\n    'install-simple',\n    'install-addon',\n    'install-offline',\n    'import-simple',\n    'import-offline',\n    'vue-simple',\n    'vue-offline',\n    // Usage\n    'use-in-code',\n    'use-in-template',\n    'use-in-html',\n    'use-generic',\n];\n/**\n * Get code for icon\n */\nfunction getIconCode(lang, icon, customisations, providerConfig) {\n    let parser;\n    switch (lang) {\n        // SVG Framework\n        case 'iconify':\n            parser = svg_framework_1.svgFrameworkParser;\n            break;\n        // CSS\n        case 'css':\n            parser = css_1.cssParser;\n            break;\n        // React\n        case 'react-api':\n            parser = react_1.reactParser;\n            break;\n        case 'react-offline':\n            parser = react_1.reactOfflineParser;\n            break;\n        // Vue\n        case 'vue2-api':\n            parser = vue_1.vueParser.bind(null, false);\n            break;\n        case 'vue2-offline':\n            parser = vue_1.vueOfflineParser.bind(null, false);\n            break;\n        case 'vue3-api':\n            parser = vue_1.vueParser.bind(null, true);\n            break;\n        case 'vue3-offline':\n            parser = vue_1.vueOfflineParser.bind(null, true);\n            break;\n        // Svelte\n        case 'svelte-api':\n            parser = svelte_1.svelteParser;\n            break;\n        case 'svelte-offline':\n            parser = svelte_1.svelteOfflineParser;\n            break;\n        // Ember\n        case 'ember':\n            parser = ember_1.emberParser;\n            break;\n        // SVG\n        case 'svg-box':\n        case 'svg-raw':\n        case 'svg-uri':\n            parser = svg_1.svgParser.bind(null, lang);\n            break;\n        default:\n            assertNever(lang);\n            return null;\n    }\n    return parser(icon, customisations, providerConfig);\n}\nexports.getIconCode = getIconCode;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.renderHTML = void 0;\nconst build_1 = require(\"@iconify/utils/lib/svg/build\");\nfunction renderHTML(icon, customisations, className) {\n    const buildResult = build_1.iconToSVG(icon, customisations);\n    // Style\n    const style = [];\n    if (customisations.inline) {\n        style.push('vertical-align: -0.125em');\n    }\n    /*\n    if (customisations.color !== '') {\n        style.push('color: ' + customisations.color);\n    }\n    */\n    const customAttributes = {};\n    if (typeof className === 'string' && className !== '') {\n        customAttributes['class'] = className;\n    }\n    if (style.length) {\n        customAttributes['style'] = style.join('; ') + ';';\n    }\n    // Generate SVG attributes\n    const attributes = {\n        // Default SVG stuff\n        'xmlns': 'http://www.w3.org/2000/svg',\n        'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n        'aria-hidden': 'true',\n        'role': 'img',\n        // Custom attributes\n        ...customAttributes,\n        // Attributes from build result\n        ...buildResult.attributes,\n    };\n    // Replace color inside SVG\n    let body = buildResult.body;\n    if (customisations.color !== '') {\n        body = body.replace(/currentColor/g, customisations.color);\n    }\n    // Generate HTML\n    return ('<svg ' +\n        Object.keys(attributes)\n            .map((key) => {\n            // There should be no quotes in content, so nothing to encode\n            return key + '=\"' + attributes[key] + '\"';\n        })\n            .join(' ') +\n        '>' +\n        body +\n        '</svg>');\n}\nexports.renderHTML = renderHTML;\n//# sourceMappingURL=html.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeAttributes = exports.mergeAttr = exports.addEmberAttr = exports.addVueAttr = exports.addReactAttr = exports.addDynamicAttr = exports.addAttr = exports.npmIconImport = exports.getCustomisationsList = exports.docsBase = exports.getCustomisationAttributes = exports.toString = exports.degrees = exports.isNumber = exports.iconToVarName = void 0;\nconst customisations_1 = require(\"../../misc/customisations\");\n/**\n * Convert icon name to variable\n */\nfunction iconToVarName(iconName) {\n    let name = '';\n    const parts = iconName.split('-');\n    parts.forEach((part, index) => {\n        name += index ? part.slice(0, 1).toUpperCase() + part.slice(1) : part;\n    });\n    if (name.charCodeAt(0) < 97 || name.charCodeAt(0) > 122) {\n        // Not a-z - add \"icon\" at start\n        name = 'icon' + name.slice(0, 1).toUpperCase() + name.slice(1);\n    }\n    else if (parts.length < 2) {\n        // Add \"Icon\" to avoid reserved keywords\n        name += 'Icon';\n    }\n    return name;\n}\nexports.iconToVarName = iconToVarName;\n/**\n * Check if string contains units\n */\nfunction isNumber(value) {\n    return typeof value === 'number'\n        ? true\n        : typeof value === 'string'\n            ? !!value.match(/^-?[0-9.]+$/)\n            : false;\n}\nexports.isNumber = isNumber;\n/**\n * Convert number to degrees string\n */\nfunction degrees(value) {\n    return value * 90 + 'deg';\n}\nexports.degrees = degrees;\n/**\n * Convert value to string\n */\nfunction toString(value) {\n    switch (typeof value) {\n        case 'number':\n            return value + '';\n        case 'string':\n            return value;\n        default:\n            return JSON.stringify(value);\n    }\n}\nexports.toString = toString;\n/**\n * List of attributes\n */\nconst baseCustomisationAttributes = [\n    'width',\n    'height',\n    'rotate',\n    'hFlip',\n    'vFlip',\n    'hAlign',\n    'vAlign',\n    'slice',\n];\nfunction getCustomisationAttributes(color, inline) {\n    const results = baseCustomisationAttributes.slice(0);\n    if (color) {\n        results.push('color');\n    }\n    if (inline) {\n        results.push('inline');\n    }\n    return results;\n}\nexports.getCustomisationAttributes = getCustomisationAttributes;\n/**\n * Documentation\n */\nexports.docsBase = 'https://docs.iconify.design/icon-components/';\nfunction getCustomisationsList(customisations) {\n    const results = new Set();\n    // Add color\n    if (customisations.color !== '') {\n        results.add('color');\n    }\n    // Add dimensions\n    const width = customisations.width;\n    const hasWidth = width !== null && width !== '';\n    const height = customisations.height;\n    const hasHeight = height !== null && height !== '';\n    if (hasWidth) {\n        results.add('width');\n    }\n    if (hasHeight) {\n        results.add(hasWidth || height === 'auto' ? 'height' : 'onlyHeight');\n    }\n    // Transformations and alignment\n    ['rotate', 'hFlip', 'vFlip', 'hAlign', 'vAlign', 'slice'].forEach((prop) => {\n        const key = prop;\n        const value = customisations[key];\n        if (value !== void 0 && value !== customisations_1.emptyCustomisations[key]) {\n            results.add(key);\n        }\n    });\n    // Inline\n    if (customisations.inline) {\n        results.add('inline');\n    }\n    return results;\n}\nexports.getCustomisationsList = getCustomisationsList;\nfunction npmIconImport(icon, name, providerConfig, preferES) {\n    const npm = preferES\n        ? providerConfig.npmES\n            ? providerConfig.npmES\n            : providerConfig.npmCJS\n        : providerConfig.npmCJS\n            ? providerConfig.npmCJS\n            : providerConfig.npmES;\n    if (!npm) {\n        return null;\n    }\n    const packageName = typeof npm.package === 'string'\n        ? npm.package.replace('{prefix}', icon.prefix)\n        : typeof npm.package === 'function'\n            ? npm.package(providerConfig, icon)\n            : null;\n    if (typeof packageName !== 'string') {\n        return null;\n    }\n    const file = typeof npm.file === 'string'\n        ? npm.file.replace('{name}', icon.name)\n        : typeof npm.file === 'function'\n            ? npm.file(providerConfig, icon)\n            : null;\n    if (typeof file !== 'string') {\n        return null;\n    }\n    const code = 'import ' + name + \" from '\" + packageName + file + \"';\";\n    return {\n        name,\n        package: packageName,\n        file,\n        code,\n    };\n}\nexports.npmIconImport = npmIconImport;\nfunction addAttr(list, key, value) {\n    list[key] = {\n        key,\n        value,\n    };\n}\nexports.addAttr = addAttr;\nfunction addDynamicAttr(list, key, anyValue, syntax) {\n    let value;\n    switch (typeof anyValue) {\n        case 'boolean':\n            value = anyValue ? 'true' : 'false';\n            break;\n        case 'object':\n            value = JSON.stringify(anyValue);\n            break;\n        default:\n            value = anyValue;\n    }\n    list[key] = {\n        key,\n        value,\n        syntax,\n    };\n}\nexports.addDynamicAttr = addDynamicAttr;\nfunction addReactAttr(list, key, value) {\n    if (typeof value === 'string' && key !== 'icon') {\n        addAttr(list, key, value);\n    }\n    else {\n        addDynamicAttr(list, key, value, '{var}={{value}}');\n    }\n}\nexports.addReactAttr = addReactAttr;\nfunction addVueAttr(list, key, value) {\n    if (typeof value === 'string' && key !== 'icon') {\n        addAttr(list, key, value);\n    }\n    else {\n        addDynamicAttr(list, key, value, ':{var}=\"{value}\"');\n    }\n}\nexports.addVueAttr = addVueAttr;\nfunction addEmberAttr(list, key, value) {\n    if (typeof value === 'string') {\n        addAttr(list, '@' + key, value);\n    }\n    else {\n        addDynamicAttr(list, key, value, '@{var}={{{value}}}');\n    }\n}\nexports.addEmberAttr = addEmberAttr;\n/**\n * Merge attribute values\n */\nfunction mergeAttr(list, key, value, separator) {\n    const oldItem = typeof list[key] === 'object'\n        ? list[key]\n        : void 0;\n    list[key] = {\n        key,\n        value: (oldItem ? oldItem.value + separator : '') + value,\n        syntax: oldItem ? oldItem.syntax : void 0,\n    };\n}\nexports.mergeAttr = mergeAttr;\n/**\n * Merge result\n */\nfunction mergeAttributes(list) {\n    return Object.keys(list)\n        .map((key) => {\n        const item = list[key];\n        if (typeof item === 'object') {\n            return (typeof item.syntax === 'string'\n                ? item.syntax\n                : '{var}=\"{value}\"')\n                .replace('{var}', item.key)\n                .replace('{value}', item.value);\n        }\n        return item;\n    })\n        .join(' ');\n}\nexports.mergeAttributes = mergeAttributes;\n//# sourceMappingURL=common.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cssParser = void 0;\nconst common_1 = require(\"./common\");\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental\nfunction assertNever(v) {\n    //\n}\n// Documentation links\nconst docs = {\n    type: 'css',\n    href: common_1.docsBase + 'css.html',\n};\n/**\n * Code output for CSS\n */\nconst cssParser = (icon, customisations, providerConfig) => {\n    if (typeof providerConfig.svg !== 'string') {\n        return null;\n    }\n    // Parse all customisations\n    const list = {};\n    common_1.getCustomisationsList(customisations).forEach((attr) => {\n        switch (attr) {\n            // Ignore\n            case 'inline':\n                break;\n            // Color\n            case 'color':\n                common_1.addAttr(list, 'color', customisations[attr]);\n                break;\n            // Dimensions\n            case 'width':\n            case 'height':\n                common_1.addAttr(list, attr, common_1.toString(customisations[attr]));\n                break;\n            case 'onlyHeight':\n                common_1.addAttr(list, 'height', common_1.toString(customisations.height));\n                break;\n            // Transformations\n            case 'rotate':\n                common_1.addAttr(list, attr, common_1.degrees(customisations[attr]));\n                break;\n            case 'hFlip':\n                common_1.mergeAttr(list, 'flip', 'horizontal', ',');\n                break;\n            case 'vFlip':\n                common_1.mergeAttr(list, 'flip', 'vertical', ',');\n                break;\n            // Alignment\n            case 'hAlign':\n            case 'vAlign':\n                common_1.mergeAttr(list, 'align', customisations[attr], ',');\n                break;\n            case 'slice':\n                common_1.mergeAttr(list, 'align', attr, ',');\n                break;\n            default:\n                assertNever(attr);\n        }\n    });\n    // Generate params\n    const params = Object.keys(list)\n        .map((key) => {\n        const item = list[key];\n        if (typeof item === 'object') {\n            return item.key + '=' + encodeURIComponent(item.value);\n        }\n        return key + '=' + encodeURIComponent(item);\n    })\n        .join('&');\n    // Get URL\n    const url = providerConfig.svg\n        .replace('{prefix}', icon.prefix)\n        .replace('{name}', icon.name) + (params ? '?' + params : '');\n    const result = {\n        raw: [\n            \"background: url('\" + url + \"') no-repeat center center / contain;\",\n            \"content: url('\" + url + \"');\",\n        ],\n        isAPI: true,\n        docs,\n    };\n    return result;\n};\nexports.cssParser = cssParser;\n//# sourceMappingURL=css.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.emberParser = void 0;\nconst icon_1 = require(\"../../misc/icon\");\nconst versions_1 = require(\"../versions\");\nconst common_1 = require(\"./common\");\n// Documentation links\nconst docs = {\n    type: 'ember',\n    href: common_1.docsBase + 'ember/',\n};\n// Code cache\nconst installCode = versions_1.getComponentInstall('ember', true);\n/**\n * Code output for API component\n */\nconst emberParser = (icon, customisations, providerConfig) => {\n    if (!providerConfig.api) {\n        return null;\n    }\n    // List of attributes\n    const list = {};\n    // Add icon name\n    common_1.addEmberAttr(list, 'icon', icon_1.iconToString(icon));\n    // Params\n    common_1.getCustomisationsList(customisations).forEach((attr) => {\n        switch (attr) {\n            case 'onlyHeight': {\n                const value = customisations.height;\n                common_1.addEmberAttr(list, 'height', value);\n                break;\n            }\n            default:\n                common_1.addEmberAttr(list, attr, customisations[attr]);\n        }\n    });\n    // Generate code\n    const code = '<IconifyIcon ' + common_1.mergeAttributes(list) + ' />';\n    const result = {\n        component: {\n            'install-addon': installCode,\n            'use-in-template': code,\n        },\n        isAPI: true,\n        docs,\n    };\n    return result;\n};\nexports.emberParser = emberParser;\n//# sourceMappingURL=ember.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reactOfflineParser = exports.reactParser = void 0;\nconst icon_1 = require(\"../../misc/icon\");\nconst versions_1 = require(\"../versions\");\nconst common_1 = require(\"./common\");\n// Documentation links\nconst docs = {\n    type: 'react',\n    href: common_1.docsBase + 'react/',\n};\n// Code cache\nconst installCode = versions_1.getComponentInstall('react', true);\nconst importCode = \"import { Icon } from '\" + versions_1.componentPackages.react.name + \"';\";\n/**\n * Add properties and generate code\n */\nfunction generateCode(list, customisations) {\n    // Parse all customisations\n    common_1.getCustomisationsList(customisations).forEach((attr) => {\n        switch (attr) {\n            case 'onlyHeight': {\n                const value = customisations.height;\n                common_1.addReactAttr(list, 'height', value);\n                break;\n            }\n            default:\n                common_1.addReactAttr(list, attr, customisations[attr]);\n        }\n    });\n    return '<Icon ' + common_1.mergeAttributes(list) + ' />';\n}\n/**\n * Code output for API component\n */\nconst reactParser = (icon, customisations, providerConfig) => {\n    if (!providerConfig.api) {\n        return null;\n    }\n    // List of attributes\n    const list = {};\n    // Add icon name\n    common_1.addAttr(list, 'icon', icon_1.iconToString(icon));\n    // Generate code\n    const code = generateCode(list, customisations);\n    const result = {\n        component: {\n            'install-simple': installCode,\n            'import-simple': importCode,\n            'use-in-template': code,\n        },\n        isAPI: true,\n        docs,\n    };\n    return result;\n};\nexports.reactParser = reactParser;\n/**\n * Code output for offline component\n */\nconst reactOfflineParser = (icon, customisations, providerConfig) => {\n    if (!providerConfig.npmCJS && !providerConfig.npmES) {\n        return null;\n    }\n    // Variable name\n    const varName = common_1.iconToVarName(icon.name);\n    // Import statement\n    const npmImport = common_1.npmIconImport(icon, varName, providerConfig, false);\n    if (!npmImport) {\n        return null;\n    }\n    // List of attributes\n    const list = {};\n    // Add icon name\n    common_1.addReactAttr(list, 'icon', varName);\n    // Generate code\n    const code = generateCode(list, customisations);\n    const result = {\n        component: {\n            'install-offline': installCode + ' ' + npmImport.package,\n            'import-offline': importCode + '\\n' + npmImport.code,\n            'use-in-template': code,\n        },\n        isAPI: false,\n        docs,\n    };\n    return result;\n};\nexports.reactOfflineParser = reactOfflineParser;\n//# sourceMappingURL=react.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.svelteOfflineParser = exports.svelteParser = void 0;\nconst icon_1 = require(\"../../misc/icon\");\nconst versions_1 = require(\"../versions\");\nconst common_1 = require(\"./common\");\n// Documentation links\nconst docs = {\n    type: 'svelte',\n    href: common_1.docsBase + 'svelte/',\n};\n// Code cache\nconst installCode = versions_1.getComponentInstall('svelte', true);\nconst importCode = \"import Icon from '\" + versions_1.componentPackages.svelte.name + \"';\";\n/**\n * Add properties and generate code\n */\nfunction generateCode(list, customisations) {\n    // Parse all customisations\n    common_1.getCustomisationsList(customisations).forEach((attr) => {\n        switch (attr) {\n            case 'onlyHeight': {\n                const value = customisations.height;\n                common_1.addReactAttr(list, 'height', value);\n                break;\n            }\n            default:\n                common_1.addReactAttr(list, attr, customisations[attr]);\n        }\n    });\n    return '<Icon ' + common_1.mergeAttributes(list) + ' />';\n}\n/**\n * Code output for API component\n */\nconst svelteParser = (icon, customisations, providerConfig) => {\n    if (!providerConfig.api) {\n        return null;\n    }\n    // List of attributes\n    const list = {};\n    // Add icon name\n    common_1.addAttr(list, 'icon', icon_1.iconToString(icon));\n    // Generate code\n    const code = generateCode(list, customisations);\n    const result = {\n        component: {\n            'install-simple': installCode,\n            'import-simple': importCode,\n            'use-in-template': code,\n        },\n        isAPI: true,\n        docs,\n    };\n    return result;\n};\nexports.svelteParser = svelteParser;\n/**\n * Code output for offline component\n */\nconst svelteOfflineParser = (icon, customisations, providerConfig) => {\n    if (!providerConfig.npmCJS && !providerConfig.npmES) {\n        return null;\n    }\n    // Variable name\n    const varName = common_1.iconToVarName(icon.name);\n    // Import statement\n    const npmImport = common_1.npmIconImport(icon, varName, providerConfig, false);\n    if (!npmImport) {\n        return null;\n    }\n    // List of attributes\n    const list = {};\n    // Add icon name\n    common_1.addReactAttr(list, 'icon', varName);\n    // Generate code\n    const code = generateCode(list, customisations);\n    const result = {\n        component: {\n            'install-offline': installCode + ' ' + npmImport.package,\n            'import-offline': importCode + '\\n' + npmImport.code,\n            'use-in-template': code,\n        },\n        isAPI: false,\n        docs,\n    };\n    return result;\n};\nexports.svelteOfflineParser = svelteOfflineParser;\n//# sourceMappingURL=svelte.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.svgFrameworkParser = void 0;\nconst iconify_1 = require(\"../../iconify\");\nconst icon_1 = require(\"../../misc/icon\");\nconst versions_1 = require(\"../versions\");\nconst common_1 = require(\"./common\");\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental\nfunction assertNever(v) {\n    //\n}\n// Documentation links\nconst docs = {\n    type: 'iconify',\n    href: common_1.docsBase + 'svg-framework/',\n};\n// Head section\nlet head;\n/**\n * Code output for SVG Framework\n */\nconst svgFrameworkParser = (icon, customisations, providerConfig) => {\n    if (!providerConfig.api) {\n        return null;\n    }\n    // List of attributes\n    const list = {};\n    // Add class\n    common_1.addAttr(list, 'class', customisations.inline ? 'iconify-inline' : 'iconify');\n    // Add icon name\n    common_1.addAttr(list, 'data-icon', icon_1.iconToString(icon));\n    // Parse all customisations\n    common_1.getCustomisationsList(customisations).forEach((attr) => {\n        switch (attr) {\n            case 'inline':\n                break;\n            // Color\n            case 'color':\n                common_1.mergeAttr(list, 'style', 'color: ' + customisations[attr] + ';', ' ');\n                break;\n            // Dimensions\n            case 'width':\n                common_1.addAttr(list, 'data-width', common_1.toString(customisations[attr]));\n                break;\n            case 'onlyHeight': {\n                const value = customisations.height;\n                common_1.mergeAttr(list, 'style', 'font-size: ' + value + (common_1.isNumber(value) ? 'px;' : ';'), ' ');\n                break;\n            }\n            case 'height':\n                common_1.addAttr(list, 'data-height', common_1.toString(customisations[attr]));\n                break;\n            // Transformations\n            case 'rotate':\n                common_1.addAttr(list, 'data-rotate', common_1.degrees(customisations[attr]));\n                break;\n            case 'hFlip':\n                common_1.mergeAttr(list, 'data-flip', 'horizontal', ',');\n                break;\n            case 'vFlip':\n                common_1.mergeAttr(list, 'data-flip', 'vertical', ',');\n                break;\n            // Alignment\n            case 'hAlign':\n            case 'vAlign':\n                common_1.mergeAttr(list, 'data-align', customisations[attr], ',');\n                break;\n            case 'slice':\n                common_1.mergeAttr(list, 'data-align', attr, ',');\n                break;\n            default:\n                assertNever(attr);\n        }\n    });\n    // Generate HTML\n    const html = '<span ' + common_1.mergeAttributes(list) + '></span>';\n    // Head script\n    if (head === void 0) {\n        const str = iconify_1.Iconify.getVersion ? iconify_1.Iconify.getVersion() : versions_1.iconifyVersion;\n        head =\n            '<script src=\"https://code.iconify.design/' +\n                str.split('.').shift() +\n                '/' +\n                str +\n                '/iconify.min.js\"><' +\n                '/script>';\n    }\n    const result = {\n        iconify: {\n            head,\n            html,\n        },\n        isAPI: true,\n        docs,\n    };\n    return result;\n};\nexports.svgFrameworkParser = svgFrameworkParser;\n//# sourceMappingURL=svg-framework.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.svgParser = void 0;\nconst iconify_1 = require(\"../../iconify\");\nconst icon_1 = require(\"../../misc/icon\");\nconst html_1 = require(\"../html\");\n/**\n * Code output for API component\n */\nfunction svgParser(lang, icon, customisations, providerConfig) {\n    var _a;\n    if (!providerConfig.raw) {\n        return null;\n    }\n    const iconName = icon_1.iconToString(icon);\n    const data = (_a = iconify_1.Iconify.getIcon) === null || _a === void 0 ? void 0 : _a.call(iconify_1.Iconify, iconName);\n    if (!data) {\n        return null;\n    }\n    let str = html_1.renderHTML(data, customisations);\n    switch (lang) {\n        case 'svg-box':\n            // Add empty rectangle before shapes\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            str = str.replace('>', '><rect x=\"' +\n                data.left +\n                '\" y=\"' +\n                data.top +\n                '\" width=\"' +\n                data.width +\n                '\" height=\"' +\n                data.height +\n                '\" fill=\"none\" stroke=\"none\" />');\n            break;\n        case 'svg-uri': {\n            // Remove unused attributes\n            const parts = str.split('>');\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            let firstTag = parts.shift();\n            ['aria-hidden', 'focusable', 'role', 'class', 'style'].forEach((attr) => {\n                firstTag = firstTag.replace(new RegExp('\\\\s' + attr + '=\"[^\"]*\"'), '');\n            });\n            parts.unshift(firstTag);\n            str = parts.join('>');\n            // Encode\n            str = \"url('data:image/svg+xml,\" + encodeURIComponent(str) + \"')\";\n            break;\n        }\n    }\n    const result = {\n        raw: [str],\n        isAPI: false,\n    };\n    return result;\n}\nexports.svgParser = svgParser;\n//# sourceMappingURL=svg.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.vueOfflineParser = exports.vueParser = void 0;\nconst icon_1 = require(\"../../misc/icon\");\nconst versions_1 = require(\"../versions\");\nconst common_1 = require(\"./common\");\n// Documentation links\nconst docs2 = {\n    type: 'vue',\n    href: common_1.docsBase + 'vue2/',\n};\nconst docs3 = {\n    type: 'vue',\n    href: common_1.docsBase + 'vue/',\n};\n// Code cache\nconst installCode2 = versions_1.getComponentInstall('vue2', true);\nconst installCode3 = versions_1.getComponentInstall('vue3', true);\nconst importCode2 = \"import { Icon } from '\" + versions_1.componentPackages.vue2.name + \"';\";\nconst importCode3 = \"import { Icon } from '\" + versions_1.componentPackages.vue3.name + \"';\";\nconst scriptCode = 'export default {\\n\\tcomponents: {\\n\\t\\tIcon,\\n\\t},\\n});';\nconst scriptOfflineCode = 'export default {\\n\\tcomponents: {\\n\\t\\tIcon,\\n\\t},\\n\\tdata() {\\n\\t\\treturn {\\n\\t\\t\\ticons: {\\n\\t\\t\\t\\t{varName},\\n\\t\\t\\t},\\n\\t\\t};\\n\\t},\\n});';\n/**\n * Add properties and generate code\n */\nfunction generateCode(list, customisations) {\n    // Parse all customisations\n    common_1.getCustomisationsList(customisations).forEach((attr) => {\n        switch (attr) {\n            case 'onlyHeight': {\n                const value = customisations.height;\n                common_1.addVueAttr(list, 'height', value);\n                break;\n            }\n            case 'hFlip':\n            case 'vFlip':\n            case 'hAlign':\n            case 'vAlign': {\n                common_1.addVueAttr(list, (attr.slice(0, 1) === 'h' ? 'horizontal' : 'vertical') +\n                    attr.slice(1), customisations[attr]);\n                break;\n            }\n            default:\n                common_1.addVueAttr(list, attr, customisations[attr]);\n        }\n    });\n    return '<Icon ' + common_1.mergeAttributes(list) + ' />';\n}\n/**\n * Code output for API component\n */\nfunction vueParser(vue3, icon, customisations, providerConfig) {\n    if (!providerConfig.api) {\n        return null;\n    }\n    // List of attributes\n    const list = {};\n    // Add icon name\n    common_1.addAttr(list, 'icon', icon_1.iconToString(icon));\n    // Generate code\n    const code = generateCode(list, customisations);\n    const result = {\n        component: {\n            'install-simple': vue3 ? installCode3 : installCode2,\n            'import-simple': vue3 ? importCode3 : importCode2,\n            'use-in-template': code,\n            'vue-simple': scriptCode,\n        },\n        isAPI: true,\n        docs: vue3 ? docs3 : docs2,\n    };\n    return result;\n}\nexports.vueParser = vueParser;\n/**\n * Code output for offline component\n */\nfunction vueOfflineParser(vue3, icon, customisations, providerConfig) {\n    if (!providerConfig.npmCJS && !providerConfig.npmES) {\n        return null;\n    }\n    // Variable name\n    const varName = common_1.iconToVarName(icon.name);\n    // Import statement\n    const npmImport = common_1.npmIconImport(icon, varName, providerConfig, vue3);\n    if (!npmImport) {\n        return null;\n    }\n    // List of attributes\n    const list = {};\n    // Add icon name\n    common_1.addVueAttr(list, 'icon', 'icons.' + varName);\n    // Generate code\n    const code = generateCode(list, customisations);\n    const result = {\n        component: {\n            'install-offline': (vue3 ? installCode3 : installCode2) + ' ' + npmImport.package,\n            'import-offline': (vue3 ? importCode3 : importCode2) + '\\n' + npmImport.code,\n            'use-in-template': code,\n            'vue-offline': scriptOfflineCode.replace('{varName}', varName),\n        },\n        isAPI: false,\n        docs: vue3 ? docs3 : docs2,\n    };\n    return result;\n}\nexports.vueOfflineParser = vueOfflineParser;\n//# sourceMappingURL=vue.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.translateCodeSampleTitles = exports.capitalizeCodeSampleTitle = exports.codeSampleTitles = void 0;\nconst capitalize_1 = require(\"../misc/capitalize\");\n/**\n * Code sample tab and mode titles\n *\n * This list contains only items that require custom text.\n * Everything else will be capitalized using capitalizeCodeSampleTitle() function, such as 'vue2' changed to 'Vue 2'\n */\nexports.codeSampleTitles = {\n    'iconify': 'SVG Framework',\n    'html': 'HTML',\n    'css': 'CSS',\n    'svg': 'SVG',\n    'svg-raw': 'SVG',\n    'svg-box': 'SVG with viewBox rectangle',\n    'svg-uri': 'SVG as data: URI',\n    'react-offline': 'React (offline)',\n    'react-api': 'React',\n    'vue2-offline': 'Vue 2 (offline)',\n    'vue2-api': 'Vue 2',\n    'offline': '(offline)',\n};\n/**\n * Capitalize code sample title\n */\nfunction capitalizeCodeSampleTitle(key) {\n    const customValue = exports.codeSampleTitles[key];\n    if (customValue !== void 0) {\n        return customValue;\n    }\n    // Check for '-offline' and '-api'\n    const parts = key.split('-');\n    if (parts.length > 1) {\n        const lastPart = parts.pop();\n        const testKey = parts.join('-');\n        switch (lastPart) {\n            case 'offline':\n                return (capitalizeCodeSampleTitle(testKey) +\n                    ' ' +\n                    exports.codeSampleTitles.offline);\n            case 'api':\n                return capitalizeCodeSampleTitle(testKey);\n        }\n    }\n    // Return capitalised value\n    return capitalize_1.capitalize(key);\n}\nexports.capitalizeCodeSampleTitle = capitalizeCodeSampleTitle;\n/**\n * Add / replace custom sample titles\n */\nfunction translateCodeSampleTitles(translation) {\n    for (const key in translation) {\n        const attr = key;\n        exports.codeSampleTitles[attr] = translation[attr];\n    }\n}\nexports.translateCodeSampleTitles = translateCodeSampleTitles;\n//# sourceMappingURL=phrases.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCodeSamplesTree = void 0;\nconst phrases_1 = require(\"./phrases\");\nconst iconify_1 = require(\"../iconify\");\nconst rawCodeTabs = {\n    html: {\n        iconify: 'api',\n        css: 'svg',\n    },\n    react: {\n        'react-api': 'api',\n        'react-offline': 'offline',\n    },\n    vue: {\n        'vue3-api': 'api',\n        'vue2-api': 'api',\n        'vue3-offline': 'offline',\n        'vue2-offline': 'offline',\n    },\n    svelte: {\n        'svelte-api': 'api',\n        'svelte-offline': 'offline',\n    },\n    ember: 'api',\n    svg: {\n        'svg-raw': 'raw',\n        'svg-box': 'raw',\n        'svg-uri': 'raw',\n    },\n};\n/**\n * Get code samples tree\n */\nfunction getCodeSamplesTree(config) {\n    const results = [];\n    /**\n     * Check if code sample can be shown\n     */\n    function canUse(mode, type) {\n        // Check for required functions\n        switch (mode) {\n            case 'svg-box':\n            case 'svg-raw':\n            case 'svg-uri':\n                if (!iconify_1.Iconify.getIcon) {\n                    return false;\n                }\n        }\n        // Check type\n        switch (type) {\n            case 'raw':\n                return config[type];\n            case 'api':\n                return config.api;\n            case 'svg':\n                return config.svg !== void 0;\n            case 'offline':\n                return config.npmES !== void 0 || config.npmCJS !== void 0;\n        }\n    }\n    /**\n     * Get title\n     */\n    function getTitle(mode) {\n        if (phrases_1.codeSampleTitles[mode] !== void 0) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return phrases_1.codeSampleTitles[mode];\n        }\n        return phrases_1.capitalizeCodeSampleTitle(mode);\n    }\n    for (const key in rawCodeTabs) {\n        // Using weird type casting because TypeScript can't property resolve it\n        const attr = key;\n        const item = rawCodeTabs[key];\n        // Item without children\n        if (typeof item === 'string') {\n            const mode = attr;\n            if (canUse(mode, item)) {\n                // Add item without children\n                const newItem = {\n                    mode,\n                    type: item,\n                    title: getTitle(attr),\n                };\n                results.push(newItem);\n            }\n            else {\n                console.error('Cannot use mode:', mode, item);\n            }\n            continue;\n        }\n        // Item with children\n        const children = [];\n        for (const key2 in item) {\n            const mode = key2;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const type = item[mode];\n            if (canUse(mode, type)) {\n                const newItem = {\n                    mode,\n                    type,\n                    title: getTitle(mode),\n                };\n                children.push(newItem);\n            }\n        }\n        let firstChild;\n        const tab = attr;\n        const title = getTitle(tab);\n        switch (children.length) {\n            case 0:\n                break;\n            case 1:\n                // Merge children\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                firstChild = children[0];\n                results.push({\n                    tab,\n                    mode: firstChild.mode,\n                    type: firstChild.type,\n                    title,\n                });\n                break;\n            default:\n                // Add all children\n                results.push({\n                    tab,\n                    children,\n                    title,\n                });\n        }\n    }\n    return results;\n}\nexports.getCodeSamplesTree = getCodeSamplesTree;\n//# sourceMappingURL=tree.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getComponentInstall = exports.componentPackages = exports.iconifyVersion = void 0;\n// Iconify version (do not edit it, replaced during build!)\nexports.iconifyVersion = '2.0.3';\nexports.componentPackages = {\n    react: {\n        name: '@iconify/react',\n    },\n    vue2: {\n        name: '@iconify/vue2',\n    },\n    vue3: {\n        name: '@iconify/vue',\n    },\n    svelte: {\n        name: '@iconify/svelte',\n    },\n    ember: {\n        name: '@iconify/ember',\n    },\n};\n/**\n * Get package name to install\n */\nfunction getComponentInstall(key, dev) {\n    const item = exports.componentPackages[key];\n    let result = item.name;\n    if (item.version !== void 0) {\n        result += item.version;\n    }\n    if (typeof dev === 'boolean') {\n        return 'npm install --save' + (dev ? '-dev ' : ' ') + result;\n    }\n    return result;\n}\nexports.getComponentInstall = getComponentInstall;\n//# sourceMappingURL=versions.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rawDataToCollection = exports.dataToCollection = void 0;\nconst info_1 = require(\"./info\");\n/**\n * Parse themes\n */\nfunction parseThemes(iconSet, sortedIcons, result) {\n    const data = {\n        prefix: {\n            hasEmpty: false,\n            hasUncategorized: false,\n            values: [],\n            titles: Object.create(null),\n            found: Object.create(null),\n            test: (name, test) => name.slice(0, test.length) === test,\n        },\n        suffix: {\n            hasEmpty: false,\n            hasUncategorized: false,\n            values: [],\n            titles: Object.create(null),\n            found: Object.create(null),\n            test: (name, test) => name.slice(0 - test.length) === test,\n        },\n    };\n    const keys = ['prefix', 'suffix'];\n    // Converted icon set data, using ThemeType as key, new theme format as value\n    const iconSetData = {\n        prefix: null,\n        suffix: null,\n    };\n    // Convert legacy format\n    if (typeof iconSet.themes === 'object' && iconSet.themes) {\n        const themes = iconSet.themes;\n        Object.keys(themes).forEach((key) => {\n            const theme = themes[key];\n            keys.forEach((attr) => {\n                const prop = attr;\n                if (typeof theme[prop] === 'string') {\n                    // Has prefix or suffix\n                    const value = theme[prop];\n                    if (iconSetData[attr] === null) {\n                        iconSetData[attr] = Object.create(null);\n                    }\n                    iconSetData[attr][value] = theme.title;\n                }\n            });\n        });\n    }\n    // Check themes\n    keys.forEach((key) => {\n        const attr = (key + 'es');\n        if (typeof iconSet[attr] === 'object' && iconSet[attr] !== null) {\n            // Prefixes or suffixes exist: overwrite old entry\n            iconSetData[key] = iconSet[attr];\n        }\n        if (!iconSetData[key]) {\n            // No prefix or suffix? Delete entry in data\n            delete data[key];\n            return;\n        }\n        // Validate themes\n        const dataItem = data[key];\n        const theme = iconSetData[key];\n        Object.keys(theme).forEach((value) => {\n            const title = theme[value];\n            if (value !== '') {\n                // Check for '-' at start or end\n                switch (key) {\n                    case 'prefix':\n                        if (value.slice(-1) !== '-') {\n                            value += '-';\n                        }\n                        break;\n                    case 'suffix':\n                        if (value.slice(0, 1) !== '-') {\n                            value = '-' + value;\n                        }\n                        break;\n                }\n            }\n            if (dataItem.titles[value] !== void 0) {\n                // Duplicate entry\n                return;\n            }\n            // Add value\n            if (value === '') {\n                dataItem.hasEmpty = true;\n            }\n            else {\n                dataItem.values.push(value);\n            }\n            // Set data\n            dataItem.titles[value] = title;\n            dataItem.found[value] = 0;\n        });\n        // Check if theme is empty\n        if (!Object.keys(dataItem.titles).length) {\n            delete data[key];\n        }\n    });\n    // Check stuff\n    Object.keys(data).forEach((attr) => {\n        const dataItem = data[attr];\n        const matches = dataItem.values;\n        const iconKey = attr === 'prefix' ? 'themePrefixes' : 'themeSuffixes';\n        // Sort matches by length, then alphabetically\n        matches.sort((a, b) => a.length === b.length ? a.localeCompare(b) : b.length - a.length);\n        // Check all icons\n        sortedIcons.forEach((icon) => {\n            // Check icon\n            (icon.aliases\n                ? [icon.name].concat(icon.aliases)\n                : [icon.name]).forEach((name, index) => {\n                // Find match\n                let theme = null;\n                for (let i = 0; i < matches.length; i++) {\n                    const match = matches[i];\n                    if (dataItem.test(name, match)) {\n                        // Found matching theme\n                        dataItem.found[match]++;\n                        theme = match;\n                        break;\n                    }\n                }\n                if (theme === null && dataItem.hasEmpty && !index) {\n                    // Empty prefix/suffix, but do not test aliases\n                    theme = '';\n                    dataItem.found['']++;\n                }\n                // Get title\n                const title = theme === null ? '' : dataItem.titles[theme];\n                // Not found\n                if (theme === null) {\n                    if (index > 0) {\n                        return;\n                    }\n                    // Uncategorized\n                    dataItem.hasUncategorized = true;\n                    theme = '';\n                }\n                // Found\n                if (icon[iconKey] === void 0) {\n                    icon[iconKey] = [title];\n                    return;\n                }\n                const titles = icon[iconKey];\n                if (titles.indexOf(title) === -1) {\n                    titles.push(title);\n                }\n            });\n        });\n        // Add result\n        const titles = Object.create(null);\n        Object.keys(dataItem.titles).forEach((match) => {\n            if (dataItem.found[match]) {\n                titles[match] = dataItem.titles[match];\n            }\n        });\n        if (dataItem.hasUncategorized) {\n            titles[''] = '';\n        }\n        switch (Object.keys(titles).length) {\n            case 0:\n                // Nothing to do\n                break;\n            case 1:\n                // 1 theme: remove all entries\n                sortedIcons.forEach((icon) => {\n                    delete icon[iconKey];\n                });\n                break;\n            default:\n                // Many entries\n                result[iconKey] = titles;\n        }\n    });\n}\n/**\n * Parse characters map\n */\nfunction parseChars(chars, icons) {\n    Object.keys(chars).forEach((char) => {\n        const name = chars[char];\n        if (icons[name] !== void 0) {\n            const icon = icons[name];\n            if (icon.chars === void 0) {\n                icon.chars = [];\n            }\n            icon.chars.push(char);\n        }\n    });\n}\n/**\n * Convert icons to sorted array\n */\nfunction sortIcons(icons) {\n    const sortedIcons = [];\n    Object.keys(icons)\n        .sort((a, b) => a.localeCompare(b))\n        .forEach((name) => {\n        sortedIcons.push(icons[name]);\n    });\n    return sortedIcons;\n}\n/**\n * Convert collection data\n */\nfunction dataToCollection(provider, data) {\n    if (typeof data !== 'object' || data === null) {\n        return null;\n    }\n    const source = data;\n    // Check required fields\n    if (typeof source.prefix !== 'string') {\n        return null;\n    }\n    // Create result\n    const result = {\n        provider,\n        prefix: source.prefix,\n        name: '',\n        total: 0,\n        icons: [],\n    };\n    // Get info\n    if (typeof source.info === 'object' && source.info !== null) {\n        const info = info_1.dataToCollectionInfo(source.info, result.prefix);\n        if (info === null) {\n            // Invalid info block, so something is wrong\n            return null;\n        }\n        result.info = info;\n    }\n    // Get collection name\n    if (typeof source.name === 'string') {\n        result.name = source.name;\n    }\n    else if (typeof source.title === 'string') {\n        // Correct API response\n        result.name = source.title;\n    }\n    else if (result.info !== void 0) {\n        result.name = result.info.name;\n    }\n    else {\n        result.name = result.prefix;\n    }\n    // Check for categories\n    let tags = typeof source.categories === 'object' && source.categories !== null\n        ? Object.keys(source.categories)\n        : [];\n    let hasUncategorised = false, uncategorisedKey = 'uncategorized';\n    ['uncategorized', 'uncategorised'].forEach((attr) => {\n        if (typeof source[attr] === 'object' &&\n            source[attr] instanceof Array &&\n            source[attr].length > 0) {\n            uncategorisedKey = attr;\n            hasUncategorised = true;\n        }\n    });\n    // Find all icons\n    const icons = Object.create(null);\n    function addCategory(iconsList, category) {\n        let added = false;\n        iconsList.forEach((name) => {\n            if (typeof name !== 'string') {\n                return;\n            }\n            added = true;\n            if (icons[name] === void 0) {\n                // Add new icon\n                const icon = {\n                    provider,\n                    prefix: result.prefix,\n                    name,\n                    tags: [category],\n                };\n                icons[name] = icon;\n                return;\n            }\n            // Add tag to existing icon\n            if (icons[name].tags === void 0) {\n                icons[name].tags = [];\n            }\n            if (icons[name].tags.indexOf(category) === -1) {\n                icons[name].tags.push(category);\n            }\n        });\n        return added;\n    }\n    tags = tags.filter((category) => {\n        let added = false;\n        const categoryItems = source.categories[category];\n        if (categoryItems instanceof Array) {\n            added = addCategory(categoryItems, category);\n        }\n        else {\n            Object.keys(categoryItems).forEach((subcategory) => {\n                const subcategoryItems = categoryItems[subcategory];\n                if (subcategoryItems instanceof Array) {\n                    added = addCategory(subcategoryItems, category) || added;\n                }\n            });\n        }\n        return added;\n    });\n    const hasTags = tags.length > 0;\n    // Add uncategorised icons\n    if (hasUncategorised) {\n        const list = source[uncategorisedKey];\n        list.forEach((name) => {\n            if (typeof name !== 'string') {\n                return;\n            }\n            if (icons[name] === void 0) {\n                // Add new icon\n                const icon = {\n                    provider,\n                    prefix: result.prefix,\n                    name: name,\n                };\n                if (hasTags) {\n                    icon.tags = [''];\n                }\n                icons[name] = icon;\n                return;\n            }\n        });\n        if (hasTags) {\n            tags.push('');\n        }\n    }\n    // Add characters\n    if (typeof source.chars === 'object') {\n        parseChars(source.chars, icons);\n    }\n    // Add aliases\n    const missingAliases = Object.create(null);\n    if (typeof source.aliases === 'object') {\n        const aliases = source.aliases;\n        Object.keys(aliases).forEach((alias) => {\n            const name = aliases[alias];\n            if (icons[name] !== void 0) {\n                const icon = icons[name];\n                if (icon.aliases === void 0) {\n                    icon.aliases = [];\n                }\n                icon.aliases.push(alias);\n                return;\n            }\n            // Alias is not found. Hidden icon?\n            if (missingAliases[name] === void 0) {\n                missingAliases[name] = [];\n            }\n            missingAliases[name].push(alias);\n        });\n    }\n    // Add hidden icons\n    if (source.hidden instanceof Array) {\n        let hidden = [];\n        source.hidden.forEach((icon) => {\n            // Add icon\n            hidden.push(icon);\n            // Look for aliases of hidden icon\n            if (missingAliases[icon] !== void 0) {\n                hidden = hidden.concat(missingAliases[icon]);\n            }\n        });\n        result.hidden = hidden;\n    }\n    // Convert to sorted array\n    const sortedIcons = sortIcons(icons);\n    // Check tags\n    if (tags.length > 1) {\n        result.tags = tags.sort(sortTags);\n    }\n    else if (hasTags) {\n        // Only one tag - delete tags\n        sortedIcons.forEach((icon) => {\n            delete icon.tags;\n        });\n    }\n    // Add themes\n    parseThemes(source, sortedIcons, result);\n    // Add icons\n    result.icons = sortedIcons;\n    result.total = result.icons.length;\n    if (result.info) {\n        result.info.total = result.total;\n    }\n    return result;\n}\nexports.dataToCollection = dataToCollection;\n/**\n * Convert raw data from icon set\n */\nfunction rawDataToCollection(source) {\n    /**\n     * Add icon\n     */\n    function addIcon(name, depth = 0) {\n        if (depth > 3) {\n            // Alias recursion is too high. Do not make aliases of aliases.\n            return null;\n        }\n        if (icons[name] !== void 0) {\n            // Already added\n            return name;\n        }\n        // Add icon\n        if (source.icons[name] !== void 0) {\n            if (!source.icons[name].hidden) {\n                icons[name] = {\n                    provider: result.provider,\n                    prefix: result.prefix,\n                    name,\n                    tags: [],\n                };\n                return name;\n            }\n            return null;\n        }\n        // Add alias\n        if (source.aliases &&\n            source.aliases[name] !== void 0 &&\n            !source.aliases[name].hidden) {\n            // Resolve alias\n            const item = source.aliases[name];\n            const parent = item.parent;\n            // Add parent icon\n            const added = addIcon(parent, depth + 1);\n            if (added !== null) {\n                // Icon was added, which means parent icon is a viable icon\n                // Check if new icon is an alias or full icon\n                if (!(item.rotate || item.hFlip || item.vFlip)) {\n                    // Alias\n                    const parentIcon = icons[added];\n                    if (!parentIcon.aliases) {\n                        parentIcon.aliases = [name];\n                    }\n                    else if (parentIcon.aliases.indexOf(name) === -1) {\n                        parentIcon.aliases.push(name);\n                    }\n                    return added;\n                }\n                else {\n                    // New icon\n                    icons[name] = {\n                        provider: result.provider,\n                        prefix: result.prefix,\n                        name,\n                        tags: [],\n                    };\n                    return name;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Add tag to icons\n     */\n    function addTag(iconsList, tag) {\n        let added = false;\n        iconsList.forEach((name) => {\n            if (icons[name] !== void 0 &&\n                icons[name].tags.indexOf(tag) === -1) {\n                icons[name].tags.push(tag);\n                added = true;\n            }\n        });\n        return added;\n    }\n    // Check required fields\n    if (typeof source.prefix !== 'string') {\n        return null;\n    }\n    const result = {\n        provider: typeof source.provider === 'string' ? source.provider : '',\n        prefix: source.prefix,\n        name: '',\n        total: 0,\n        icons: [],\n    };\n    // Get required info\n    if (typeof source.info !== 'object' || source.info === null) {\n        return null;\n    }\n    const info = info_1.dataToCollectionInfo(source.info, result.prefix);\n    if (info === null) {\n        // Invalid info block, so something is wrong\n        return null;\n    }\n    result.info = info;\n    // Get collection name\n    result.name = result.info.name;\n    // Find all icons\n    const icons = Object.create(null);\n    Object.keys(source.icons).forEach((name) => addIcon(name));\n    if (typeof source.aliases === 'object') {\n        Object.keys(source.aliases).forEach((name) => addIcon(name));\n    }\n    const iconNames = Object.keys(icons);\n    // Check for categories\n    const tags = [];\n    if (typeof source.categories === 'object' && source.categories !== null) {\n        let hasUncategorised = false;\n        const categories = source.categories;\n        Object.keys(categories).forEach((category) => {\n            const categoryItems = categories[category];\n            // Array\n            if (categoryItems instanceof Array) {\n                if (addTag(categoryItems, category)) {\n                    tags.push(category);\n                }\n            }\n            else if (typeof categoryItems === 'object') {\n                // Sub-categories. No longer used, but can be found in some older icon sets\n                Object.keys(categoryItems).forEach((subcategory) => {\n                    const subcategoryItems = categoryItems[subcategory];\n                    if (subcategoryItems instanceof Array) {\n                        if (addTag(subcategoryItems, category) &&\n                            tags.indexOf(category) === -1) {\n                            tags.push(category);\n                        }\n                    }\n                });\n            }\n        });\n        // Check if icons without categories exist\n        iconNames.forEach((name) => {\n            if (!icons[name].tags.length) {\n                icons[name].tags.push('');\n                hasUncategorised = true;\n            }\n        });\n        if (hasUncategorised) {\n            tags.push('');\n        }\n    }\n    // Remove tags if there are less than 2 categories\n    if (tags.length < 2) {\n        Object.keys(icons).forEach((name) => {\n            delete icons[name].tags;\n        });\n    }\n    else {\n        result.tags = tags.sort(sortTags);\n    }\n    // Add characters\n    if (typeof source.chars === 'object') {\n        parseChars(source.chars, icons);\n    }\n    // Sort icons\n    const sortedIcons = sortIcons(icons);\n    // Add themes\n    parseThemes(source, sortedIcons, result);\n    // Add icons\n    result.icons = sortedIcons;\n    result.total = result.info.total = result.icons.length;\n    return result;\n}\nexports.rawDataToCollection = rawDataToCollection;\n/**\n * Sort categories\n */\nfunction sortTags(a, b) {\n    if (a === '') {\n        return 1;\n    }\n    if (b === '') {\n        return -1;\n    }\n    return a.localeCompare(b);\n}\n//# sourceMappingURL=collection.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.autoIndexCollections = exports.filterCollections = exports.collectionsPrefixes = exports.dataToCollections = void 0;\nconst info_1 = require(\"./info\");\n/**\n * Convert data from API to CollectionsList\n */\nfunction dataToCollections(data) {\n    const result = Object.create(null);\n    const uncategorised = Object.create(null);\n    if (typeof data !== 'object' || data === null) {\n        return result;\n    }\n    // Assume Record<prefix, item> structure\n    Object.keys(data).forEach((prefix) => {\n        const row = data[prefix];\n        if (typeof row !== 'object' ||\n            row === null ||\n            typeof row.category !== 'string') {\n            return;\n        }\n        // Convert item\n        const item = info_1.dataToCollectionInfo(row, prefix);\n        if (item === null) {\n            return;\n        }\n        // Add category and item\n        const category = row.category;\n        if (category !== '') {\n            if (result[category] === void 0) {\n                result[category] = Object.create(null);\n            }\n            result[category][prefix] = item;\n        }\n        else {\n            uncategorised[prefix] = item;\n        }\n    });\n    // Add uncategorised at the end\n    if (Object.keys(uncategorised).length > 0) {\n        result[''] = uncategorised;\n    }\n    return result;\n}\nexports.dataToCollections = dataToCollections;\n/**\n * Get collection prefixes from converted collections list\n */\nfunction collectionsPrefixes(collections) {\n    let prefixes = [];\n    Object.keys(collections).forEach((category) => {\n        prefixes = prefixes.concat(Object.keys(collections[category]));\n    });\n    return prefixes;\n}\nexports.collectionsPrefixes = collectionsPrefixes;\n/**\n * Filter collections\n */\nfunction filterCollections(collections, callback, keepEmptyCategories = false) {\n    const result = Object.create(null);\n    // Parse each category\n    Object.keys(collections).forEach((category) => {\n        if (keepEmptyCategories) {\n            result[category] = Object.create(null);\n        }\n        // Parse each item in category\n        Object.keys(collections[category]).forEach((prefix) => {\n            const item = collections[category][prefix];\n            if (!callback(item, category, prefix)) {\n                return;\n            }\n            // Passed filter\n            if (result[category] === void 0) {\n                result[category] = Object.create(null);\n            }\n            result[category][prefix] = item;\n        });\n    });\n    return result;\n}\nexports.filterCollections = filterCollections;\n/**\n * Add indexes to all collections\n */\nfunction autoIndexCollections(collections, start = 0) {\n    let index = start;\n    Object.keys(collections).forEach((category) => {\n        const items = collections[category];\n        Object.keys(items).forEach((prefix) => {\n            items[prefix].index = index++;\n        });\n    });\n}\nexports.autoIndexCollections = autoIndexCollections;\n//# sourceMappingURL=collections.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dataToCollectionInfo = void 0;\nconst minDisplayHeight = 16;\nconst maxDisplayHeight = 24;\n/**\n * Convert data from API to CollectionInfo\n */\nfunction dataToCollectionInfo(data, expectedPrefix = '') {\n    if (typeof data !== 'object' || data === null) {\n        return null;\n    }\n    const source = data;\n    const getSourceNestedString = (field, key, defaultValue = '') => {\n        if (typeof source[field] !== 'object') {\n            return defaultValue;\n        }\n        const obj = source[field];\n        return typeof obj[key] === 'string' ? obj[key] : defaultValue;\n    };\n    // Get name\n    let name;\n    if (typeof source.name === 'string') {\n        name = source.name;\n    }\n    else if (typeof source.title === 'string') {\n        name = source.title;\n    }\n    else {\n        return null;\n    }\n    // Get prefix\n    let prefix;\n    if (expectedPrefix === '') {\n        if (typeof source.prefix !== 'string') {\n            return null;\n        }\n        prefix = source.prefix;\n    }\n    else {\n        if (typeof source.prefix === 'string' &&\n            source.prefix !== expectedPrefix) {\n            // Prefixes do not match\n            return null;\n        }\n        prefix = expectedPrefix;\n    }\n    // Generate data\n    const result = {\n        prefix: prefix,\n        name: name,\n        total: typeof source.total === 'number' ? source.total : 0,\n        version: typeof source.version === 'string' ? source.version : '',\n        author: {\n            name: getSourceNestedString('author', 'name', typeof source.author === 'string' ? source.author : 'Unknown'),\n            url: getSourceNestedString('author', 'url', ''),\n        },\n        license: {\n            title: getSourceNestedString('license', 'title', typeof source.license === 'string' ? source.license : 'Unknown'),\n            spdx: getSourceNestedString('license', 'spdx', ''),\n            url: getSourceNestedString('license', 'url', ''),\n        },\n        samples: [],\n        category: typeof source.category === 'string' ? source.category : '',\n        palette: typeof source.palette === 'boolean' ? source.palette : false,\n    };\n    // Total as string\n    if (typeof source.total === 'string') {\n        const num = parseInt(source.total);\n        if (num > 0) {\n            result.total = num;\n        }\n    }\n    // Add samples\n    if (source.samples instanceof Array) {\n        source.samples.forEach((item) => {\n            if (result.samples.length < 3 && typeof item === 'string') {\n                result.samples.push(item);\n            }\n        });\n    }\n    // Add height\n    if (typeof source.height === 'number' ||\n        typeof source.height === 'string') {\n        const num = parseInt(source.height);\n        if (num > 0) {\n            result.height = num;\n        }\n    }\n    if (source.height instanceof Array) {\n        source.height.forEach((item) => {\n            const num = parseInt(item);\n            if (num > 0) {\n                if (!(result.height instanceof Array)) {\n                    result.height = [];\n                }\n                result.height.push(num);\n            }\n        });\n        switch (result.height.length) {\n            case 0:\n                delete result.height;\n                break;\n            case 1:\n                result.height = result.height[0];\n        }\n    }\n    // Add display height\n    if (typeof result.height === 'number') {\n        // Convert from height\n        result.displayHeight = result.height;\n        while (result.displayHeight < minDisplayHeight) {\n            result.displayHeight *= 2;\n        }\n        while (result.displayHeight > maxDisplayHeight) {\n            result.displayHeight /= 2;\n        }\n        if (result.displayHeight !== Math.round(result.displayHeight) ||\n            result.displayHeight < minDisplayHeight ||\n            result.displayHeight > maxDisplayHeight) {\n            delete result.displayHeight;\n        }\n    }\n    if (typeof source.displayHeight === 'number' ||\n        typeof source.displayHeight === 'string') {\n        // Convert from source.displayHeight\n        const num = parseInt(source.displayHeight);\n        if (num >= minDisplayHeight &&\n            num <= maxDisplayHeight &&\n            Math.round(num) === num) {\n            result.displayHeight = num;\n        }\n    }\n    // Convert palette from string value\n    if (typeof source.palette === 'string') {\n        switch (source.palette.toLowerCase()) {\n            case 'colorless': // Iconify v1\n            case 'false': // Boolean as string\n                result.palette = false;\n                break;\n            case 'colorful': // Iconify v1\n            case 'true': // Boolean as string\n                result.palette = true;\n        }\n    }\n    // Parse all old keys\n    Object.keys(source).forEach((key) => {\n        const value = source[key];\n        if (typeof value !== 'string') {\n            return;\n        }\n        switch (key) {\n            case 'url':\n            case 'uri':\n                result.author.url = value;\n                break;\n            case 'licenseURL':\n            case 'licenseURI':\n                result.license.url = value;\n                break;\n            case 'licenseID':\n            case 'licenseSPDX':\n                result.license.spdx = value;\n                break;\n        }\n    });\n    return result;\n}\nexports.dataToCollectionInfo = dataToCollectionInfo;\n//# sourceMappingURL=info.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dataToSearchResults = void 0;\nconst icon_1 = require(\"../misc/icon\");\nconst info_1 = require(\"./info\");\nfunction dataToSearchResults(provider, data) {\n    if (typeof data !== 'object' || data === null) {\n        return null;\n    }\n    // Get source as object\n    const source = data;\n    if (typeof source.request !== 'object' || source.request === null) {\n        return null;\n    }\n    // Check required attributes\n    const request = source.request;\n    if (typeof request.query !== 'string') {\n        return null;\n    }\n    if (typeof source.total !== 'number' || typeof source.limit !== 'number') {\n        return null;\n    }\n    // Create result\n    const result = {\n        provider,\n        query: request.query,\n        total: source.total,\n        limit: source.limit,\n        icons: [],\n        collections: Object.create(null),\n    };\n    // Parse all icons\n    if (typeof source.collections !== 'object' ||\n        !(source.icons instanceof Array)) {\n        return null;\n    }\n    const sourceIcons = source.icons;\n    const sourceCollections = source.collections;\n    try {\n        sourceIcons.forEach((item) => {\n            const icon = icon_1.stringToIcon(item, true, provider);\n            if (icon === null) {\n                throw new Error('Invalid icon');\n            }\n            result.icons.push(icon);\n            const prefix = icon.prefix;\n            if (result.collections[prefix] === void 0) {\n                // Add collection\n                if (sourceCollections[prefix] === void 0) {\n                    throw new Error(`Missing data for prefix ${prefix}`);\n                }\n                const info = info_1.dataToCollectionInfo(sourceCollections[prefix], prefix);\n                if (info === null) {\n                    throw new Error(`Invalid data for prefix ${prefix}`);\n                }\n                result.collections[prefix] = info;\n            }\n        });\n    }\n    catch (err) {\n        return null;\n    }\n    // Overwrite total\n    result.total = result.icons.length;\n    return result;\n}\nexports.dataToSearchResults = dataToSearchResults;\n//# sourceMappingURL=search.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCollectionTitle = exports.getCollectionInfo = exports.setCollectionInfo = void 0;\n/**\n * Set data\n */\nfunction setCollectionInfo(storage, provider, prefix, data) {\n    if (storage[provider] === void 0) {\n        storage[provider] = Object.create(null);\n    }\n    const providerData = storage[provider];\n    if (providerData[prefix] === void 0 || data.index) {\n        // Overwrite previous entry only if index is set\n        providerData[prefix] = data;\n    }\n}\nexports.setCollectionInfo = setCollectionInfo;\n/**\n * Get data\n */\nfunction getCollectionInfo(storage, provider, prefix) {\n    return storage[provider] === void 0 || storage[provider][prefix] === void 0\n        ? null\n        : storage[provider][prefix];\n}\nexports.getCollectionInfo = getCollectionInfo;\n/**\n * Get collection title (or prefix if not available)\n */\nfunction getCollectionTitle(storage, provider, prefix) {\n    if (storage[provider] === void 0 || storage[provider][prefix] === void 0) {\n        return prefix;\n    }\n    return storage[provider][prefix].name;\n}\nexports.getCollectionTitle = getCollectionTitle;\n//# sourceMappingURL=collections.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.customisedConfig = exports.createConfig = exports.mergeConfig = exports.setComponentsConfig = void 0;\nconst objects_1 = require(\"../misc/objects\");\n/**\n * Default UI config\n */\nconst defaultUIConfig = {\n    // Number of icons per page.\n    itemsPerPage: 52,\n    // Maximum delay between changing current view and updating visible view.\n    // This delay is used to avoid \"loading\" page when changing views.\n    viewUpdateDelay: 300,\n    // Number of sibling collections to show when collection view is child view of collections list.\n    showSiblingCollections: 2,\n};\n/**\n * Router config\n */\nconst defaultRouterConfig = {\n    // Home route as string, empty to automatically detect route\n    home: '',\n    // Allow synchronous rendering when API data is available?\n    syncRender: false,\n};\n/**\n * Default configuration.\n *\n * 2 levels deep object:\n * object[key][key2] = value\n */\nconst defaultConfig = {\n    // UI\n    ui: defaultUIConfig,\n    // Router\n    router: defaultRouterConfig,\n    // Components\n    components: {},\n};\n/**\n * Set default components config\n */\nfunction setComponentsConfig(config) {\n    defaultConfig.components = Object.assign(config);\n}\nexports.setComponentsConfig = setComponentsConfig;\n/**\n * Merge data\n */\nfunction mergeConfig(config, custom) {\n    for (const key in custom) {\n        const attr = key;\n        const configSource = config[attr];\n        if (configSource === void 0) {\n            continue;\n        }\n        // Merge objects\n        const customSource = custom[attr];\n        for (const key2 in customSource) {\n            const attr2 = key2;\n            if (configSource[attr2] !== void 0) {\n                // Overwrite entry\n                configSource[attr2] = customSource[attr2];\n            }\n        }\n    }\n}\nexports.mergeConfig = mergeConfig;\n/**\n * Create configuration object\n */\nfunction createConfig(customValues = {}) {\n    const config = objects_1.cloneObject(defaultConfig);\n    if (customValues) {\n        mergeConfig(config, customValues);\n    }\n    return config;\n}\nexports.createConfig = createConfig;\n/**\n * Get customised configuration values\n */\nfunction customisedConfig(config) {\n    const customised = {};\n    for (const key in config) {\n        const attr = key;\n        const defaultSource = defaultConfig[attr];\n        const configSource = config[attr];\n        const child = {};\n        let found = false;\n        for (const key2 in configSource) {\n            const attr2 = key2;\n            if (configSource[attr2] !== defaultSource[attr2]) {\n                child[attr2] = configSource[attr2];\n                found = true;\n            }\n        }\n        if (found) {\n            customised[attr] = child;\n        }\n    }\n    return customised;\n}\nexports.customisedConfig = customisedConfig;\n//# sourceMappingURL=config.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeCollections = exports.convertCustomSets = exports.emptyConvertedSet = void 0;\nconst iconify_1 = require(\"../iconify\");\nconst collection_1 = require(\"../converters/collection\");\nconst collections_1 = require(\"../converters/collections\");\n/**\n * TypeScript guard\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function\nfunction assertNever(s) { }\n/**\n * Empty\n */\nexports.emptyConvertedSet = {\n    merge: 'custom-last',\n    providers: Object.create(null),\n};\n/**\n * Convert custom icon sets, return empty set on failure\n */\nfunction convertCustomSets(data, importIcons = true) {\n    if (!data.iconSets || !data.iconSets.length) {\n        return exports.emptyConvertedSet;\n    }\n    // Merge\n    let merge = 'only-custom';\n    switch (data.merge) {\n        case 'custom-first':\n        case 'custom-last':\n        case 'only-custom':\n            merge = data.merge;\n            break;\n        case void 0:\n            break;\n        default:\n            assertNever(data.merge);\n    }\n    // Set basic data\n    const result = {\n        merge,\n        providers: Object.create(null),\n    };\n    // Info to parse later\n    const rawInfo = Object.create(null);\n    // Get all providers, add icon sets to Iconify.\n    data.iconSets.forEach((item) => {\n        if (typeof item.prefix !== 'string') {\n            return;\n        }\n        // Get/set provider\n        if (typeof data.provider === 'string') {\n            item.provider = data.provider;\n        }\n        const provider = typeof item.provider === 'string' ? item.provider : '';\n        // Custom info block\n        if (!item.info && data.info && data.info[item.prefix]) {\n            item.info = data.info[item.prefix];\n        }\n        // Convert data\n        const convertedData = collection_1.rawDataToCollection(item);\n        if (!convertedData) {\n            return;\n        }\n        // Add data to result\n        if (result.providers[provider] === void 0) {\n            result.providers[provider] = {\n                total: 0,\n                data: Object.create(null),\n                collections: {},\n            };\n        }\n        const providerData = result.providers[provider];\n        if (providerData.data[convertedData.prefix] !== void 0) {\n            // Already exists\n            return;\n        }\n        // Add data\n        providerData.data[convertedData.prefix] = convertedData;\n        providerData.total++;\n        // Store raw info block to convert to collections list later, overwrite count\n        if (rawInfo[provider] === void 0) {\n            rawInfo[provider] = Object.create(null);\n        }\n        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion */\n        const rawItemInfo = Object.assign({}, item.info);\n        rawItemInfo.total = convertedData.total;\n        rawInfo[provider][convertedData.prefix] = rawItemInfo;\n        // Add icons to Iconify\n        if (importIcons && iconify_1.Iconify.addCollection) {\n            iconify_1.Iconify.addCollection(item);\n        }\n    });\n    // Parse collections lists\n    Object.keys(rawInfo).forEach((provider) => {\n        result.providers[provider].collections = collections_1.dataToCollections(rawInfo[provider]);\n    });\n    return result;\n}\nexports.convertCustomSets = convertCustomSets;\n/**\n * Merge icon sets from API and custom icon sets\n */\nfunction mergeCollections(provider, defaultSets, customSets) {\n    // Get list of parsed data\n    const parsedData = [];\n    if (defaultSets) {\n        parsedData.push({\n            isCustom: false,\n            categories: defaultSets,\n        });\n    }\n    if (customSets) {\n        const customCollections = customSets.providers[provider].collections;\n        // Unshift or push it, depending on merge order\n        parsedData[customSets.merge === 'custom-first' ? 'unshift' : 'push']({\n            isCustom: true,\n            categories: customCollections,\n        });\n    }\n    // Setup result as empty object\n    const results = Object.create(null);\n    // Store prefixes map to avoid duplicates\n    const usedPrefixes = Object.create(null);\n    // Parse all data\n    parsedData.forEach((item) => {\n        // Parse all categories\n        const collectionsList = item.categories;\n        Object.keys(collectionsList).forEach((category) => {\n            const categoryItems = collectionsList[category];\n            Object.keys(categoryItems).forEach((prefix) => {\n                if (usedPrefixes[prefix] !== void 0) {\n                    // Prefix has already been parsed\n                    if (item.isCustom) {\n                        // Remove previous entry\n                        delete results[usedPrefixes[prefix]][prefix];\n                    }\n                    else {\n                        // Do not overwrite: always show set from API in case of duplicate entries\n                        return;\n                    }\n                }\n                // Add item\n                usedPrefixes[prefix] = category;\n                if (results[category] === void 0) {\n                    results[category] = Object.create(null);\n                }\n                results[category][prefix] = categoryItems[prefix];\n            });\n        });\n    });\n    return results;\n}\nexports.mergeCollections = mergeCollections;\n//# sourceMappingURL=custom-sets.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.listProviders = exports.addProvider = exports.getProvider = exports.convertProviderData = exports.internalSourceCache = void 0;\nconst iconify_1 = require(\"../iconify\");\nconst icon_1 = require(\"@iconify/utils/lib/icon\");\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function\nfunction assertNever(s) { }\n/**\n * Default values\n */\nconst defaultAPIDataLinks = {\n    home: '',\n    collection: '',\n    icon: '',\n};\nconst defaultAPIDataNPM = {\n    package: '',\n    icon: '',\n};\nconst defaultAPIData = {\n    // These variables will be automatically set if empty\n    provider: '',\n    title: '',\n    api: '',\n    // Optional\n    links: defaultAPIDataLinks,\n    npm: defaultAPIDataNPM,\n    svg: '',\n};\n/**\n * Local cache\n */\n// Exported to allow quick manipulation of links. Not meant to be used in any other way\nexports.internalSourceCache = Object.create(null);\nconst configuredCache = Object.create(null);\n// Add default provider\nconst iconifyRoot = 'https://icon-sets.iconify.design/';\nconst iconifyPackage = '@iconify/icons-{prefix}';\nexports.internalSourceCache[''] = {\n    config: {},\n    title: 'Iconify',\n    links: {\n        home: iconifyRoot,\n        collection: iconifyRoot + '{prefix}/',\n        icon: iconifyRoot + '{prefix}/{name}/',\n    },\n    npm: {\n        package: iconifyPackage,\n        icon: iconifyPackage + '/{name}',\n    },\n    svg: 'https://api.iconify.design/{prefix}/{name}.svg',\n};\n/**\n * Defaults\n */\nconst defaults = {\n    title: '',\n    links: defaultAPIDataLinks,\n    npm: defaultAPIDataNPM,\n    svg: '',\n};\n/**\n * Convert data returned from API\n */\nfunction convertProviderData(host, raw) {\n    const provider = raw.provider;\n    if (typeof provider !== 'string' ||\n        // Allow empty string\n        (provider !== '' && !provider.match(icon_1.matchName))) {\n        return null;\n    }\n    // Clean up raw data\n    const data = {};\n    for (const key in defaultAPIData) {\n        const attr = key;\n        switch (attr) {\n            case 'title':\n                data.title =\n                    typeof raw.title === 'string' ? raw.title : provider;\n                break;\n            case 'provider':\n                data.provider = provider;\n                break;\n            case 'api':\n                if (typeof raw.api === 'string' && raw.api !== '') {\n                    data.api = [raw.api];\n                }\n                else if (raw.api instanceof Array) {\n                    data.api = raw.api;\n                }\n                else if (host === '') {\n                    // Missing host\n                    return null;\n                }\n                else {\n                    data.api = [host];\n                }\n                break;\n            case 'npm':\n            case 'links': {\n                const defaultValue = defaultAPIData[attr];\n                let resultValue;\n                if (typeof raw[attr] !== 'object' || !raw[attr]) {\n                    // Copy default value\n                    resultValue = defaultValue;\n                }\n                else {\n                    const rawValue = raw[attr];\n                    // Merge values\n                    resultValue = {};\n                    for (const nestedKey in defaultValue) {\n                        const nestedAttr = nestedKey;\n                        if (typeof rawValue[nestedAttr] === 'string') {\n                            resultValue[nestedAttr] = rawValue[nestedAttr];\n                        }\n                        else {\n                            resultValue[nestedAttr] = defaultValue[nestedAttr];\n                        }\n                    }\n                }\n                data[attr] = resultValue;\n                break;\n            }\n            case 'svg':\n                data[attr] =\n                    typeof raw[attr] === 'string'\n                        ? raw[attr]\n                        : defaultAPIData[attr];\n                break;\n            default:\n                assertNever(attr);\n        }\n    }\n    const fullData = data;\n    // Create API config\n    const config = {\n        resources: fullData.api,\n    };\n    // Create data\n    const result = {\n        config,\n        title: fullData.title,\n        links: fullData.links,\n        npm: fullData.npm,\n        svg: '',\n    };\n    return result;\n}\nexports.convertProviderData = convertProviderData;\n/**\n * Get API provider\n */\nfunction getProvider(provider) {\n    if (configuredCache[provider] === void 0) {\n        if (exports.internalSourceCache[provider] === void 0) {\n            // Missing provider\n            return null;\n        }\n        const source = exports.internalSourceCache[provider];\n        // Get Redundancy instance from Iconify\n        const data = iconify_1.Iconify.getAPI ? iconify_1.Iconify.getAPI(provider) : void 0;\n        if (data === void 0) {\n            // Failed again - something is wrong with config\n            configuredCache[provider] = null;\n        }\n        else {\n            configuredCache[provider] = {\n                config: data.config,\n                redundancy: data.redundancy,\n            };\n            // Add missing fields\n            const cache = configuredCache[provider];\n            const src = source;\n            for (const key in defaults) {\n                if (src[key] !== void 0) {\n                    cache[key] = src[key];\n                }\n                else {\n                    cache[key] = defaults[key];\n                }\n            }\n        }\n    }\n    return configuredCache[provider];\n}\nexports.getProvider = getProvider;\n/**\n * Add provider\n */\nfunction addProvider(provider, config) {\n    if (!iconify_1.Iconify.addAPIProvider || exports.internalSourceCache[provider] !== void 0) {\n        // addAPIProvider is not set or cannot overwrite provider\n        return;\n    }\n    if (config.title === void 0) {\n        // Use provider as name\n        config.title = provider;\n    }\n    exports.internalSourceCache[provider] = config;\n    iconify_1.Iconify.addAPIProvider(provider, config.config);\n}\nexports.addProvider = addProvider;\n/**\n * Get all providers\n */\nfunction listProviders() {\n    return Object.keys(exports.internalSourceCache).sort();\n}\nexports.listProviders = listProviders;\n//# sourceMappingURL=providers.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Events = void 0;\n/**\n * Events class\n */\nclass Events {\n    constructor() {\n        this._subscribers = Object.create(null);\n    }\n    /**\n     * Subscribe to event\n     *\n     * @param event Event name\n     * @param callback Callback function\n     * @param key Optional unique key for unsubscribe. If key is set, any other event listener with same key will be removed\n     */\n    subscribe(event, callback, key) {\n        if (this._subscribers[event] === void 0) {\n            // Create new array\n            this._subscribers[event] = [];\n        }\n        else if (typeof key === 'string') {\n            // Remove previous subscribers with same key\n            this._subscribers[event] = this._subscribers[event].filter((item) => item.key !== key);\n        }\n        // Add new subscriber\n        this._subscribers[event].push({\n            callback,\n            key,\n        });\n    }\n    /**\n     * Unsubscribe from event\n     *\n     * @param event Event name\n     * @param value Callback or key\n     */\n    unsubscribe(event, value) {\n        if (this._subscribers[event] === void 0) {\n            return;\n        }\n        let key;\n        switch (typeof value) {\n            case 'function':\n                key = 'callback';\n                break;\n            case 'string':\n                key = 'key';\n                break;\n            default:\n                return;\n        }\n        this._subscribers[event] = this._subscribers[event].filter((item) => item[key] !== value);\n    }\n    /**\n     * Check if event has listeners\n     *\n     * @param event Event name\n     */\n    hasListeners(event) {\n        return (this._subscribers[event] !== void 0 &&\n            this._subscribers[event].length > 0);\n    }\n    /**\n     * Fire event\n     *\n     * @param event Event name\n     * @param data Payload\n     * @param delay True if event should fire on next tick\n     */\n    fire(event, data, delay = false) {\n        if (!this.hasListeners(event)) {\n            return;\n        }\n        if (delay) {\n            setTimeout(() => {\n                this._fire(event, data);\n            });\n        }\n        else {\n            this._fire(event, data);\n        }\n    }\n    /**\n     * Fire event\n     *\n     * @param event\n     * @param data\n     */\n    _fire(event, data) {\n        this._subscribers[event].forEach((item) => {\n            item.callback(data, event);\n        });\n    }\n}\nexports.Events = Events;\n//# sourceMappingURL=events.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setIconify = exports.Iconify = void 0;\nexports.Iconify = {};\n/**\n * Set Iconify functions\n *\n * Use this to set Iconify module before doing anything\n */\nfunction setIconify(functions) {\n    // Merge all functions\n    [functions, functions._api].forEach((items) => {\n        if (typeof items === 'object') {\n            for (const key in items) {\n                const value = items[key];\n                if (typeof value === 'function') {\n                    exports.Iconify[key] = value;\n                }\n            }\n        }\n    });\n}\nexports.setIconify = setIconify;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCoreInstance = exports.IconFinderCore = exports.cloneObject = exports.compareObjects = exports.stringToIcon = exports.compareIcons = exports.validateIcon = exports.iconToString = exports.setComponentsConfig = exports.mergeConfig = exports.customisedConfig = exports.getCollectionTitle = exports.getCollectionInfo = exports.objectToRoute = exports.listProviders = exports.convertProviderData = exports.getProvider = exports.addProvider = exports.setIconify = exports.maxPage = exports.showPagination = exports.iterateCollectionsBlock = exports.getCollectionsBlockPrefixes = exports.getCollectionsBlockCategories = exports.isBlockEmpty = void 0;\nconst registry_1 = require(\"./registry\");\nconst storage_1 = require(\"./registry/storage\");\nconst custom_sets_1 = require(\"./data/custom-sets\");\nconst collections_1 = require(\"./data/collections\");\nObject.defineProperty(exports, \"getCollectionInfo\", { enumerable: true, get: function () { return collections_1.getCollectionInfo; } });\n/**\n * Export data for various blocks\n */\nvar types_1 = require(\"./blocks/types\");\nObject.defineProperty(exports, \"isBlockEmpty\", { enumerable: true, get: function () { return types_1.isBlockEmpty; } });\nvar collections_list_1 = require(\"./blocks/collections-list\");\nObject.defineProperty(exports, \"getCollectionsBlockCategories\", { enumerable: true, get: function () { return collections_list_1.getCollectionsBlockCategories; } });\nObject.defineProperty(exports, \"getCollectionsBlockPrefixes\", { enumerable: true, get: function () { return collections_list_1.getCollectionsBlockPrefixes; } });\nObject.defineProperty(exports, \"iterateCollectionsBlock\", { enumerable: true, get: function () { return collections_list_1.iterateCollectionsBlock; } });\nvar pagination_1 = require(\"./blocks/pagination\");\nObject.defineProperty(exports, \"showPagination\", { enumerable: true, get: function () { return pagination_1.showPagination; } });\nObject.defineProperty(exports, \"maxPage\", { enumerable: true, get: function () { return pagination_1.maxPage; } });\n/**\n * Export various types and functions that do not depend on core instance\n */\n// Iconify wrapper\nvar iconify_1 = require(\"./iconify\");\nObject.defineProperty(exports, \"setIconify\", { enumerable: true, get: function () { return iconify_1.setIconify; } });\nvar providers_1 = require(\"./data/providers\");\nObject.defineProperty(exports, \"addProvider\", { enumerable: true, get: function () { return providers_1.addProvider; } });\nObject.defineProperty(exports, \"getProvider\", { enumerable: true, get: function () { return providers_1.getProvider; } });\nObject.defineProperty(exports, \"convertProviderData\", { enumerable: true, get: function () { return providers_1.convertProviderData; } });\nObject.defineProperty(exports, \"listProviders\", { enumerable: true, get: function () { return providers_1.listProviders; } });\nvar convert_1 = require(\"./route/convert\");\nObject.defineProperty(exports, \"objectToRoute\", { enumerable: true, get: function () { return convert_1.objectToRoute; } });\nvar collections_2 = require(\"./data/collections\");\nObject.defineProperty(exports, \"getCollectionTitle\", { enumerable: true, get: function () { return collections_2.getCollectionTitle; } });\nvar config_1 = require(\"./data/config\");\nObject.defineProperty(exports, \"customisedConfig\", { enumerable: true, get: function () { return config_1.customisedConfig; } });\nObject.defineProperty(exports, \"mergeConfig\", { enumerable: true, get: function () { return config_1.mergeConfig; } });\nObject.defineProperty(exports, \"setComponentsConfig\", { enumerable: true, get: function () { return config_1.setComponentsConfig; } });\nvar icon_1 = require(\"./misc/icon\");\nObject.defineProperty(exports, \"iconToString\", { enumerable: true, get: function () { return icon_1.iconToString; } });\nObject.defineProperty(exports, \"validateIcon\", { enumerable: true, get: function () { return icon_1.validateIcon; } });\nObject.defineProperty(exports, \"compareIcons\", { enumerable: true, get: function () { return icon_1.compareIcons; } });\nObject.defineProperty(exports, \"stringToIcon\", { enumerable: true, get: function () { return icon_1.stringToIcon; } });\n// Objects\nvar objects_1 = require(\"./misc/objects\");\nObject.defineProperty(exports, \"compareObjects\", { enumerable: true, get: function () { return objects_1.compareObjects; } });\nObject.defineProperty(exports, \"cloneObject\", { enumerable: true, get: function () { return objects_1.cloneObject; } });\n/**\n * Icon Finder Core class\n */\nclass IconFinderCore {\n    constructor(params) {\n        this.params = params;\n        // Get Registry instance\n        const registry = (this.registry = new registry_1.Registry(params));\n        this.id = registry.id;\n        registry.setCustom('core', this, true);\n        // Set custom icon sets\n        if (params.iconSets) {\n            registry.customIconSets = custom_sets_1.convertCustomSets(params.iconSets);\n            // console.log('Custom sets:', registry.customIconSets);\n        }\n        // Get other required classes from Registry\n        const router = (this.router = registry.router);\n        const events = registry.events;\n        // Subscribe to events\n        events.subscribe('render', this._routerEvent.bind(this));\n        if (typeof params.custom === 'object' && params.custom !== null) {\n            Object.keys(params.custom).forEach((customType) => {\n                events.subscribe('load-' + customType, this._loadCustomIconsEvent.bind(this, customType));\n            });\n        }\n        // Change route on next tick, so callback would be called asynchronously\n        setTimeout(() => {\n            if (router.fullRoute === null) {\n                if (params.route !== void 0) {\n                    // Set route. On null or failure router will call home()\n                    router.partialRoute = params.route;\n                }\n                else {\n                    router.home();\n                }\n            }\n        });\n    }\n    /**\n     * Get collection information\n     */\n    getCollection(provider, prefix) {\n        return collections_1.getCollectionInfo(this.registry.collections, provider, prefix);\n    }\n    /**\n     * Event was fired by router\n     */\n    _routerEvent(data) {\n        this.params.callback(data, this);\n    }\n    /**\n     * Load data\n     */\n    _loadCustomIconsEvent(customType, callback) {\n        if (this.params.custom === void 0) {\n            return;\n        }\n        this.params.custom[customType](callback);\n    }\n    /**\n     * Destroy instance\n     */\n    destroy() {\n        this.registry.destroy();\n    }\n}\nexports.IconFinderCore = IconFinderCore;\n/**\n * Find Icon Finder Core instance for id\n */\nfunction getCoreInstance(id) {\n    const registry = storage_1.getRegistry(id);\n    return registry\n        ? registry.getCustom('core', true)\n        : void 0;\n}\nexports.getCoreInstance = getCoreInstance;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.capitalize = void 0;\n// Split numbers\nconst unitsSplit = /([0-9]+[0-9.]*)/g;\n/**\n * Capitalize string: split by dash and numbers\n */\nfunction capitalize(str, split = '-') {\n    return str\n        .split(split)\n        .map((item) => {\n        return item\n            .split(unitsSplit)\n            .filter((item) => item.length > 0)\n            .map((item) => item.slice(0, 1).toUpperCase() + item.slice(1))\n            .join(' ');\n    })\n        .join(' ');\n}\nexports.capitalize = capitalize;\n//# sourceMappingURL=capitalize.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendedColorKeywords = exports.baseColorKeywords = void 0;\n/**\n * List of base colors. From https://www.w3.org/TR/css3-color/\n */\nexports.baseColorKeywords = {\n    silver: [192, 192, 192],\n    gray: [128, 128, 128],\n    white: [255, 255, 255],\n    maroon: [128, 0, 0],\n    red: [255, 0, 0],\n    purple: [128, 0, 128],\n    fuchsia: [255, 0, 255],\n    green: [0, 128, 0],\n    lime: [0, 255, 0],\n    olive: [128, 128, 0],\n    yellow: [255, 255, 0],\n    navy: [0, 0, 128],\n    blue: [0, 0, 255],\n    teal: [0, 128, 128],\n    aqua: [0, 255, 255],\n};\n/**\n * List of extended colors. From https://www.w3.org/TR/css3-color/\n */\nexports.extendedColorKeywords = {\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    grey: [128, 128, 128],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50],\n    // Color module level 4\n    rebeccapurple: [102, 51, 153],\n};\n//# sourceMappingURL=color-keywords.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.colorToString = exports.stringToColor = void 0;\nconst color_keywords_1 = require(\"./color-keywords\");\n/**\n * Attempt to convert color to keyword.\n *\n * Assumes that check for alpha === 1 has been completed\n */\nfunction colorToKeyword(color) {\n    // Test all keyword lists\n    const lists = [color_keywords_1.baseColorKeywords, color_keywords_1.extendedColorKeywords];\n    for (let i = 0; i < lists.length; i++) {\n        const list = lists[i];\n        const keys = Object.keys(list);\n        let key;\n        while ((key = keys.shift()) !== void 0) {\n            const rgb = list[key];\n            if (rgb[0] === color.r &&\n                rgb[1] === color.g &&\n                rgb[2] === color.b) {\n                return key;\n            }\n        }\n    }\n    return null;\n}\n/**\n * Convert array to object\n */\nfunction valueToKeyword(value) {\n    return {\n        r: value[0],\n        g: value[1],\n        b: value[2],\n        a: 1,\n    };\n}\n/**\n * Convert hex color to object\n */\nfunction hexToColor(value) {\n    if (value.slice(0, 1) === '#') {\n        value = value.slice(1);\n    }\n    if (!/^[\\da-f]+$/i.test(value)) {\n        return null;\n    }\n    let alphaStr = '';\n    let redStr, greenStr, blueStr;\n    let start = 0;\n    switch (value.length) {\n        case 4:\n            alphaStr = value.slice(-1);\n            alphaStr += alphaStr;\n        // eslint-disable-next-line no-fallthrough\n        case 3:\n            redStr = value.slice(start, ++start);\n            redStr += redStr;\n            greenStr = value.slice(start, ++start);\n            greenStr += greenStr;\n            blueStr = value.slice(start, ++start);\n            blueStr += blueStr;\n            break;\n        case 8:\n            alphaStr = value.slice(-2);\n        // eslint-disable-next-line no-fallthrough\n        case 6:\n            redStr = value.slice(start++, ++start);\n            greenStr = value.slice(start++, ++start);\n            blueStr = value.slice(start++, ++start);\n            break;\n        default:\n            return null;\n    }\n    return {\n        r: parseInt(redStr, 16),\n        g: parseInt(greenStr, 16),\n        b: parseInt(blueStr, 16),\n        a: alphaStr === '' ? 1 : parseInt(alphaStr, 16) / 255,\n    };\n}\n/**\n * Convert string to color\n */\nfunction stringToColor(value) {\n    value = value.toLowerCase();\n    // Test keywords\n    if (color_keywords_1.baseColorKeywords[value] !== void 0) {\n        return valueToKeyword(color_keywords_1.baseColorKeywords[value]);\n    }\n    if (color_keywords_1.extendedColorKeywords[value] !== void 0) {\n        return valueToKeyword(color_keywords_1.extendedColorKeywords[value]);\n    }\n    // Test for function\n    if (value.indexOf('(') === -1) {\n        // Not a function: test hex string\n        return hexToColor(value);\n    }\n    // Remove whitespace\n    value = value.replace(/\\s+/g, '');\n    if (value.slice(-1) !== ')') {\n        return null;\n    }\n    // Remove ')' at the end\n    value = value.slice(0, value.length - 1);\n    // Split by '('\n    const parts = value.split('(');\n    if (parts.length !== 2 || /[^\\d.,%-]/.test(parts[1])) {\n        return null;\n    }\n    const keyword = parts[0];\n    const colors = parts[1].split(',');\n    if (colors.length !== 3 && colors.length !== 4) {\n        return null;\n    }\n    let alpha = 1;\n    // Get alpha\n    if (colors.length === 4) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lastItem = colors.pop();\n        alpha = parseFloat(lastItem) * (lastItem.slice(-1) === '%' ? 0.01 : 1);\n        if (isNaN(alpha)) {\n            return null;\n        }\n        alpha = alpha < 0 ? 0 : alpha > 1 ? 1 : alpha;\n    }\n    // Parse\n    let color1; // red or hue\n    let color2; // green or saturation\n    let color3; // blue or lightness\n    let isPercentages;\n    let multiplier;\n    switch (keyword) {\n        case 'rgb':\n        case 'rgba':\n            // Either all or no components can be percentages\n            isPercentages = colors[0].slice(-1) === '%';\n            if ((colors[1].slice(-1) === '%') !== isPercentages ||\n                (colors[2].slice(-1) === '%') !== isPercentages) {\n                return null;\n            }\n            // Convert to numbers and normalize colors\n            multiplier = isPercentages ? 2.55 : 1;\n            color1 = parseFloat(colors[0]) * multiplier;\n            color2 = parseFloat(colors[1]) * multiplier;\n            color3 = parseFloat(colors[2]) * multiplier;\n            return {\n                r: isNaN(color1) || color1 < 0\n                    ? 0\n                    : color1 > 255\n                        ? 255\n                        : color1,\n                g: isNaN(color2) || color2 < 0\n                    ? 0\n                    : color2 > 255\n                        ? 255\n                        : color2,\n                b: isNaN(color3) || color3 < 0\n                    ? 0\n                    : color3 > 255\n                        ? 255\n                        : color3,\n                a: alpha,\n            };\n        case 'hsl':\n        case 'hsla':\n            if (colors[0].indexOf('%') !== -1 ||\n                colors[1].slice(-1) !== '%' ||\n                colors[2].slice(-1) !== '%') {\n                // Hue cannot be percentage, saturation and lightness must be percentage\n                return null;\n            }\n            // Convert to numbers and normalize colors\n            color1 = parseFloat(colors[0]);\n            color2 = parseFloat(colors[1]);\n            color3 = parseFloat(colors[2]);\n            return {\n                h: isNaN(color1)\n                    ? 0\n                    : color1 < 0\n                        ? (color1 % 360) + 360\n                        : color1 >= 360\n                            ? color1 % 360\n                            : color1,\n                s: isNaN(color2) || color2 < 0\n                    ? 0\n                    : color2 > 100\n                        ? 100\n                        : color2,\n                l: isNaN(color3) || color3 < 0\n                    ? 0\n                    : color3 > 100\n                        ? 100\n                        : color3,\n                a: alpha,\n            };\n    }\n    return null;\n}\nexports.stringToColor = stringToColor;\n/**\n * Convert HSL to RGB\n */\nfunction hslToRGB(value, round = false) {\n    function valore(n1, n2, hue) {\n        hue = hue < 0 ? (hue % 360) + 360 : hue >= 360 ? hue % 360 : hue;\n        if (hue >= 240) {\n            return n1;\n        }\n        if (hue < 60) {\n            return n1 + ((n2 - n1) * hue) / 60;\n        }\n        if (hue < 180) {\n            return n2;\n        }\n        return n1 + ((n2 - n1) * (240 - hue)) / 60;\n    }\n    const hue = value.h < 0\n        ? (value.h % 360) + 360\n        : value.h >= 360\n            ? value.h % 360\n            : value.h;\n    const sat = value.s < 0 ? 0 : value.s > 100 ? 1 : value.s / 100;\n    const lum = value.l < 0 ? 0 : value.l > 100 ? 1 : value.l / 100;\n    let m2;\n    if (lum <= 0.5) {\n        m2 = lum * (1 + sat);\n    }\n    else {\n        m2 = lum + sat * (1 - lum);\n    }\n    const m1 = 2 * lum - m2;\n    let c1, c2, c3;\n    if (sat === 0 && hue === 0) {\n        c1 = lum;\n        c2 = lum;\n        c3 = lum;\n    }\n    else {\n        c1 = valore(m1, m2, hue + 120);\n        c2 = valore(m1, m2, hue);\n        c3 = valore(m1, m2, hue - 120);\n    }\n    return {\n        r: round ? Math.round(c1 * 255) : c1 * 255,\n        g: round ? Math.round(c2 * 255) : c2 * 255,\n        b: round ? Math.round(c3 * 255) : c3 * 255,\n        a: value.a,\n    };\n}\n/**\n * Convert color to string\n */\nfunction colorToString(color) {\n    // Attempt to convert to RGB\n    let rgbColor;\n    try {\n        rgbColor =\n            color.r !== void 0\n                ? color\n                : hslToRGB(color);\n    }\n    catch (err) {\n        return '';\n    }\n    // Check precision\n    const rgbRounded = rgbColor.r === Math.round(rgbColor.r) &&\n        rgbColor.g === Math.round(rgbColor.g) &&\n        rgbColor.b === Math.round(rgbColor.b);\n    // Check for keyword and hexadecimal color\n    if (rgbRounded && color.a === 1) {\n        // Keyword?\n        const keyword = colorToKeyword(rgbColor);\n        if (typeof keyword === 'string') {\n            return keyword;\n        }\n        // Hex color\n        let result = '';\n        let canShorten = true;\n        try {\n            ['r', 'g', 'b'].forEach((attr) => {\n                const value = rgbColor[attr];\n                if (value < 0 || value > 255) {\n                    throw new Error('Invalid color');\n                }\n                const str = (value < 16 ? '0' : '') + value.toString(16);\n                result += str;\n                canShorten = canShorten && str[0] === str[1];\n            });\n        }\n        catch (err) {\n            return '';\n        }\n        return '#' + (canShorten ? result[0] + result[2] + result[4] : result);\n    }\n    // RGB(A) or HSL(A)\n    if (!rgbRounded && color.h !== void 0) {\n        // HSL(A)\n        const hslColor = color;\n        const list = [];\n        try {\n            // Hue\n            let hue = hslColor.h % 360;\n            while (hue < 0) {\n                hue += 360;\n            }\n            list.push(hue + '');\n            // Saturation, lightness\n            ['s', 'l'].forEach((attr) => {\n                const value = hslColor[attr];\n                if (value < 0 || value > 100) {\n                    throw new Error('Invalid color');\n                }\n                list.push(value + '%');\n            });\n        }\n        catch (err) {\n            return '';\n        }\n        if (hslColor.a !== 1) {\n            list.push(hslColor.a + '');\n        }\n        return (hslColor.a === 1 ? 'hsl(' : 'hsla(') + list.join(', ') + ')';\n    }\n    // RGB(A)\n    const list = [];\n    try {\n        ['r', 'g', 'b'].forEach((attr) => {\n            const value = rgbColor[attr];\n            if (value < 0 || value > 255) {\n                throw new Error('Invalid color');\n            }\n            list.push(value + '');\n        });\n    }\n    catch (err) {\n        return '';\n    }\n    if (rgbColor.a !== 1) {\n        list.push(rgbColor.a + '');\n    }\n    return (rgbColor.a === 1 ? 'rgb(' : 'rgba(') + list.join(', ') + ')';\n}\nexports.colorToString = colorToString;\n//# sourceMappingURL=colors.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.filterCustomisations = exports.mergeCustomisations = exports.defaultCustomisations = exports.emptyCustomisations = void 0;\nconst customisations_1 = require(\"@iconify/utils/lib/customisations\");\n/**\n * Custom values\n */\nconst emptyCustomValues = {\n    color: '',\n};\n/**\n * Empty values\n */\nexports.emptyCustomisations = {\n    ...customisations_1.defaults,\n    ...emptyCustomValues,\n};\n/**\n * Default values\n */\nexports.defaultCustomisations = {\n    ...exports.emptyCustomisations,\n};\n/**\n * Add missing values to customisations, creating new object. Function does type checking\n */\nfunction mergeCustomisations(defaults, values) {\n    // Merge default properties\n    const result = customisations_1.mergeCustomisations(defaults, values);\n    // Merge custom properties\n    for (const key in emptyCustomValues) {\n        const attr = key;\n        // Match type\n        result[attr] =\n            values && typeof values[attr] === typeof defaults[attr]\n                ? values[attr]\n                : defaults[attr];\n    }\n    return result;\n}\nexports.mergeCustomisations = mergeCustomisations;\n/**\n * Export only customised attributes\n */\nfunction filterCustomisations(values) {\n    // Function can handle any properties, just needs some type hinting\n    const result = {};\n    for (const key in exports.defaultCustomisations) {\n        const attr = key;\n        if (values[attr] !== exports.defaultCustomisations[attr] &&\n            values[attr] !== exports.emptyCustomisations[attr]) {\n            result[attr] = values[attr];\n        }\n    }\n    return result;\n}\nexports.filterCustomisations = filterCustomisations;\n//# sourceMappingURL=customisations.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.iconToString = exports.compareIcons = exports.validateIcon = exports.stringToIcon = exports.match = void 0;\nconst name_1 = require(\"@iconify/utils/lib/icon/name\");\nObject.defineProperty(exports, \"validateIcon\", { enumerable: true, get: function () { return name_1.validateIcon; } });\n/**\n * Expression to test part of icon name.\n */\nexports.match = /^[a-z0-9]+(-[a-z0-9]+)*$/;\n/**\n * Convert string to Icon object.\n */\nconst stringToIcon = (value, validate = false, provider = '') => {\n    return name_1.stringToIcon(value, validate, false, provider);\n};\nexports.stringToIcon = stringToIcon;\n/**\n * Compare Icon objects.\n *\n * Note: null means icon is invalid, so null to null comparison = false.\n */\nconst compareIcons = (icon1, icon2) => {\n    return (icon1 !== null &&\n        icon2 !== null &&\n        icon1.provider === icon2.provider &&\n        icon1.name === icon2.name &&\n        icon1.prefix === icon2.prefix);\n};\nexports.compareIcons = compareIcons;\n/**\n * Convert icon to string.\n */\nconst iconToString = (icon) => {\n    return ((icon.provider === '' ? '' : '@' + icon.provider + ':') +\n        icon.prefix +\n        ':' +\n        icon.name);\n};\nexports.iconToString = iconToString;\n//# sourceMappingURL=icon.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.match = exports.compareObjects = exports.cloneObject = void 0;\n/**\n * Deep clone simple object.\n *\n * This function does not handle anything other than primitive types + Arrays.\n * This function is on average 10 times faster than JSON.parse(JSON.stringify(obj)) on small objects, several times faster on big objects\n */\nfunction cloneObject(obj) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n    if (obj instanceof Array) {\n        return obj.map((item) => {\n            if (typeof item === 'object') {\n                return cloneObject(item);\n            }\n            else {\n                return item;\n            }\n        });\n    }\n    const result = {};\n    let key;\n    for (key in obj) {\n        if (typeof obj[key] !== 'object') {\n            result[key] = obj[key];\n        }\n        else {\n            result[key] = cloneObject(obj[key]);\n        }\n    }\n    return result;\n}\nexports.cloneObject = cloneObject;\n/**\n * Compare two objects.\n *\n * This function does not handle anything other than primitive types + Arrays.\n */\nfunction compareObjects(obj1, obj2) {\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {\n        return obj1 === obj2;\n    }\n    if (obj1 === obj2) {\n        // Same object or both are null\n        return true;\n    }\n    if (obj1 === null || obj2 === null) {\n        // One of objects is null\n        return false;\n    }\n    // Check for arrays\n    if (obj1 instanceof Array) {\n        if (!(obj2 instanceof Array)) {\n            return false;\n        }\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (let i = 0; i < obj1.length; i++) {\n            const value1 = obj1[i];\n            const value2 = obj2[i];\n            if (value1 !== value2) {\n                // Different values. If both are objects, do deep comparison, otherwise return false\n                if (typeof value1 !== 'object' ||\n                    typeof value2 !== 'object' ||\n                    !compareObjects(value1, value2)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    else if (obj2 instanceof Array) {\n        return false;\n    }\n    // Not array\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let i = 0; i < keys1.length; i++) {\n        const key = keys1[i];\n        if (typeof obj1[key] !==\n            typeof obj2[key]) {\n            return false;\n        }\n        if (typeof obj1[key] === 'object') {\n            if (!compareObjects(obj1[key], obj2[key])) {\n                return false;\n            }\n        }\n        else if (obj1[key] !==\n            obj2[key]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.compareObjects = compareObjects;\n/**\n * Find match of keyword in data.\n *\n * Comparison is case insensitive.\n */\nfunction match(data, keyword) {\n    if (typeof data === 'number') {\n        data = '' + data;\n    }\n    if (typeof data === 'string') {\n        return data.toLowerCase().indexOf(keyword) !== -1;\n    }\n    if (typeof data !== 'object' || data === null) {\n        return false;\n    }\n    if (data instanceof Array) {\n        for (let i = 0; i < data.length; i++) {\n            if (match(data[i], keyword)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    for (const key in data) {\n        if (match(data[key], keyword)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.match = match;\n//# sourceMappingURL=objects.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Registry = void 0;\nconst config_1 = require(\"../data/config\");\nconst events_1 = require(\"../events\");\nconst fetch_1 = require(\"../api/fetch\");\nconst router_1 = require(\"../route/router\");\nconst storage_1 = require(\"./storage\");\nconst custom_sets_1 = require(\"../data/custom-sets\");\n/**\n * Registry class\n */\nclass Registry {\n    constructor(params) {\n        this._data = Object.create(null);\n        const namespace = typeof params === 'string'\n            ? params\n            : typeof params === 'object' &&\n                typeof params.namespace === 'string'\n                ? params.namespace\n                : 'iconify';\n        this.namespace = namespace;\n        // Get unique id based on namespace\n        this.id = storage_1.uniqueId(namespace);\n        // Add namespace\n        this.initialised = storage_1.addRegistry(this);\n        // Copy shared data\n        this._sharedData = storage_1.getSharedData(namespace);\n        // Params\n        this.params = typeof params === 'object' ? params : {};\n        // Add instance\n        this._save();\n    }\n    /**\n     * Save instance in registry list\n     */\n    _save() {\n        storage_1.saveRegistry(this);\n    }\n    /**\n     * Get/set config\n     */\n    get config() {\n        if (this._sharedData.config === void 0) {\n            this._sharedData.config = config_1.createConfig(this.params.config);\n        }\n        return this._sharedData.config;\n    }\n    set config(value) {\n        this._sharedData.config = value;\n    }\n    /**\n     * Get/set events\n     */\n    get events() {\n        if (this._data.events === void 0) {\n            this._data.events = new events_1.Events();\n        }\n        return this._data.events;\n    }\n    set events(value) {\n        this._data.events = value;\n    }\n    /**\n     * Get/set API\n     */\n    get api() {\n        if (this._sharedData.api === void 0) {\n            this._sharedData.api = new fetch_1.API(this);\n        }\n        return this._sharedData.api;\n    }\n    set api(value) {\n        this._sharedData.api = value;\n    }\n    /**\n     * Get/set custom icon sets\n     */\n    get customIconSets() {\n        if (this._data.customIconSets === void 0) {\n            this._data.customIconSets = custom_sets_1.emptyConvertedSet;\n        }\n        return this._data.customIconSets;\n    }\n    set customIconSets(value) {\n        this._data.customIconSets = value;\n    }\n    /**\n     * Get/set collections\n     */\n    get collections() {\n        if (this._sharedData.collections === void 0) {\n            this._sharedData.collections = Object.create(null);\n        }\n        return this._sharedData.collections;\n    }\n    set collections(value) {\n        this._sharedData.collections = value;\n    }\n    /**\n     * Set/set router\n     */\n    get router() {\n        if (this._data.router === void 0) {\n            this._data.router = new router_1.Router(this.id);\n        }\n        return this._data.router;\n    }\n    set router(value) {\n        this._data.router = value;\n    }\n    /**\n     * Set/set route\n     */\n    get fullRoute() {\n        return this.router.fullRoute;\n    }\n    set fullRoute(value) {\n        this.router.fullRoute = value;\n    }\n    get partialRoute() {\n        return this.router.partialRoute;\n    }\n    set partialRoute(value) {\n        this.router.partialRoute = value;\n    }\n    /**\n     * Get/set custom data\n     */\n    getCustom(key, local = true) {\n        const data = local ? this._data : this._sharedData;\n        if (data.custom === void 0) {\n            return void 0;\n        }\n        return data.custom[key];\n    }\n    setCustom(key, value, local = true) {\n        const data = local ? this._data : this._sharedData;\n        if (data.custom === void 0) {\n            data.custom = Object.create(null);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const custom = data.custom;\n        // Create getter and setter for local properties\n        if (local && custom[key] === void 0) {\n            Object.defineProperty(this, key, {\n                get() {\n                    return custom[key];\n                },\n                set(value) {\n                    custom[key] = value;\n                },\n            });\n        }\n        custom[key] = value;\n    }\n    /**\n     * Destroy instance\n     */\n    destroy() {\n        storage_1.destroyRegistry(this);\n    }\n}\nexports.Registry = Registry;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRegistry = exports.destroyRegistry = exports.getSharedData = exports.saveRegistry = exports.addRegistry = exports.uniqueId = void 0;\nconst namespaces = Object.create(null);\nconst registry = Object.create(null);\n/**\n * Get unique id\n */\nfunction uniqueId(namespace) {\n    let counter = 0, id;\n    while (registry[(id = namespace + counter)] !== void 0) {\n        counter++;\n    }\n    return id;\n}\nexports.uniqueId = uniqueId;\n/**\n * Add registry to storage\n */\nfunction addRegistry(registry) {\n    const namespace = registry.namespace, id = registry.id;\n    if (namespaces[namespace] === void 0) {\n        namespaces[namespace] = {\n            ids: [id],\n            data: Object.create(null),\n        };\n        return true;\n    }\n    namespaces[namespace].ids.push(id);\n    return false;\n}\nexports.addRegistry = addRegistry;\n/**\n * Save registry\n */\nfunction saveRegistry(item) {\n    registry[item.id] = item;\n}\nexports.saveRegistry = saveRegistry;\n/**\n * Get shared data\n */\nfunction getSharedData(namespace) {\n    return namespaces[namespace].data;\n}\nexports.getSharedData = getSharedData;\n/**\n * Delete registry entries\n */\nfunction destroyRegistry(item) {\n    if (registry[item.id] === void 0) {\n        return;\n    }\n    // Delete registry from index\n    delete registry[item.id];\n    // Remove id from shared namespaces\n    namespaces[item.namespace].ids = namespaces[item.namespace].ids.filter((id) => id !== item.id);\n}\nexports.destroyRegistry = destroyRegistry;\n/**\n * Get Registry instance for id.\n *\n * This is used to pass registry as constant string in React/Svelte, so changes in Registry instance won't trigger refresh of entire UI.\n */\nconst getRegistry = (id) => registry[id];\nexports.getRegistry = getRegistry;\n//# sourceMappingURL=storage.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objectToRoute = exports.objectToRouteParams = exports.routeToObject = exports.routeParamsToObject = void 0;\nconst defaults_1 = require(\"./defaults\");\n/**\n * TypeScript guard\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function\nfunction assertNever(s) { }\n/**\n * Get required and default values\n */\nfunction getValues(type) {\n    let defaults;\n    let required;\n    switch (type) {\n        case 'collections':\n            defaults = defaults_1.collectionsRouteDefaults;\n            required = defaults_1.collectionsRouteMinimum;\n            break;\n        case 'collection':\n            defaults = defaults_1.collectionRouteDefaults;\n            required = defaults_1.collectionRouteMinimum;\n            break;\n        case 'search':\n            defaults = defaults_1.searchRouteDefaults;\n            required = defaults_1.searchRouteMinimum;\n            break;\n        case 'custom':\n            defaults = defaults_1.customRouteDefaults;\n            required = defaults_1.customRouteMinimum;\n            break;\n        case 'empty':\n            defaults = defaults_1.emptyRouteDefaults;\n            required = defaults_1.emptyRouteMinimum;\n            break;\n        default:\n            assertNever(type);\n            throw new Error(`Unknown route type: ${type}`);\n    }\n    return {\n        defaults,\n        required,\n    };\n}\n/**\n * Remove default values from route\n */\nconst routeParamsToObject = (type, params) => {\n    const result = {};\n    const { defaults, required } = getValues(type);\n    for (const key in defaults) {\n        const value = params[key];\n        if (\n        // Save value if it is required\n        required[key] !== void 0 ||\n            // Save value if it is different\n            value !== defaults[key]) {\n            result[key] = value;\n        }\n    }\n    return result;\n};\nexports.routeParamsToObject = routeParamsToObject;\n/**\n * Convert route to object for export, ignoring default values\n */\nconst routeToObject = (route) => {\n    const result = {\n        type: route.type,\n    };\n    const params = exports.routeParamsToObject(route.type, route.params);\n    if (Object.keys(params).length > 0) {\n        result.params = params;\n    }\n    if (route.parent) {\n        const parent = exports.routeToObject(route.parent);\n        if (parent) {\n            result.parent = parent;\n        }\n    }\n    return result;\n};\nexports.routeToObject = routeToObject;\n/**\n * List of parameters to change to lower case\n */\nconst toLowerCaseStrings = ['filter', 'search', 'provider'];\n/**\n * Convert object to RouteParams\n */\nconst objectToRouteParams = (type, params) => {\n    const result = {};\n    const { defaults, required } = getValues(type);\n    // Check for required properties\n    for (const key in required) {\n        if (typeof params[key] !== typeof required[key] ||\n            params[key] === required[key]) {\n            // Cannot have different type or empty value\n            throw new Error(`Missing required route parameter \"${key}\" in objectToRouteParams()`);\n        }\n    }\n    // Copy all values\n    for (const key in defaults) {\n        const defaultValue = defaults[key];\n        if (params[key] === void 0) {\n            // Use default\n            result[key] = defaultValue;\n            continue;\n        }\n        let value = params[key];\n        const allowedType = defaultValue === null ? 'string' : typeof defaultValue;\n        if (typeof value === allowedType) {\n            // Matching type\n            if (allowedType === 'string' &&\n                toLowerCaseStrings.indexOf(key) !== -1) {\n                // Change to lower case\n                value = value.toLowerCase();\n            }\n            result[key] = value;\n            continue;\n        }\n        // Exception: null where default value is not null\n        if (value === null) {\n            if (key === 'page' && type === 'collection') {\n                result[key] = value;\n                continue;\n            }\n        }\n        // Invalid value\n        result[key] = defaultValue;\n    }\n    return result;\n};\nexports.objectToRouteParams = objectToRouteParams;\n/**\n * Convert object to Route, adding missing values\n */\nconst objectToRoute = (data, defaultRoute = null) => {\n    // Check for valid object\n    if (data === null ||\n        typeof data !== 'object' ||\n        typeof data.type !== 'string') {\n        return defaultRoute;\n    }\n    // Check if route is valid\n    const type = data.type;\n    switch (type) {\n        case 'collections':\n        case 'collection':\n        case 'custom':\n        case 'search':\n        case 'empty':\n            break;\n        default:\n            assertNever(type);\n            return defaultRoute;\n    }\n    // Get parameters\n    let params;\n    try {\n        params = exports.objectToRouteParams(type, typeof data.params === 'object'\n            ? data.params\n            : {});\n    }\n    catch (err) {\n        return defaultRoute;\n    }\n    // Get parent\n    let parent = null;\n    if (typeof data.parent === 'object' && data.parent !== null) {\n        parent = exports.objectToRoute(data.parent, null);\n        if (parent === null) {\n            // Error in child route\n            return defaultRoute;\n        }\n    }\n    // Return result\n    return {\n        type,\n        params,\n        parent,\n    };\n};\nexports.objectToRoute = objectToRoute;\n//# sourceMappingURL=convert.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.emptyRouteMinimum = exports.customRouteMinimum = exports.searchRouteMinimum = exports.collectionRouteMinimum = exports.collectionsRouteMinimum = exports.emptyRouteDefaults = exports.customRouteDefaults = exports.searchRouteDefaults = exports.collectionRouteDefaults = exports.collectionsRouteDefaults = void 0;\n/**\n * Default values for route parameters\n */\nexports.collectionsRouteDefaults = {\n    provider: '',\n    filter: '',\n    category: null,\n};\nexports.collectionRouteDefaults = {\n    provider: '',\n    prefix: '',\n    filter: '',\n    icon: '',\n    page: 0,\n    tag: null,\n    themePrefix: null,\n    themeSuffix: null,\n};\nexports.searchRouteDefaults = {\n    provider: '',\n    search: '',\n    short: true,\n    page: 0,\n};\nexports.customRouteDefaults = {\n    customType: '',\n    filter: '',\n    page: 0,\n};\nexports.emptyRouteDefaults = {};\n/**\n * Partial default values, used to validate parameters in partial routes\n */\nexports.collectionsRouteMinimum = {};\nexports.collectionRouteMinimum = {\n    prefix: '',\n};\nexports.searchRouteMinimum = {\n    search: '',\n};\nexports.customRouteMinimum = {\n    customType: '',\n};\nexports.emptyRouteMinimum = {};\n//# sourceMappingURL=defaults.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Router = void 0;\nconst storage_1 = require(\"../registry/storage\");\nconst convert_1 = require(\"./convert\");\nconst collections_1 = require(\"../views/collections\");\nconst collection_1 = require(\"../views/collection\");\nconst search_1 = require(\"../views/search\");\nconst custom_1 = require(\"../views/custom\");\nconst empty_1 = require(\"../views/empty\");\nconst providers_1 = require(\"../data/providers\");\n/**\n * TypeScript guard\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-empty-function\nfunction assertNever(s) { }\n/**\n * Change provider in home route\n */\nfunction changeProvider(route, provider) {\n    switch (route.type) {\n        case 'collections':\n        case 'collection':\n        case 'search':\n            if (route.params === void 0) {\n                route.params = {};\n            }\n            route.params.provider = provider;\n    }\n    if (route.parent) {\n        changeProvider(route.parent, provider);\n    }\n}\n/**\n * Router class\n */\nclass Router {\n    /**\n     * Constructor\n     *\n     * @param instance\n     * @param callback\n     */\n    constructor(instance) {\n        // Current view\n        this._view = null;\n        // Currently visible view, could be different than current view\n        this._visibleView = null;\n        // Timer for replacing view\n        this._timer = null;\n        // Default API provider\n        this.defaultProvider = '';\n        this._instance = instance;\n        const registry = storage_1.getRegistry(this._instance);\n        // Subscribe to view events, handle them in the same handler\n        const events = registry.events;\n        events.subscribe('view-loaded', (view) => {\n            this._viewEvent(view);\n        });\n        events.subscribe('view-updated', (view) => {\n            this._viewEvent(view);\n        });\n    }\n    /**\n     * Get current error message\n     */\n    error() {\n        return this._visibleView === null || this._visibleView.loading\n            ? 'loading'\n            : this._visibleView.error;\n    }\n    /**\n     * Render currently visible view\n     */\n    render() {\n        return this._visibleView === null ? null : this._visibleView.render();\n    }\n    /**\n     * Set or get current route\n     *\n     * Route cannot be set to null. Setting route to null will result in home route.\n     * Route could be null when reading it for the first time, so value null.\n     */\n    set partialRoute(route) {\n        this._setRoute(route ? convert_1.objectToRoute(route) : null);\n    }\n    get partialRoute() {\n        return this._visibleView\n            ? convert_1.routeToObject(this._visibleView.route)\n            : null;\n    }\n    set fullRoute(route) {\n        this._setRoute(route);\n    }\n    get fullRoute() {\n        return this._visibleView ? this._visibleView.route : null;\n    }\n    /**\n     * Navigate to home\n     */\n    home(provider = null) {\n        const registry = storage_1.getRegistry(this._instance);\n        const config = registry.config;\n        // Generate route\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const defaultRouteString = config.router.home;\n        let route = null;\n        if (defaultRouteString !== '') {\n            // Use configured route\n            route = convert_1.objectToRoute(JSON.parse(defaultRouteString));\n        }\n        else {\n            // Detect route. Check custom icon sets first\n            const customIconSets = registry.customIconSets;\n            const currentProvider = typeof provider === 'string' ? provider : this.defaultProvider;\n            if (customIconSets.providers[currentProvider] === void 0) {\n                // No custom icon sets, use collections\n                route = convert_1.objectToRoute({\n                    type: 'collections',\n                });\n            }\n            else {\n                const customSetsData = customIconSets.providers[currentProvider];\n                // Custom icon set exists\n                let showCollections = customSetsData.total > 1;\n                if (!showCollections &&\n                    customIconSets.merge !== 'only-custom') {\n                    // Show collections if API provider is valid\n                    showCollections = this._checkProvider(currentProvider, false);\n                }\n                route = convert_1.objectToRoute(showCollections\n                    ? {\n                        type: 'collections',\n                        params: {\n                            provider: currentProvider,\n                        },\n                    }\n                    : {\n                        type: 'collection',\n                        params: {\n                            provider: currentProvider,\n                            prefix: Object.keys(customSetsData.data).shift(),\n                        },\n                    });\n            }\n        }\n        if (route === null) {\n            throw new Error('Error resetting route');\n        }\n        // Change default provider\n        changeProvider(route, provider === null || !this._checkProvider(provider)\n            ? this.defaultProvider\n            : provider);\n        // Generate view\n        const view = this._viewFromRoute(route);\n        if (view === null) {\n            throw new Error('Error resetting route');\n        }\n        // Change view\n        this._setView(view, true);\n    }\n    /**\n     * Apply action to currently visible view\n     */\n    action(action, value) {\n        if (this._visibleView === null) {\n            return;\n        }\n        // If visible view does not match current view, reset pending view. Action overrides previous view change\n        this._changeCurrentView();\n        // Apply action to current view\n        this._visibleView.action(action, value);\n    }\n    /**\n     * Set icons to view with matching customType\n     *\n     * View must be visible or pending\n     */\n    setCustomIcons(customType, icons) {\n        const view = this._getCustomView(customType);\n        if (view !== null) {\n            view.setIcons(icons);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Get custom icons\n     */\n    getCustomIcons(customType) {\n        const view = this._getCustomView(customType);\n        return view === null ? null : view.getIcons();\n    }\n    /**\n     * Set route\n     */\n    _setRoute(route) {\n        let view;\n        // Check provider\n        if (route && route.params) {\n            const provider = route.params\n                .provider;\n            if (typeof provider === 'string' &&\n                provider !== '' &&\n                !this._checkProvider(provider)) {\n                route = null;\n            }\n        }\n        // Attempt to create view\n        if (route !== null && (view = this._viewFromRoute(route)) !== null) {\n            this._setView(view, true);\n            return;\n        }\n        // Error - navigate to home\n        this.home();\n    }\n    /**\n     * Find custom view\n     */\n    _getCustomView(customType) {\n        if (this._visibleView === null || this._view === null) {\n            return null;\n        }\n        // Check visible view\n        if (this._visibleView.type === 'custom' &&\n            this._visibleView.type === customType) {\n            return this._visibleView;\n        }\n        // Check pending view\n        if (this._view.type === 'custom' &&\n            this._view.type === customType) {\n            return this._view;\n        }\n        return null;\n    }\n    /**\n     * Create child view\n     */\n    createChildView(route, parentLevels = 0) {\n        const cleanRoute = route === null ? null : convert_1.objectToRoute(route);\n        if (cleanRoute === null) {\n            return;\n        }\n        // Set parent view\n        let parentView = this._visibleView;\n        for (let i = 0; i < parentLevels; i++) {\n            if (parentView !== null) {\n                parentView = parentView.parent;\n            }\n        }\n        // Create view\n        const view = this._viewFromRoute(cleanRoute, parentView);\n        if (view === null) {\n            return;\n        }\n        // Reset pending view\n        this._changeCurrentView();\n        // Set it as new view, but not immediately\n        this._setView(view, false);\n    }\n    /**\n     * Go up in parent views tree by \"levels\"\n     */\n    setParentView(levels = 1) {\n        let view = this._visibleView;\n        for (let i = 0; i < levels; i++) {\n            if (view === null || view.parent === null) {\n                return;\n            }\n            view = view.parent;\n        }\n        if (view !== this._visibleView) {\n            this._setView(view, true);\n        }\n    }\n    /**\n     * Set view\n     */\n    _setView(view, immediate) {\n        this._view = view;\n        view.startLoading();\n        if (this._visibleView !== view) {\n            if (immediate || !view.loading || this._visibleView === null) {\n                // Change visible view immediately and trigger event\n                this._visibleView = view;\n                this._triggerChange(true);\n            }\n            else {\n                // Start timer that will change visible view and trigger event after delay\n                this._startTimer();\n            }\n        }\n    }\n    /**\n     * Reset current view to visible view\n     */\n    _changeCurrentView() {\n        if (this._view !== this._visibleView) {\n            this._view = this._visibleView;\n            this._stopTimer();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Change visible view to current view\n     */\n    _changeVisibleView() {\n        if (this._view !== this._visibleView) {\n            this._visibleView = this._view;\n            this._stopTimer();\n            this._triggerChange(true);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Create view from route\n     */\n    _viewFromRoute(route, parentView = void 0) {\n        // Get parent view\n        let parent = null;\n        if (parentView !== void 0) {\n            parent = parentView;\n            route.parent = parentView === null ? null : parentView.route;\n        }\n        else if (route.parent !== null) {\n            parent = this._viewFromRoute(route.parent);\n            if (parent === null) {\n                return null;\n            }\n        }\n        // Create view\n        switch (route.type) {\n            case 'collections':\n                return new collections_1.CollectionsView(this._instance, route, parent);\n            case 'collection':\n                return new collection_1.CollectionView(this._instance, route, parent);\n            case 'search':\n                return new search_1.SearchView(this._instance, route, parent);\n            case 'custom':\n                return new custom_1.CustomView(this._instance, route, parent);\n            case 'empty':\n                return new empty_1.EmptyView(this._instance, route, parent);\n            default:\n                assertNever(route);\n                return null;\n        }\n    }\n    /**\n     * Handle event from view\n     */\n    _viewEvent(view) {\n        if (view !== this._view) {\n            // Action for different view - ignore it\n            return;\n        }\n        // Change visible view if it doesn't match view.\n        // Function also calls _triggerChange(true)\n        if (this._changeVisibleView()) {\n            return;\n        }\n        // Something changed in visible view\n        this._triggerChange(false);\n    }\n    /**\n     * Something has changed in visible view\n     */\n    _triggerChange(viewChanged) {\n        const registry = storage_1.getRegistry(this._instance);\n        const events = registry.events;\n        // Render blocks first, it might change error or route\n        const blocks = this.render();\n        // Create item\n        const item = {\n            viewChanged,\n            error: this.error(),\n            route: this.partialRoute,\n            blocks,\n        };\n        events.fire('render', item);\n    }\n    /**\n     * Start timer to change visible view\n     */\n    _startTimer() {\n        this._stopTimer();\n        const registry = storage_1.getRegistry(this._instance);\n        const config = registry.config;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const timeout = config.ui.viewUpdateDelay;\n        if (!timeout) {\n            this._changeVisibleView();\n        }\n        else {\n            // Store current view, change it on timer\n            const view = this._view;\n            this._timer = setTimeout(() => {\n                if (this._view === view) {\n                    this._changeVisibleView();\n                }\n            }, timeout);\n        }\n    }\n    /**\n     * Stop loading timer\n     */\n    _stopTimer() {\n        if (this._timer !== null) {\n            clearTimeout(this._timer);\n            this._timer = null;\n        }\n    }\n    /**\n     * Check if provider exists\n     */\n    _checkProvider(provider, checkCustom = true) {\n        // Get provider\n        const result = providers_1.getProvider(provider);\n        if (result !== null) {\n            return true;\n        }\n        // Test custom icon sets. Allow invalid provider if it has custom data\n        if (!checkCustom) {\n            return false;\n        }\n        const registry = storage_1.getRegistry(this._instance);\n        const customIconSets = registry.customIconSets;\n        return customIconSets.providers[provider] !== void 0;\n    }\n}\nexports.Router = Router;\n//# sourceMappingURL=router.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseView = void 0;\nconst storage_1 = require(\"../registry/storage\");\nconst providers_1 = require(\"../data/providers\");\n/**\n * Base view class\n */\nclass BaseView {\n    constructor() {\n        this.type = '';\n        this.parent = null;\n        this.updating = false;\n        this.error = '';\n        this.blocksRequireUpdate = true;\n        // Loading status\n        this.loading = true;\n        this._loadingTimer = null;\n        this._alreadyLoaded = false;\n        this._startedLoading = false;\n        // Loading control: waiting for parent view\n        this.onLoad = null;\n        this._mustWaitForParent = false;\n        this._isSync = null;\n    }\n    /**\n     * Set _isSync variable\n     */\n    _checkSync() {\n        if (this._isSync === null) {\n            this._isSync = !!storage_1.getRegistry(this._instance).config.router\n                .syncRender;\n        }\n        return this._isSync;\n    }\n    /**\n     * Change parent view\n     */\n    _parentAction(value) {\n        if (this.parent === null) {\n            return;\n        }\n        const levels = typeof value === 'number' && value > 0 ? value : 1;\n        const registry = storage_1.getRegistry(this._instance);\n        const router = registry.router;\n        router.setParentView(levels);\n    }\n    /**\n     * Change provider\n     */\n    _providerAction(value) {\n        if (typeof value !== 'string') {\n            return;\n        }\n        const providerData = providers_1.getProvider(value);\n        if (!providerData) {\n            return;\n        }\n        const registry = storage_1.getRegistry(this._instance);\n        const router = registry.router;\n        router.home(value);\n    }\n    /**\n     * Start loading\n     */\n    startLoading() {\n        if (this._startedLoading) {\n            return;\n        }\n        // Already loaded somehow (by setting data directly)\n        if (!this.loading) {\n            this._startedLoading = true;\n            return;\n        }\n        // Start loading\n        if (this._mustWaitForParent && this.parent !== null) {\n            this.parent.startLoading();\n        }\n        this._startLoading();\n    }\n    /**\n     * Start loading\n     */\n    _startLoading() {\n        this._startedLoading = true;\n        if (this._checkSync()) {\n            this._startLoadingData();\n        }\n        else {\n            setTimeout(() => {\n                this._startLoadingData();\n            });\n        }\n    }\n    _startLoadingData() {\n        throw new Error('startLoading should not be called on base view');\n    }\n    /**\n     * Search action\n     */\n    _searchAction(provider, value) {\n        if (typeof value !== 'string' || value.trim() === '') {\n            return;\n        }\n        const keyword = value.trim().toLowerCase();\n        // Check for collections\n        let view = this;\n        let levels = 0;\n        while (view.type !== 'collections') {\n            if (view.parent === null) {\n                return;\n            }\n            view = view.parent;\n            levels++;\n        }\n        // Apply action to collections\n        const registry = storage_1.getRegistry(this._instance);\n        const router = registry.router;\n        router.createChildView({\n            type: 'search',\n            params: {\n                provider,\n                search: keyword,\n            },\n        }, levels);\n    }\n    /**\n     * Load data from API\n     */\n    _loadAPI(provider, query, params, cacheKey = true) {\n        const registry = storage_1.getRegistry(this._instance);\n        const api = registry.api;\n        // Send query\n        api.query(provider, query, params, (data, error) => {\n            if (data === void 0) {\n                // Error\n                if (this.loading) {\n                    this.error = error === 404 ? 'not_found' : 'timeout';\n                    this.loading = false;\n                    this._triggerLoaded();\n                }\n                return;\n            }\n            if (data === null || !this._mustWaitForParent) {\n                // Parse immediately\n                this._parseAPIData(data);\n                return;\n            }\n            // Parse data after parent view has finished loading\n            this._waitForParent(() => {\n                this._parseAPIData(data);\n            });\n        }, cacheKey);\n    }\n    /**\n     * Wait for parent view to load\n     */\n    _waitForParent(callback) {\n        if (!this._mustWaitForParent ||\n            this.parent === null ||\n            !this.parent.loading) {\n            callback();\n            return;\n        }\n        // Wait for parent\n        this.parent.onLoad = callback;\n    }\n    /**\n     * Parse data from API\n     *\n     * Should be overwritten by child classes\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-unused-vars\n    _parseAPIData(data) {\n        throw new Error('_parseAPIData should not be called on base view');\n    }\n    /**\n     * Send event when view has been loaded\n     *\n     * Can be sent synchronously\n     */\n    _triggerLoaded() {\n        if (this._alreadyLoaded) {\n            // Do not trigger event twice\n            this._triggerUpdated();\n            return;\n        }\n        this._alreadyLoaded = true;\n        const registry = storage_1.getRegistry(this._instance);\n        const events = registry.events;\n        events.fire('view-loaded', this);\n        // Trigger onLoad event for child view\n        if (this.onLoad !== null) {\n            const onLoad = this.onLoad;\n            this.onLoad = null;\n            onLoad();\n        }\n    }\n    /**\n     * Send event when view has been updated\n     *\n     * Must be sent asynchronously to consume multiple updates\n     */\n    _triggerUpdated() {\n        if (!this.updating) {\n            this.updating = true;\n            const update = () => {\n                this.updating = false;\n                const registry = storage_1.getRegistry(this._instance);\n                const events = registry.events;\n                events.fire('view-updated', this);\n            };\n            if (this._checkSync()) {\n                update();\n            }\n            else {\n                setTimeout(update);\n            }\n        }\n    }\n}\nexports.BaseView = BaseView;\n//# sourceMappingURL=base.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollectionView = void 0;\nconst base_1 = require(\"./base\");\nconst collection_info_1 = require(\"../blocks/collection-info\");\nconst filters_1 = require(\"../blocks/filters\");\nconst collection_1 = require(\"../converters/collection\");\nconst icons_list_1 = require(\"../blocks/icons-list\");\nconst pagination_1 = require(\"../blocks/pagination\");\nconst storage_1 = require(\"../registry/storage\");\nconst search_1 = require(\"../blocks/search\");\nconst collections_list_1 = require(\"../blocks/collections-list\");\nconst collections_1 = require(\"../data/collections\");\nconst base_2 = require(\"../api/base\");\nconst filterKeys = [\n    'tags',\n    'themePrefixes',\n    'themeSuffixes',\n];\n/**\n * Class\n */\nclass CollectionView extends base_1.BaseView {\n    /**\n     * Create view\n     */\n    constructor(instance, route, parent = null) {\n        super();\n        this._data = null;\n        this._blocks = null;\n        this.type = 'collection';\n        this._instance = instance;\n        this.route = route;\n        this.provider = route.params.provider;\n        this.parent = parent;\n        this.prefix = route.params.prefix;\n        // Check if custom icon set is used\n        const registry = storage_1.getRegistry(this._instance);\n        const customSets = registry.customIconSets;\n        if (customSets.providers[this.provider] !== void 0 &&\n            customSets.providers[this.provider].data[this.prefix] !== void 0) {\n            this._isCustom = true;\n            this._data = customSets.providers[this.provider].data[this.prefix];\n        }\n        else {\n            this._isCustom = false;\n        }\n        // Wait for parent to load if parent view is search or collections list\n        this._mustWaitForParent =\n            parent !== null &&\n                (parent.type === 'search' || parent.type === 'collections');\n        // Check for cache\n        if (!this._data) {\n            const cache = registry.getCustom('core-cache');\n            if (typeof cache === 'object' && cache[this.provider]) {\n                const collectionCache = cache[this.provider].collection;\n                if (collectionCache && collectionCache[this.prefix]) {\n                    this._data = collectionCache[this.prefix];\n                }\n            }\n        }\n    }\n    /**\n     * Start loading\n     */\n    _startLoadingData() {\n        if (!this._data) {\n            const params = {\n                prefix: this.prefix,\n                info: 'true',\n                chars: 'true',\n                aliases: 'true',\n            };\n            if (this.route.params.icon !== '') {\n                // Ask for hidden icons (icons that were removed from icon set) if route has a\n                // reference icon, in case if reference icon is hidden.\n                params.hidden = 'true';\n            }\n            this._loadAPI(this.provider, '/collection', params, base_2.collectionCacheKey(this.prefix));\n        }\n        else {\n            this._parseAPIData(null);\n        }\n    }\n    /**\n     * Run action on view\n     */\n    action(action, value) {\n        switch (action) {\n            // Select parent view\n            case 'parent':\n                this._parentAction(value);\n                return;\n            // Change provider\n            case 'provider':\n                if (value !== this.provider) {\n                    this._providerAction(value);\n                }\n                return;\n            // Global search\n            case 'search':\n                this._searchAction(this.provider, value);\n                return;\n            // Search icons\n            case 'filter':\n                if (typeof value !== 'string') {\n                    return;\n                }\n                value = value.trim().toLowerCase();\n                if (value === this.route.params.filter) {\n                    return;\n                }\n                this.route.params.filter = value;\n                this.blocksRequireUpdate = true;\n                break;\n            // Change current page\n            case 'pagination':\n                if (typeof value === 'string') {\n                    value = parseInt(value);\n                }\n                // Check number\n                if (typeof value !== 'number' ||\n                    isNaN(value) ||\n                    value < 0 ||\n                    value === this.route.params.page) {\n                    return;\n                }\n                // Change page\n                this.route.params.page = value;\n                this.blocksRequireUpdate = true;\n                break;\n            // Change reference icon\n            case 'icon':\n                if (value === '' || value === null) {\n                    // Reset\n                    this.route.params.icon = '';\n                    break;\n                }\n                // Check type\n                if (typeof value !== 'string') {\n                    return;\n                }\n                // Change reference icon and automatically set page\n                this.route.params.icon = value;\n                this.route.params.page = null;\n                this.blocksRequireUpdate = true;\n                break;\n            // Filters\n            case 'tags':\n                this._filterAction('tag', value);\n                return;\n            case 'themePrefixes':\n                this._filterAction('themePrefix', value);\n                return;\n            case 'themeSuffixes':\n                this._filterAction('themeSuffix', value);\n                return;\n            // Parent view's filter\n            case 'collections':\n                this._collectionsAction(value);\n                return;\n            default:\n                return;\n        }\n        // Action has changed something - trigger update event\n        this._triggerUpdated();\n    }\n    /**\n     * Filter action\n     */\n    _filterAction(key, value) {\n        if (value !== null && typeof value !== 'string') {\n            return;\n        }\n        if (this.route.params[key] === value) {\n            return;\n        }\n        this.route.params[key] = value;\n        this.blocksRequireUpdate = true;\n        this._triggerUpdated();\n    }\n    /**\n     * Change active collection\n     */\n    _collectionsAction(value) {\n        if (this.parent === null ||\n            (this.parent.type !== 'search' &&\n                this.parent.type !== 'collections')) {\n            return;\n        }\n        // If value matches this collection, navigate to parent view\n        if (value === this.prefix || value === null) {\n            this._parentAction(1);\n            return;\n        }\n        // Run action on parent view\n        if (typeof value === 'string') {\n            this.parent.action('collections-internal', value);\n        }\n    }\n    /**\n     * Find icon in icons list\n     *\n     * Returns false on failure\n     */\n    _getIconIndex(icons, name) {\n        for (let i = 0; i < icons.length; i++) {\n            const icon = icons[i];\n            if (icon.name === name) {\n                return i;\n            }\n            if (icon.aliases) {\n                const aliases = icon.aliases;\n                for (let j = 0; j < aliases.length; j++) {\n                    if (aliases[j] === name) {\n                        return i;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Render blocks\n     */\n    render() {\n        if (this.loading || this._blocks === null || this._data === null) {\n            return null;\n        }\n        // Check if blocks have been cached or if there is a error\n        if (!this.blocksRequireUpdate || this.error !== '') {\n            return this._blocks;\n        }\n        this.blocksRequireUpdate = false;\n        // Apply route to blocks\n        const blocks = this._blocks;\n        // Copy icons\n        blocks.icons.icons = this._data.icons.slice(0);\n        // Set active filters\n        blocks.filter.keyword = this.route.params.filter;\n        if (blocks.tags !== null) {\n            blocks.tags.active = this.route.params.tag;\n        }\n        if (blocks.themePrefixes !== null) {\n            blocks.themePrefixes.active = this.route.params.themePrefix;\n        }\n        if (blocks.themeSuffixes !== null) {\n            blocks.themeSuffixes.active = this.route.params.themeSuffix;\n        }\n        // Apply search\n        icons_list_1.applyIconFilters(blocks.icons, blocks.filter, filterKeys\n            .filter((key) => blocks[key] !== null)\n            .map((key) => blocks[key]));\n        const iconsBlock = blocks.icons;\n        const iconsList = iconsBlock.icons;\n        // Get current page\n        const perPage = blocks.pagination.perPage;\n        const referenceIcon = this.route.params.icon;\n        let page;\n        if (this.route.params.page !== null) {\n            page = this.route.params.page;\n        }\n        else if (referenceIcon === '') {\n            page = 0;\n        }\n        else {\n            const iconIndex = this._getIconIndex(iconsList, referenceIcon);\n            page =\n                iconIndex === false ? 0 : pagination_1.getPageForIndex(perPage, iconIndex);\n        }\n        // Check pagination\n        blocks.pagination.length = iconsBlock.icons.length;\n        blocks.pagination.page = page;\n        const maximumPage = pagination_1.maxPage(blocks.pagination);\n        if (maximumPage < blocks.pagination.page) {\n            this.route.params.page = blocks.pagination.page = maximumPage;\n        }\n        // Apply pagination\n        const startIndex = blocks.pagination.page * perPage;\n        const nextIndex = Math.min(startIndex + perPage, iconsList.length + 1);\n        iconsBlock.icons = iconsList.slice(startIndex, nextIndex);\n        // Navigation\n        if (iconsList.length > 1) {\n            // Add first/last icon\n            iconsBlock.first = iconsList[0];\n            iconsBlock.last = iconsList[iconsList.length - 1];\n            // Add previous/next icon\n            iconsBlock.prev =\n                startIndex > 0 ? iconsList[startIndex - 1] : iconsBlock.last;\n            iconsBlock.next =\n                iconsList[nextIndex] === void 0\n                    ? iconsBlock.first\n                    : iconsList[nextIndex];\n        }\n        else {\n            // Nothing to navigate\n            delete iconsBlock.first;\n            delete iconsBlock.last;\n            delete iconsBlock.prev;\n            delete iconsBlock.next;\n        }\n        return this._blocks;\n    }\n    /**\n     * Parse data from API\n     *\n     * Should be overwritten by child classes\n     */\n    _parseAPIData(data) {\n        if (!this._data && !this._isCustom) {\n            this._data = collection_1.dataToCollection(this.provider, data);\n        }\n        // Mark as loaded, mark blocks for re-render and reset error\n        this.loading = false;\n        this.blocksRequireUpdate = true;\n        this.error = '';\n        // Create empty blocks\n        this._blocks = {\n            // Info\n            info: collection_info_1.defaultCollectionInfoBlock(),\n            // Search\n            filter: Object.assign(search_1.defaultSearchBlock(), {\n                keyword: this.route.params.filter,\n                searchType: 'collection',\n                title: this.prefix,\n            }),\n            // Filters\n            collections: null,\n            tags: null,\n            themePrefixes: null,\n            themeSuffixes: null,\n            // Icons and pagination\n            icons: icons_list_1.defaultIconsListBlock(),\n            pagination: pagination_1.defaultPaginationBlock(),\n        };\n        const initialisedBlocks = this._blocks;\n        // Check if data was valid\n        if (this._data === null) {\n            this.error = data === null ? 'not_found' : 'invalid_data';\n            this._triggerLoaded();\n            return;\n        }\n        const parsedData = this._data;\n        // Validate prefix\n        if (this.prefix !== parsedData.prefix) {\n            this.error = 'invalid_data';\n            this._triggerLoaded();\n            return;\n        }\n        // Get registry and modules\n        const registry = storage_1.getRegistry(this._instance);\n        const config = registry.config;\n        const collections = registry.collections;\n        // Set info\n        initialisedBlocks.info.prefix = this.prefix;\n        if (parsedData.info !== void 0) {\n            // Store info in collections storage\n            collections_1.setCollectionInfo(collections, this.provider, this.prefix, parsedData.info);\n        }\n        // Get info from collections storage because it might include index for color scheme\n        initialisedBlocks.info.info = collections_1.getCollectionInfo(collections, this.provider, this.prefix);\n        if (initialisedBlocks.info.info !== null) {\n            initialisedBlocks.filter.title = initialisedBlocks.info.info.name;\n        }\n        // Check if there are any icons\n        if (parsedData.total < 1) {\n            this.error = 'empty';\n        }\n        else {\n            // Create pagination\n            const pagination = initialisedBlocks.pagination;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            pagination.perPage = config.ui.itemsPerPage;\n            pagination.fullLength = pagination.length = parsedData.icons.length;\n            const page = this.route.params.page;\n            pagination.page =\n                page === null ? 0 : Math.min(page, pagination_1.maxPage(pagination));\n            // Copy full icons list for possible use in UI\n            this._blocks.icons.allIcons = parsedData.icons;\n            // Copy collections filter from parent view\n            if (this.parent && !this.parent.loading) {\n                if (this.parent.type === 'search') {\n                    // Get copy of block from parent view\n                    const collectionsBlock = this\n                        .parent.getCollectionsBlock();\n                    if (collectionsBlock !== null) {\n                        // Copy block and set active filter\n                        this._blocks.collections = collectionsBlock;\n                        this._blocks.collections.active = this.prefix;\n                    }\n                }\n                else if (this.parent.type === 'collections') {\n                    // Find previous / next items\n                    this._blocks.collections = this._findSiblingCollections();\n                }\n            }\n            // Icon filters\n            let startIndex = 0;\n            filterKeys.forEach((key) => {\n                const dataKey = key;\n                if (parsedData[dataKey] !== void 0) {\n                    const item = parsedData[dataKey];\n                    const isArray = item instanceof Array;\n                    const list = (isArray\n                        ? item\n                        : Object.values(item));\n                    const listKeys = isArray\n                        ? []\n                        : Object.keys(item);\n                    if (list instanceof Array && list.length > 1) {\n                        // Create empty filters block\n                        const filter = filters_1.defaultFiltersBlock();\n                        filter.filterType = key;\n                        initialisedBlocks[key] = filter;\n                        // Copy all filters\n                        list.forEach((tag, index) => {\n                            const item = filters_1.defaultFilter(tag);\n                            if (!isArray) {\n                                item.match = listKeys[index];\n                            }\n                            filter.filters[tag] = item;\n                        });\n                        // Apply index\n                        startIndex = filters_1.autoIndexFilters(filter, startIndex);\n                    }\n                }\n            });\n        }\n        // Send event\n        this._triggerLoaded();\n    }\n    /**\n     * Find sibling collections from collections list, return them as block\n     */\n    _findSiblingCollections() {\n        const collectionsBlock = this\n            .parent.getCollectionsBlock();\n        if (collectionsBlock === null) {\n            return null;\n        }\n        const collections = collections_list_1.collectionsPrefixesWithInfo(collectionsBlock);\n        const match = collections.find((item) => item.prefix === this.prefix);\n        if (match === void 0 || collections.length < 2) {\n            return null;\n        }\n        // Get limit\n        const registry = storage_1.getRegistry(this._instance);\n        const config = registry.config;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const limit = config.ui.showSiblingCollections;\n        // Get items before and after current prefix\n        let display = [];\n        if (collections.length < limit * 2 + 2) {\n            // Display all collections\n            display = collections.slice(0);\n        }\n        else {\n            const index = collections.indexOf(match);\n            // few items before current\n            for (let i = index - limit; i < index; i++) {\n                display.push(collections[(i + collections.length) % collections.length]);\n            }\n            // Current item\n            display.push(match);\n            // few items after current\n            for (let i = index + 1; i <= index + limit; i++) {\n                display.push(collections[i % collections.length]);\n            }\n        }\n        // Create block\n        const block = filters_1.defaultFiltersBlock();\n        block.filterType = 'collections';\n        block.active = this.prefix;\n        display.forEach((item) => {\n            const filter = filters_1.defaultFilter(item.name);\n            filter.index = item.index;\n            block.filters[item.prefix] = filter;\n        });\n        return block;\n    }\n}\nexports.CollectionView = CollectionView;\n//# sourceMappingURL=collection.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollectionsView = void 0;\nconst base_1 = require(\"./base\");\nconst collections_filter_1 = require(\"../blocks/collections-filter\");\nconst collections_list_1 = require(\"../blocks/collections-list\");\nconst filters_1 = require(\"../blocks/filters\");\nconst collections_1 = require(\"../converters/collections\");\nconst storage_1 = require(\"../registry/storage\");\nconst collections_2 = require(\"../data/collections\");\nconst custom_sets_1 = require(\"../data/custom-sets\");\nconst base_2 = require(\"../api/base\");\n/**\n * Class\n */\nclass CollectionsView extends base_1.BaseView {\n    /**\n     * Create view\n     */\n    constructor(instance, route, parent = null) {\n        super();\n        this._data = null;\n        this._blocks = null;\n        this.type = 'collections';\n        this._instance = instance;\n        this.route = route;\n        this.provider = route.params.provider;\n        this.parent = parent;\n        // Check if custom icon set is used\n        const registry = storage_1.getRegistry(this._instance);\n        const customSets = registry.customIconSets;\n        if (customSets.providers[this.provider] !== void 0) {\n            this._sources = {\n                custom: true,\n                api: customSets.merge !== 'only-custom',\n                merge: customSets.merge,\n            };\n        }\n        else {\n            this._sources = {\n                custom: false,\n                api: true,\n            };\n        }\n        // Check for cache\n        const cache = registry.getCustom('core-cache');\n        if (typeof cache === 'object') {\n            const providerCache = cache[this.provider];\n            if (providerCache && providerCache.collections) {\n                this._data = providerCache.collections;\n            }\n        }\n    }\n    /**\n     * Start loading\n     */\n    _startLoadingData() {\n        if (this._data || !this._sources.api) {\n            this._parseAPIData(null);\n            return;\n        }\n        this._loadAPI(this.provider, '/collections', {}, base_2.collectionsCacheKey());\n    }\n    /**\n     * Run action on view\n     */\n    action(action, value) {\n        switch (action) {\n            // Parent view\n            case 'parent':\n                this._parentAction(value);\n                return;\n            // Change provider\n            case 'provider':\n                if (value !== this.provider) {\n                    this._providerAction(value);\n                }\n                return;\n            // Global search\n            case 'search':\n                if (this._sources.api) {\n                    this._searchAction(this.provider, value);\n                }\n                return;\n            // Filter collections\n            case 'filter':\n                if (typeof value !== 'string') {\n                    return;\n                }\n                value = value.trim().toLowerCase();\n                if (this.route.params.filter !== value) {\n                    this.route.params.filter = value;\n                    this.blocksRequireUpdate = true;\n                }\n                else {\n                    return;\n                }\n                break;\n            // Filter categories\n            case 'categories':\n                if ((value === null || typeof value === 'string') &&\n                    value !== this.route.params.category) {\n                    this.route.params.category = value;\n                    this.blocksRequireUpdate = true;\n                }\n                else {\n                    return;\n                }\n                break;\n            // Select collection, called from child view\n            case 'collections-internal':\n                if (typeof value !== 'string' || value === '') {\n                    return;\n                }\n                this._triggerCollectionAction(value, 1);\n                return;\n            // Select collection\n            case 'collections':\n                if (typeof value !== 'string' || value === '') {\n                    return;\n                }\n                this._triggerCollectionAction(value, 0);\n                return;\n            default:\n                return;\n        }\n        // Action has changed something - trigger update event\n        this._triggerUpdated();\n    }\n    /**\n     * Create child view for prefix\n     */\n    _triggerCollectionAction(prefix, levels) {\n        // Try to find prefix in collections list\n        if (!this.loading && this._data !== null && this.error === '') {\n            // Find matching prefix\n            const categories = Object.keys(this._data);\n            let found = false;\n            for (let i = 0; i < categories.length; i++) {\n                if (this._data[categories[i]][prefix] !== void 0) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return;\n            }\n        }\n        // Create child view\n        const registry = storage_1.getRegistry(this._instance);\n        const router = registry.router;\n        router.createChildView({\n            type: 'collection',\n            params: {\n                provider: this.provider,\n                prefix: prefix,\n            },\n        }, levels);\n    }\n    /**\n     * Render blocks\n     */\n    render() {\n        if (this.loading || this._blocks === null || this._data === null) {\n            return null;\n        }\n        // Check if blocks have been cached or if there is a error\n        if (!this.blocksRequireUpdate || this.error !== '') {\n            return this._blocks;\n        }\n        this.blocksRequireUpdate = false;\n        // Apply route to blocks\n        const blocks = this._blocks;\n        const keyword = typeof this.route.params.filter === 'string'\n            ? this.route.params.filter\n            : '';\n        const category = typeof this.route.params.category === 'string'\n            ? this.route.params.category\n            : null;\n        // Set keyword and active category\n        blocks.filter.keyword = keyword;\n        blocks.categories.active = category;\n        // Set collections\n        blocks.collections.collections = this._data;\n        // Apply search filter and change disabled categories in categories filter\n        blocks.collections = collections_list_1.applyCollectionsFilter(blocks.collections, blocks.filter, blocks.categories);\n        // Apply category filter\n        if (category !== null) {\n            blocks.collections = collections_list_1.disableInactiveCategories(blocks.collections, category);\n        }\n        return blocks;\n    }\n    /**\n     * Get collections block.\n     *\n     * Used by child view.\n     */\n    getCollectionsBlock() {\n        if (this.loading || this.error !== '') {\n            return null;\n        }\n        const blocks = this.render();\n        return blocks !== null && blocks.collections !== null\n            ? blocks.collections\n            : null;\n    }\n    /**\n     * Parse data from API\n     *\n     * Should be overwritten by child classes\n     */\n    _parseAPIData(data) {\n        if (this._sources.api && !data && !this._data) {\n            // Error\n            this._data = null;\n        }\n        else if (!this._data) {\n            // Convert and merge data\n            this._data = custom_sets_1.mergeCollections(this.route.params.provider, this._sources.api\n                ? collections_1.dataToCollections(data)\n                : null, this._sources.custom\n                ? storage_1.getRegistry(this._instance).customIconSets\n                : null);\n        }\n        // Mark as loaded and mark blocks for re-render\n        this.loading = false;\n        this.blocksRequireUpdate = true;\n        this.error = '';\n        // Create blocks\n        this._blocks = {\n            filter: collections_filter_1.defaultCollectionsFilterBlock(),\n            categories: filters_1.defaultFiltersBlock(),\n            collections: collections_list_1.defaultCollectionsListBlock(),\n        };\n        this._blocks.categories.filterType = 'categories';\n        // Parse data\n        if (this._data === null) {\n            this.error = data === null ? 'not_found' : 'invalid_data';\n        }\n        else {\n            // Add indexes to collections\n            collections_1.autoIndexCollections(this._data);\n            // Set collections\n            this._blocks.collections.collections = this._data;\n            // Get categories\n            const categories = collections_list_1.getCollectionsBlockCategories(this._blocks.collections, true);\n            if (categories.length === 0) {\n                this.error = 'empty';\n            }\n            else {\n                if (categories.length > 1) {\n                    // Set category filters\n                    this._blocks.collections.showCategories = true;\n                    const filters = this._blocks.categories.filters;\n                    categories.forEach((category) => {\n                        filters[category] = filters_1.defaultFilter(category);\n                    });\n                    filters_1.autoIndexFilters(this._blocks.categories);\n                }\n                else {\n                    // Disable category filters\n                    this._blocks.collections.showCategories = false;\n                }\n                // Store collections in global data\n                const registry = storage_1.getRegistry(this._instance);\n                const collections = registry.collections;\n                collections_list_1.iterateCollectionsBlock(this._blocks.collections, (item, prefix) => {\n                    collections_2.setCollectionInfo(collections, this.provider, prefix, item);\n                });\n            }\n        }\n        // Send event\n        this._triggerLoaded();\n    }\n}\nexports.CollectionsView = CollectionsView;\n//# sourceMappingURL=collections.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CustomView = void 0;\nconst base_1 = require(\"./base\");\nconst icons_list_1 = require(\"../blocks/icons-list\");\nconst pagination_1 = require(\"../blocks/pagination\");\nconst storage_1 = require(\"../registry/storage\");\nconst icon_1 = require(\"../misc/icon\");\nconst search_1 = require(\"../blocks/search\");\nconst objects_1 = require(\"../misc/objects\");\n/**\n * Class\n */\nclass CustomView extends base_1.BaseView {\n    /**\n     * Create view\n     */\n    constructor(instance, route, parent = null) {\n        super();\n        this._data = null;\n        this._blocks = null;\n        this.type = 'custom';\n        this._instance = instance;\n        this.route = route;\n        this.parent = parent;\n        this.customType = route.params.customType;\n        this._mustWaitForParent = true;\n    }\n    /**\n     * Start loading\n     */\n    _startLoadingData() {\n        if (this._data !== null) {\n            return;\n        }\n        const registry = storage_1.getRegistry(this._instance);\n        const events = registry.events;\n        // Fire public event, exposed to external code\n        events.fire('load-' + this.customType, this.setIcons.bind(this));\n    }\n    /**\n     * Run action on view\n     */\n    action(action, value) {\n        switch (action) {\n            // Change view\n            case 'parent':\n                this._parentAction(value);\n                return;\n            // Change provider\n            case 'provider':\n                this._providerAction(value);\n                return;\n            // Set icons\n            case 'set':\n                this.setIcons(value);\n                // Returning because setIcons will trigger event\n                return;\n            // Search icons\n            case 'filter':\n                if (typeof value !== 'string') {\n                    return;\n                }\n                value = value.trim().toLowerCase();\n                if (value === this.route.params.filter) {\n                    return;\n                }\n                this.route.params.filter = value;\n                this.blocksRequireUpdate = true;\n                break;\n            // Change current page\n            case 'pagination':\n                if (typeof value === 'string') {\n                    value = parseInt(value);\n                }\n                // Check number\n                if (typeof value !== 'number' ||\n                    isNaN(value) ||\n                    value < 0 ||\n                    value === this.route.params.page) {\n                    return;\n                }\n                // Change page\n                this.route.params.page = value;\n                this.blocksRequireUpdate = true;\n                break;\n            default:\n                return;\n        }\n        // Action has changed something - trigger update event\n        this._triggerUpdated();\n    }\n    /**\n     * Render blocks\n     */\n    render() {\n        if (this.loading || this._blocks === null || this._data === null) {\n            return null;\n        }\n        // Check if blocks have been cached or if there is a error\n        if (!this.blocksRequireUpdate || this.error !== '') {\n            return this._blocks;\n        }\n        this.blocksRequireUpdate = false;\n        // Apply route to blocks\n        const blocks = this._blocks;\n        // Copy icons\n        blocks.icons.icons = this._data.slice(0);\n        // Search icons\n        blocks.filter.keyword = this.route.params.filter;\n        icons_list_1.applyIconFilters(blocks.icons, blocks.filter, [], true);\n        // Get items per page\n        const registry = storage_1.getRegistry(this._instance);\n        const config = registry.config;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const itemsPerPage = config.ui.itemsPerPage;\n        // Check pagination\n        blocks.pagination.length = blocks.icons.icons.length;\n        blocks.pagination.page = this.route.params.page;\n        const maximumPage = pagination_1.maxPage(blocks.pagination);\n        if (maximumPage < blocks.pagination.page) {\n            this.route.params.page = blocks.pagination.page = maximumPage;\n        }\n        // Apply pagination\n        const startIndex = blocks.pagination.page * itemsPerPage;\n        blocks.icons.icons = blocks.icons.icons.slice(startIndex, startIndex + itemsPerPage);\n        return this._blocks;\n    }\n    /**\n     * Set icons\n     */\n    setIcons(data) {\n        this._waitForParent(() => {\n            if (!this._checkSync()) {\n                // Make sure its async unless synchronous loading is enabled\n                setTimeout(() => {\n                    this._setIcons(data);\n                });\n            }\n            else {\n                this._setIcons(data);\n            }\n        });\n    }\n    _setIcons(data) {\n        // Check if data is valid\n        let dataArray = data;\n        let invalidData = false;\n        if (!(dataArray instanceof Array)) {\n            invalidData = true;\n            dataArray = [];\n        }\n        // Filter data\n        const parsedData = dataArray\n            .map((item) => {\n            // Convert strings\n            if (typeof item === 'string') {\n                item = icon_1.stringToIcon(item);\n            }\n            // Validate object\n            if (typeof item === 'object' && icon_1.validateIcon(item)) {\n                const icon = item;\n                return {\n                    provider: icon.provider,\n                    prefix: icon.prefix,\n                    name: icon.name,\n                };\n            }\n            // Invalid icon\n            return null;\n        })\n            .filter((icon) => icon !== null);\n        // Save data\n        this._data = parsedData;\n        // Mark as loaded, mark blocks for re-render and reset error\n        this.loading = false;\n        this.blocksRequireUpdate = true;\n        this.error = '';\n        // Create empty blocks\n        this._blocks = {\n            // Search\n            filter: Object.assign(search_1.defaultSearchBlock(), {\n                keyword: this.route.params.filter,\n                searchType: 'custom',\n                title: this.customType,\n            }),\n            // Icons and pagination\n            icons: icons_list_1.defaultIconsListBlock(),\n            pagination: pagination_1.defaultPaginationBlock(),\n        };\n        const initialisedBlocks = this._blocks;\n        // Check if data was valid\n        if (invalidData) {\n            this.error = data === null ? 'not_found' : 'invalid_data';\n            this._triggerLoaded();\n            return;\n        }\n        // Check if there are any icons\n        if (parsedData.length < 1) {\n            this.error = 'empty';\n        }\n        else {\n            // Get registry and modules\n            const registry = storage_1.getRegistry(this._instance);\n            const config = registry.config;\n            // Create pagination\n            const pagination = initialisedBlocks.pagination;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            pagination.perPage = config.ui.itemsPerPage;\n            pagination.fullLength = pagination.length = parsedData.length;\n            pagination.page = Math.min(this.route.params.page, pagination_1.maxPage(pagination));\n            // Copy full icons list for possible use in UI\n            this._blocks.icons.allIcons = parsedData;\n        }\n        // Send event\n        this._triggerLoaded();\n    }\n    /**\n     * Get icons list\n     */\n    getIcons() {\n        if (this.loading || this._blocks === null || this._data === null) {\n            return null;\n        }\n        return objects_1.cloneObject(this._data);\n    }\n}\nexports.CustomView = CustomView;\n//# sourceMappingURL=custom.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EmptyView = void 0;\nconst base_1 = require(\"./base\");\n/**\n * Class\n */\nclass EmptyView extends base_1.BaseView {\n    /**\n     * Create view\n     */\n    constructor(instance, route, parent = null) {\n        super();\n        this.type = 'empty';\n        this._instance = instance;\n        this.route = route;\n        this.parent = parent;\n    }\n    /**\n     * Start loading\n     */\n    _startLoadingData() {\n        this.loading = false;\n        this._triggerLoaded();\n    }\n    /**\n     * Run action on view\n     */\n    action(action, value) {\n        switch (action) {\n            // Navigate to parent view\n            case 'parent':\n                this._parentAction(value);\n                return;\n            // Change provider\n            case 'provider':\n                this._providerAction(value);\n                return;\n        }\n    }\n    /**\n     * Render blocks\n     */\n    render() {\n        return {};\n    }\n}\nexports.EmptyView = EmptyView;\n//# sourceMappingURL=empty.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SearchView = void 0;\nconst base_1 = require(\"./base\");\nconst filters_1 = require(\"../blocks/filters\");\nconst search_1 = require(\"../converters/search\");\nconst icons_list_1 = require(\"../blocks/icons-list\");\nconst pagination_1 = require(\"../blocks/pagination\");\nconst storage_1 = require(\"../registry/storage\");\nconst objects_1 = require(\"../misc/objects\");\nconst collections_1 = require(\"../data/collections\");\nconst base_2 = require(\"../api/base\");\n/**\n * Class\n */\nclass SearchView extends base_1.BaseView {\n    /**\n     * Create view\n     */\n    constructor(instance, route, parent = null) {\n        super();\n        this._data = null;\n        this._blocks = null;\n        this.type = 'search';\n        this._instance = instance;\n        this.route = route;\n        this.provider = route.params.provider;\n        this.parent = parent;\n        this.keyword = route.params.search;\n        // Get number of items per page\n        const registry = storage_1.getRegistry(this._instance);\n        const config = registry.config;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.itemsPerPage = config.ui.itemsPerPage;\n        // Check if full results need to be shown\n        if (this.route.params.page > 1) {\n            this.route.params.short = false;\n        }\n        // Check for cache\n        const cache = registry.getCustom('core-cache');\n        if (typeof cache === 'object' && cache[this.provider]) {\n            const searchCache = cache[this.provider].search;\n            if (searchCache && searchCache[this.keyword]) {\n                this._data = searchCache[this.keyword];\n                // Only full pages can be cached\n                this.route.params.short = false;\n            }\n        }\n        // Set items limit for query\n        this.itemsLimit = this.route.params.short ? this.itemsPerPage * 2 : 999;\n    }\n    /**\n     * Start loading\n     */\n    _startLoadingData() {\n        if (!this._data) {\n            const query = this.keyword;\n            const limit = this.itemsLimit;\n            this._loadAPI(this.provider, '/search', {\n                query,\n                limit,\n            }, base_2.searchCacheKey(query, limit));\n        }\n        else {\n            this._parseAPIData(null);\n        }\n    }\n    /**\n     * Run action on view\n     */\n    action(action, value) {\n        switch (action) {\n            // Change to parent view\n            case 'parent':\n                this._parentAction(value);\n                return;\n            // Change provider\n            case 'provider':\n                if (value !== this.provider) {\n                    this._providerAction(value);\n                }\n                return;\n            // Global search\n            case 'search':\n                if (typeof value !== 'string') {\n                    return;\n                }\n                value = value.trim().toLowerCase();\n                if (value === this.keyword) {\n                    return;\n                }\n                this._searchAction(this.provider, value);\n                return;\n            // Change current page\n            case 'pagination':\n                if (value === 'more' && this._showMoreButton()) {\n                    // Change to current page + 1\n                    value = this.route.params.page + 1;\n                }\n                // Check number\n                if (typeof value === 'string') {\n                    value = parseInt(value);\n                }\n                if (typeof value !== 'number' ||\n                    isNaN(value) ||\n                    value === this.route.params.page ||\n                    value < 0) {\n                    return;\n                }\n                // Check for \"more\"\n                if (value > 0 && this._showMoreButton()) {\n                    // Create sibling route\n                    this._triggerFullResults(value);\n                    return;\n                }\n                this.route.params.page = value;\n                this.blocksRequireUpdate = true;\n                break;\n            // Collections filter\n            case 'collections':\n                this._collectionsAction(value, 0);\n                return;\n            // Collections filter, called from child view\n            case 'collections-internal':\n                this._collectionsAction(value, 1);\n                return;\n            default:\n                return;\n        }\n        // Action has changed something - trigger update event\n        this._triggerUpdated();\n    }\n    /**\n     * Change active collection\n     */\n    _collectionsAction(value, levels) {\n        if (value !== null && typeof value !== 'string') {\n            return;\n        }\n        if (this.loading ||\n            this._blocks === null ||\n            this._blocks.collections === null) {\n            return;\n        }\n        const registry = storage_1.getRegistry(this._instance);\n        const router = registry.router;\n        if (value === null) {\n            // Change view to search results\n            router.setParentView(levels);\n            return;\n        }\n        // Create child view\n        const prefix = value;\n        router.createChildView({\n            type: 'collection',\n            params: {\n                provider: this.provider,\n                prefix,\n                filter: this.keyword,\n            },\n        }, levels);\n    }\n    /**\n     * Show full results\n     */\n    _triggerFullResults(page) {\n        // Create sibling view\n        const registry = storage_1.getRegistry(this._instance);\n        const router = registry.router;\n        router.createChildView({\n            type: 'search',\n            params: Object.assign({}, this.route.params, {\n                page: page,\n                short: false,\n            }),\n        }, 1);\n    }\n    /**\n     * Render blocks\n     */\n    render() {\n        if (this.loading || this._blocks === null || this._data === null) {\n            return null;\n        }\n        // Check if blocks have been cached or if there is a error\n        if (!this.blocksRequireUpdate || this.error !== '') {\n            return this._blocks;\n        }\n        this.blocksRequireUpdate = false;\n        // Apply route to blocks\n        const blocks = this._blocks;\n        // Copy icons\n        blocks.icons.icons = this._data.icons.slice(0);\n        // Set active filters\n        if (blocks.collections !== null) {\n            blocks.collections.active = null;\n        }\n        // Check pagination\n        blocks.pagination.length = blocks.icons.icons.length;\n        blocks.pagination.page = this.route.params.page;\n        const maximumPage = pagination_1.maxPage(blocks.pagination);\n        if (maximumPage < blocks.pagination.page) {\n            this.route.params.page = blocks.pagination.page = maximumPage;\n        }\n        // Apply pagination\n        const startIndex = blocks.pagination.page * this.itemsPerPage;\n        blocks.icons.icons = blocks.icons.icons.slice(startIndex, startIndex + this.itemsPerPage);\n        return this._blocks;\n    }\n    /**\n     * Get collections block.\n     *\n     * Used by child views. Result is copied, ready to be modified\n     */\n    getCollectionsBlock() {\n        if (this.loading || this.error !== '') {\n            return null;\n        }\n        const blocks = this.render();\n        return blocks !== null && blocks.collections !== null\n            ? objects_1.cloneObject(blocks.collections)\n            : null;\n    }\n    /**\n     * Check if more results are available\n     */\n    _showMoreButton() {\n        return this._data === null\n            ? false\n            : this.route.params.short && this._data.total === this._data.limit;\n    }\n    /**\n     * Parse data from API\n     *\n     * Should be overwritten by child classes\n     */\n    _parseAPIData(data) {\n        if (!this._data) {\n            this._data = search_1.dataToSearchResults(this.provider, data);\n        }\n        // Mark as loaded, mark blocks for re-render and reset error\n        this.loading = false;\n        this.blocksRequireUpdate = true;\n        this.error = '';\n        // Create empty blocks\n        this._blocks = {\n            // Filters\n            collections: null,\n            // Icons and pagination\n            icons: icons_list_1.defaultIconsListBlock(),\n            pagination: pagination_1.defaultPaginationBlock(),\n        };\n        const initialisedBlocks = this._blocks;\n        // Check if data was valid\n        if (this._data === null) {\n            this.error = data === null ? 'not_found' : 'invalid_data';\n            this._triggerLoaded();\n            return;\n        }\n        const parsedData = this._data;\n        // Validate parameters\n        if (this.keyword !== parsedData.query) {\n            this.error = 'invalid_data';\n            this._triggerLoaded();\n            return;\n        }\n        // Overwrite limit\n        if (parsedData.limit) {\n            this.itemsLimit = parsedData.limit;\n        }\n        // Check if there are any icons\n        if (parsedData.total < 1) {\n            this.error = 'empty';\n        }\n        else {\n            // Create pagination\n            const pagination = initialisedBlocks.pagination;\n            pagination.perPage = this.itemsPerPage;\n            pagination.fullLength = pagination.length = parsedData.icons.length;\n            pagination.page = Math.min(this.route.params.page, pagination_1.maxPage(pagination));\n            // Check if more results are available\n            pagination.more = this._showMoreButton();\n            // Get all collections\n            const prefixes = Object.keys(parsedData.collections);\n            // Store collections in global data\n            const registry = storage_1.getRegistry(this._instance);\n            const collections = registry.collections;\n            prefixes.forEach((prefix) => {\n                collections_1.setCollectionInfo(collections, this.provider, prefix, parsedData.collections[prefix]);\n            });\n            // Collections filter\n            if (prefixes.length > 1) {\n                const block = filters_1.defaultFiltersBlock();\n                this._blocks.collections = block;\n                block.filterType = 'collections';\n                prefixes.forEach((prefix) => {\n                    block.filters[prefix] = filters_1.defaultFilter(parsedData.collections[prefix].name);\n                });\n                filters_1.autoIndexFilters(block);\n            }\n        }\n        // Send event\n        this._triggerLoaded();\n    }\n}\nexports.SearchView = SearchView;\n//# sourceMappingURL=search.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeCustomisations = exports.defaults = void 0;\n/**\n * Default icon customisations values\n */\nexports.defaults = Object.freeze({\n    // Display mode\n    inline: false,\n    // Dimensions\n    width: null,\n    height: null,\n    // Alignment\n    hAlign: 'center',\n    vAlign: 'middle',\n    slice: false,\n    // Transformations\n    hFlip: false,\n    vFlip: false,\n    rotate: 0,\n});\n/**\n * TypeScript\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars-experimental, @typescript-eslint/no-unused-vars\nfunction assertNever(v) {\n    //\n}\n/**\n * Convert IconifyIconCustomisations to FullIconCustomisations\n */\nfunction mergeCustomisations(defaults, item) {\n    const result = {};\n    for (const key in defaults) {\n        const attr = key;\n        // Copy old value\n        result[attr] = defaults[attr];\n        if (item[attr] === void 0) {\n            continue;\n        }\n        // Validate new value\n        const value = item[attr];\n        switch (attr) {\n            // Boolean attributes that override old value\n            case 'inline':\n            case 'slice':\n                if (typeof value === 'boolean') {\n                    result[attr] = value;\n                }\n                break;\n            // Boolean attributes that are merged\n            case 'hFlip':\n            case 'vFlip':\n                if (value === true) {\n                    result[attr] = !result[attr];\n                }\n                break;\n            // Non-empty string\n            case 'hAlign':\n            case 'vAlign':\n                if (typeof value === 'string' && value !== '') {\n                    result[attr] = value;\n                }\n                break;\n            // Non-empty string / non-zero number / null\n            case 'width':\n            case 'height':\n                if ((typeof value === 'string' && value !== '') ||\n                    (typeof value === 'number' && value) ||\n                    value === null) {\n                    result[attr] = value;\n                }\n                break;\n            // Rotation\n            case 'rotate':\n                if (typeof value === 'number') {\n                    result[attr] += value;\n                }\n                break;\n            default:\n                assertNever(attr);\n        }\n    }\n    return result;\n}\nexports.mergeCustomisations = mergeCustomisations;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fullIcon = exports.iconDefaults = exports.matchName = void 0;\n/**\n * Expression to test part of icon name.\n */\nexports.matchName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\n/**\n * Default values for all optional IconifyIcon properties\n */\nexports.iconDefaults = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16,\n    rotate: 0,\n    vFlip: false,\n    hFlip: false,\n});\n/**\n * Add optional properties to icon\n */\nfunction fullIcon(data) {\n    return { ...exports.iconDefaults, ...data };\n}\nexports.fullIcon = fullIcon;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateIcon = exports.stringToIcon = void 0;\nconst index_1 = require(\"./index\");\n/**\n * Convert string to Icon object.\n */\nconst stringToIcon = (value, validate, allowSimpleName, provider = '') => {\n    const colonSeparated = value.split(':');\n    // Check for provider with correct '@' at start\n    if (value.slice(0, 1) === '@') {\n        // First part is provider\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n            // \"@provider:prefix:name\" or \"@provider:prefix-name\"\n            return null;\n        }\n        provider = colonSeparated.shift().slice(1);\n    }\n    // Check split by colon: \"prefix:name\", \"provider:prefix:name\"\n    if (colonSeparated.length > 3 || !colonSeparated.length) {\n        return null;\n    }\n    if (colonSeparated.length > 1) {\n        // \"prefix:name\"\n        const name = colonSeparated.pop();\n        const prefix = colonSeparated.pop();\n        const result = {\n            // Allow provider without '@': \"provider:prefix:name\"\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix,\n            name,\n        };\n        return validate && !(0, exports.validateIcon)(result) ? null : result;\n    }\n    // Attempt to split by dash: \"prefix-name\"\n    const name = colonSeparated[0];\n    const dashSeparated = name.split('-');\n    if (dashSeparated.length > 1) {\n        const result = {\n            provider: provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join('-'),\n        };\n        return validate && !(0, exports.validateIcon)(result) ? null : result;\n    }\n    // If allowEmpty is set, allow empty provider and prefix, allowing names like \"home\"\n    if (allowSimpleName && provider === '') {\n        const result = {\n            provider: provider,\n            prefix: '',\n            name,\n        };\n        return validate && !(0, exports.validateIcon)(result, allowSimpleName)\n            ? null\n            : result;\n    }\n    return null;\n};\nexports.stringToIcon = stringToIcon;\n/**\n * Check if icon is valid.\n *\n * This function is not part of stringToIcon because validation is not needed for most code.\n */\nconst validateIcon = (icon, allowSimpleName) => {\n    if (!icon) {\n        return false;\n    }\n    return !!((icon.provider === '' || icon.provider.match(index_1.matchName)) &&\n        ((allowSimpleName && icon.prefix === '') ||\n            icon.prefix.match(index_1.matchName)) &&\n        icon.name.match(index_1.matchName));\n};\nexports.validateIcon = validateIcon;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.iconToSVG = void 0;\nconst size_1 = require(\"./size\");\n/**\n * Get preserveAspectRatio value\n */\nfunction preserveAspectRatio(props) {\n    let result = '';\n    switch (props.hAlign) {\n        case 'left':\n            result += 'xMin';\n            break;\n        case 'right':\n            result += 'xMax';\n            break;\n        default:\n            result += 'xMid';\n    }\n    switch (props.vAlign) {\n        case 'top':\n            result += 'YMin';\n            break;\n        case 'bottom':\n            result += 'YMax';\n            break;\n        default:\n            result += 'YMid';\n    }\n    result += props.slice ? ' slice' : ' meet';\n    return result;\n}\n/**\n * Get SVG attributes and content from icon + customisations\n *\n * Does not generate style to make it compatible with frameworks that use objects for style, such as React.\n * Instead, it generates 'inline' value. If true, rendering engine should add verticalAlign: -0.125em to icon.\n *\n * Customisations should be normalised by platform specific parser.\n * Result should be converted to <svg> by platform specific parser.\n * Use replaceIDs to generate unique IDs for body.\n */\nfunction iconToSVG(icon, customisations) {\n    // viewBox\n    const box = {\n        left: icon.left,\n        top: icon.top,\n        width: icon.width,\n        height: icon.height,\n    };\n    // Body\n    let body = icon.body;\n    // Apply transformations\n    [icon, customisations].forEach((props) => {\n        const transformations = [];\n        const hFlip = props.hFlip;\n        const vFlip = props.vFlip;\n        let rotation = props.rotate;\n        // Icon is flipped first, then rotated\n        if (hFlip) {\n            if (vFlip) {\n                rotation += 2;\n            }\n            else {\n                // Horizontal flip\n                transformations.push('translate(' +\n                    (box.width + box.left) +\n                    ' ' +\n                    (0 - box.top) +\n                    ')');\n                transformations.push('scale(-1 1)');\n                box.top = box.left = 0;\n            }\n        }\n        else if (vFlip) {\n            // Vertical flip\n            transformations.push('translate(' +\n                (0 - box.left) +\n                ' ' +\n                (box.height + box.top) +\n                ')');\n            transformations.push('scale(1 -1)');\n            box.top = box.left = 0;\n        }\n        let tempValue;\n        if (rotation < 0) {\n            rotation -= Math.floor(rotation / 4) * 4;\n        }\n        rotation = rotation % 4;\n        switch (rotation) {\n            case 1:\n                // 90deg\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift('rotate(90 ' + tempValue + ' ' + tempValue + ')');\n                break;\n            case 2:\n                // 180deg\n                transformations.unshift('rotate(180 ' +\n                    (box.width / 2 + box.left) +\n                    ' ' +\n                    (box.height / 2 + box.top) +\n                    ')');\n                break;\n            case 3:\n                // 270deg\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift('rotate(-90 ' + tempValue + ' ' + tempValue + ')');\n                break;\n        }\n        if (rotation % 2 === 1) {\n            // Swap width/height and x/y for 90deg or 270deg rotation\n            if (box.left !== 0 || box.top !== 0) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) {\n            body =\n                '<g transform=\"' +\n                    transformations.join(' ') +\n                    '\">' +\n                    body +\n                    '</g>';\n        }\n    });\n    // Calculate dimensions\n    let width, height;\n    if (customisations.width === null && customisations.height === null) {\n        // Set height to '1em', calculate width\n        height = '1em';\n        width = (0, size_1.calculateSize)(height, box.width / box.height);\n    }\n    else if (customisations.width !== null &&\n        customisations.height !== null) {\n        // Values are set\n        width = customisations.width;\n        height = customisations.height;\n    }\n    else if (customisations.height !== null) {\n        // Height is set\n        height = customisations.height;\n        width = (0, size_1.calculateSize)(height, box.width / box.height);\n    }\n    else {\n        // Width is set\n        width = customisations.width;\n        height = (0, size_1.calculateSize)(width, box.height / box.width);\n    }\n    // Check for 'auto'\n    if (width === 'auto') {\n        width = box.width;\n    }\n    if (height === 'auto') {\n        height = box.height;\n    }\n    // Convert to string\n    width = typeof width === 'string' ? width : width + '';\n    height = typeof height === 'string' ? height : height + '';\n    // Result\n    const result = {\n        attributes: {\n            width,\n            height,\n            preserveAspectRatio: preserveAspectRatio(customisations),\n            viewBox: box.left + ' ' + box.top + ' ' + box.width + ' ' + box.height,\n        },\n        body,\n    };\n    if (customisations.inline) {\n        result.inline = true;\n    }\n    return result;\n}\nexports.iconToSVG = iconToSVG;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.calculateSize = void 0;\n/**\n * Regular expressions for calculating dimensions\n */\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\n/**\n * Calculate second dimension when only 1 dimension is set\n */\nfunction calculateSize(size, ratio, precision) {\n    if (ratio === 1) {\n        return size;\n    }\n    precision = precision === void 0 ? 100 : precision;\n    if (typeof size === 'number') {\n        return Math.ceil(size * ratio * precision) / precision;\n    }\n    if (typeof size !== 'string') {\n        return size;\n    }\n    // Split code into sets of strings and numbers\n    const oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) {\n        return size;\n    }\n    const newParts = [];\n    let code = oldParts.shift();\n    let isNumber = unitsTest.test(code);\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (isNumber) {\n            const num = parseFloat(code);\n            if (isNaN(num)) {\n                newParts.push(code);\n            }\n            else {\n                newParts.push(Math.ceil(num * ratio * precision) / precision);\n            }\n        }\n        else {\n            newParts.push(code);\n        }\n        // next\n        code = oldParts.shift();\n        if (code === void 0) {\n            return newParts.join('');\n        }\n        isNumber = !isNumber;\n    }\n}\nexports.calculateSize = calculateSize;\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}"],"names":[],"sourceRoot":""}