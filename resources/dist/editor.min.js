/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/scripts/editor/mini-blocks/index.ts":
/*!*******************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/index.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerBlocks": () => (/* binding */ registerBlocks)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/blocks */ "@wordpress/blocks");
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _latest_news__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./latest-news */ "./resources/scripts/editor/mini-blocks/latest-news/index.ts");
/* harmony import */ var _most_popular__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./most-popular */ "./resources/scripts/editor/mini-blocks/most-popular/index.ts");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Gutenberg Blocks
 *
 * All blocks related JavaScript files should be imported here.
 * You can create a new block folder in this dir and include code
 * for that block here as well.
 *
 * All blocks should be included here since this is the file that
 * Webpack is compiling as the input file.
 */

/**
 * WordPress dependencies
 */
 // Register Mini Blocks


 // import * as gpmaincontent from './dynamic-gp-main-content';

function registerBlocks() {
  [_latest_news__WEBPACK_IMPORTED_MODULE_2__, _most_popular__WEBPACK_IMPORTED_MODULE_3__].forEach(function (block) {
    if (!block) {// return;
    }

    var name = block.name,
        category = block.category,
        settings = block.settings;
    (0,_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__.registerBlockType)("".concat(name), _objectSpread({
      category: category
    }, settings));
  });
}
registerBlocks();

/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/latest-news/edit.tsx":
/*!*******************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/latest-news/edit.tsx ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */

 // import HologramNewsCalouselTemplate from './templates/hologramNewsCalouselTemplate';

/**
 * Block edit function
 */
var Edit = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Edit, _Component);

  var _super = _createSuper(Edit);

  function Edit(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Edit);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Edit, [{
    key: "render",
    value: function render() {
      var className = this.props.attributes.className;
      return /*#__PURE__*/React.createElement("div", {
        className: className
      }, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__.InnerBlocks // renderAppender={ InnerBlocks.ButtonBlockAppender }
      , null));
    }
  }]);

  return Edit;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Edit);

/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/latest-news/index.ts":
/*!*******************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/latest-news/index.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "category": () => (/* binding */ category),
/* harmony export */   "settings": () => (/* binding */ settings)
/* harmony export */ });
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _block_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./block.json */ "./resources/scripts/editor/mini-blocks/latest-news/block.json");
/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edit */ "./resources/scripts/editor/mini-blocks/latest-news/edit.tsx");
/* harmony import */ var _save__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./save */ "./resources/scripts/editor/mini-blocks/latest-news/save.tsx");
/* harmony import */ var _editor_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor.scss */ "./resources/scripts/editor/mini-blocks/latest-news/editor.scss");
/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style.scss */ "./resources/scripts/editor/mini-blocks/latest-news/style.scss");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Style dependencies
 */



/**
 * Block constants
 */

var name = _block_json__WEBPACK_IMPORTED_MODULE_1__.name,
    category = _block_json__WEBPACK_IMPORTED_MODULE_1__.category,
    attributes = _block_json__WEBPACK_IMPORTED_MODULE_1__.attributes,
    supports = _block_json__WEBPACK_IMPORTED_MODULE_1__.supports;
var settings = {
  title: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('mini latest-news', 'gameplayblocks'),
  description: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('latest news mini block.', 'gameplayblocks'),
  icon: 'editor-kitchensink',
  keywords: [(0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('container', 'gameplayblocks'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('wrapper', 'gameplayblocks'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('section', 'gameplayblocks')],
  attributes: attributes,
  supports: supports,
  edit: _edit__WEBPACK_IMPORTED_MODULE_2__["default"],
  save: _save__WEBPACK_IMPORTED_MODULE_3__["default"]
};


/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/latest-news/save.tsx":
/*!*******************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/latest-news/save.tsx ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */



/**
 * Block edit function
 */
var Save = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Save, _Component);

  var _super = _createSuper(Save);

  function Save(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Save);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Save, [{
    key: "render",
    value: function render() {
      var className = this.props.attributes.className;
      return /*#__PURE__*/React.createElement("div", {
        className: className
      }, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__.InnerBlocks.Content, null));
    }
  }]);

  return Save;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Save);

/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/most-popular/edit.tsx":
/*!********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/most-popular/edit.tsx ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */



/**
 * Block edit function
 */
var Edit = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Edit, _Component);

  var _super = _createSuper(Edit);

  function Edit(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Edit);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Edit, [{
    key: "render",
    value: function render() {
      var className = this.props.attributes.className;
      return /*#__PURE__*/React.createElement("div", {
        className: className
      }, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__.InnerBlocks // renderAppender={ InnerBlocks.ButtonBlockAppender }
      , null));
    }
  }]);

  return Edit;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Edit);

/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/most-popular/index.ts":
/*!********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/most-popular/index.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "category": () => (/* binding */ category),
/* harmony export */   "settings": () => (/* binding */ settings)
/* harmony export */ });
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _block_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./block.json */ "./resources/scripts/editor/mini-blocks/most-popular/block.json");
/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edit */ "./resources/scripts/editor/mini-blocks/most-popular/edit.tsx");
/* harmony import */ var _save__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./save */ "./resources/scripts/editor/mini-blocks/most-popular/save.tsx");
/* harmony import */ var _editor_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor.scss */ "./resources/scripts/editor/mini-blocks/most-popular/editor.scss");
/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style.scss */ "./resources/scripts/editor/mini-blocks/most-popular/style.scss");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Style dependencies
 */



/**
 * Block constants
 */

var name = _block_json__WEBPACK_IMPORTED_MODULE_1__.name,
    category = _block_json__WEBPACK_IMPORTED_MODULE_1__.category,
    attributes = _block_json__WEBPACK_IMPORTED_MODULE_1__.attributes,
    supports = _block_json__WEBPACK_IMPORTED_MODULE_1__.supports;
var settings = {
  title: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('most-popular', 'gameplayblocks'),
  description: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Provide custom container.', 'gameplayblocks'),
  icon: 'editor-kitchensink',
  keywords: [(0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('most-popular', 'gameplayblocks'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('wrapper', 'gameplayblocks'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('section', 'gameplayblocks')],
  attributes: attributes,
  supports: supports,
  edit: _edit__WEBPACK_IMPORTED_MODULE_2__["default"],
  save: _save__WEBPACK_IMPORTED_MODULE_3__["default"]
};


/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/most-popular/save.tsx":
/*!********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/most-popular/save.tsx ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */



/**
 * Block edit function
 */
var Save = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Save, _Component);

  var _super = _createSuper(Save);

  function Save(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Save);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Save, [{
    key: "render",
    value: function render() {
      var className = this.props.attributes.className;
      return /*#__PURE__*/React.createElement("div", {
        className: className
      }, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__.InnerBlocks.Content, null));
    }
  }]);

  return Save;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Save);

/***/ }),

/***/ "./resources/scripts/editor/sbirdThemeBuilder.tsx":
/*!********************************************************!*\
  !*** ./resources/scripts/editor/sbirdThemeBuilder.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _wordpress_plugins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/plugins */ "@wordpress/plugins");
/* harmony import */ var _wordpress_plugins__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_wordpress_plugins__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _wordpress_data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @wordpress/data */ "@wordpress/data");
/* harmony import */ var _wordpress_data__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_wordpress_data__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @wordpress/compose */ "@wordpress/compose");
/* harmony import */ var _wordpress_compose__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_wordpress_compose__WEBPACK_IMPORTED_MODULE_8__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




 // import { FC } from "react";
// let data = wp.data.select("core/editor").getEditorBlocks();
// console.log( data )
// let fs = require("fs");
// fs.writeFile( testt , dictstring )
//  new File( data , absolutePluginsDirPath +"/blueprints/test.json",
//  	{ type: "application/json"},
//  )
// console.log( absolutePluginsDirPath );
// generic  ComponentType  {
// 	className: string;
// 	attributes: {};
// 	setAttributes: any;
// }

var SbirdThemeBuilder = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(SbirdThemeBuilder, _Component);

  var _super = _createSuper(SbirdThemeBuilder);

  function SbirdThemeBuilder(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, SbirdThemeBuilder);

    return _super.call(this, props); //      this.state = {
    //         test: '',
    //      }
    //      console.log("test working 1");
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(SbirdThemeBuilder, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {// console.log("test working 2");
      // const Page = useSelect(
      //     ( select ) => {
      //         return select( 'core/edit-site' ).getPage();    
      //     },
      //         []
      //     );
      //     let select = wp.data.select( 'core/editor' );
      //     let isSavingPost = select.isSavingPost();
      //     let isAutoSaving = select.isAutosavingPost();
      //     let didPostSaveRequestSucceed = select.didPostSaveRequestSucceed();
      //     if ( isSavingPost || isAutoSaving && didPostSaveRequestSucceed ) {
      //         console.log("isSavingPost && !isAutosavingPost && didPostSaveRequestSucceed");
      //         // unsubscribe();
      //         let currentPostId = wp.data.select("core/editor").getCurrentPostId();
      //         let currentPostTitle = wp.data.select("core/editor").getCurrentPost().title;
      //         let currentPostType = wp.data.select("core/editor").getCurrentPostType()
      //         let currentPostAttributes = wp.data.select("core/editor").getEditorBlocks();
      //         // wp.data.select( 'core/block-editor' ).getSettings()
      //         //bluePrint full
      //         let blueprintData = {
      //             currentPostId: currentPostId,
      //             currentPostTitle: currentPostTitle,
      //             currentPostType: currentPostType,
      //             postAttributes: currentPostAttributes,
      //         };
      //         console.log( blueprintData )
      //         apiFetch( { 
      //             path: '/blueprints/v2/blueprint',
      //             method: "POST",
      //             headers: { 
      //                 'Content-type': 'application/json',
      //                 'X-WP-Nonce': wpApiSettings.nonce
      //             },
      //             'credentials': 'same-origin',
      //             data: { blueprint: blueprintData }
      //         } )       
      //         .then( res => 
      //             console.log( res )
      //         ).catch( err => {
      //             console.log( err );
      //         } )
      //     }
    } // const unsubscribe = wp.data.subscribe( () => {
    // } )

  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/React.createElement(React.Fragment, null);
    }
  }]);

  return SbirdThemeBuilder;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component); // const { settings, templateType, page, deviceType } = useSelect(
//     ( select ) => {
//         const {
//             getSettings,
//             getEditedPostType,
//             getPage,
//             __experimentalGetPreviewDeviceType,
//         } = select( 'core/edit-site' );
//         return {
//             settings: getSettings( setIsInserterOpen ),
//             templateType: getEditedPostType(),
//             page: getPage(),
//             deviceType: __experimentalGetPreviewDeviceType(),
//         };
//     },
//     []
// );
// console.log(settings, templateType, page, deviceType);
// function Effect( props: any ) {
//     const Page = useSelect(
//         ( select ) => {
//             return select( 'core/edit-site' ).getPage();    
//         },
//             []
//         );
//         console.log( "test 3" );
//         return Page;
//     }
// function BlockCount() {
//     const count = useSelect( ( select ) => {
//       return select( 'core/block-editor' ).getBlockCount()
//     }, [] );
//     return count;
//   }


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_wordpress_compose__WEBPACK_IMPORTED_MODULE_8__.compose)([(0,_wordpress_data__WEBPACK_IMPORTED_MODULE_7__.withSelect)(function (select, props) {
  console.log(select('core/block-editor').getBlockCount());
  return select('core/block-editor').getBlockCount();
})])(SbirdThemeBuilder));
(0,_wordpress_plugins__WEBPACK_IMPORTED_MODULE_6__.registerPlugin)('sbird-core-additions', {
  icon: "admin-appearance",
  render: SbirdThemeBuilder
});

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/footer/edit.tsx":
/*!***************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/footer/edit.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */

 // import { ApolloProvider } from '@apollo/client';
// import Outlineclient from '../../apollo/clients/OutlineClient';
// import { any, string } from 'prop-types';

/**
 * Block edit function
 */
var Edit = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Edit, _Component);

  var _super = _createSuper(Edit);

  function Edit(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Edit);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Edit, [{
    key: "render",
    value: function render() {
      var attributes = this.props.attributes;
      var templates = {
        "cleanreddredmp": [['gameplayblocks/postslist', {
          className: 'tw-bg-yellow-500'
        }], ['gameplayblocks/gpmaincontent', {
          className: 'tw-bg-green-500'
        }]],
        "modernflat": [['gameplayblocks/postslist', {
          className: 'tw-bg-blue-500'
        }], ['core/cover', {
          className: 'tw-bg-red-500'
        }], ['gameplayblocks/gpmaincontent', {
          className: 'tw-bg-orange-500'
        }]]
      }; // const activeTemplate: string = templates[ attributes.currentTheme ];

      return (
        /*#__PURE__*/
        // <ApolloProvider  client={ Outlineclient } >
        React.createElement("div", {
          className: attributes.className
        }, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__.InnerBlocks, {
          templateInsertUpdatesSelection: true // allowedBlocks={ true } 
          // template={ activeTemplate }

        }))
        /* </ApolloProvider> */

      );
    }
  }]);

  return Edit;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Edit);

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/footer/index.ts":
/*!***************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/footer/index.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "category": () => (/* binding */ category),
/* harmony export */   "settings": () => (/* binding */ settings)
/* harmony export */ });
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _block_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./block.json */ "./resources/scripts/editor/super-blocks/footer/block.json");
/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edit */ "./resources/scripts/editor/super-blocks/footer/edit.tsx");
/* harmony import */ var _save__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./save */ "./resources/scripts/editor/super-blocks/footer/save.tsx");
/* harmony import */ var _editor_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor.scss */ "./resources/scripts/editor/super-blocks/footer/editor.scss");
/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style.scss */ "./resources/scripts/editor/super-blocks/footer/style.scss");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Style dependencies
 */



/**
 * Block constants
 */

var name = _block_json__WEBPACK_IMPORTED_MODULE_1__.name,
    category = _block_json__WEBPACK_IMPORTED_MODULE_1__.category,
    attributes = _block_json__WEBPACK_IMPORTED_MODULE_1__.attributes,
    supports = _block_json__WEBPACK_IMPORTED_MODULE_1__.supports;
var settings = {
  title: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('footer', 'gameplay blocks'),
  description: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('provide outline container.', 'gameplay blocks'),
  icon: 'editor-kitchensink',
  keywords: [(0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('container', 'block-builder'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('wrapper', 'block-builder'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('section', 'block-builder')],
  attributes: attributes,
  supports: supports,
  edit: _edit__WEBPACK_IMPORTED_MODULE_2__["default"],
  save: _save__WEBPACK_IMPORTED_MODULE_3__["default"]
};


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/footer/save.tsx":
/*!***************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/footer/save.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */



/**
 * Block edit function
 */
var Save = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Save, _Component);

  var _super = _createSuper(Save);

  function Save(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Save);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Save, [{
    key: "render",
    value: function render() {
      // let blockProps <T>( arg: T ) = useBlockProps.save();
      return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__.InnerBlocks.Content, null));
    }
  }]);

  return Save;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Save);

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/header/edit.tsx":
/*!***************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/header/edit.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * External dependencies
 */
// import { isUndefined, pickBy, map } from 'lodash';
// import classnames from 'classnames';
// import moment from 'moment';

/**
 * Internal dependencies
 */

/**
 * WordPress dependencies
 */


/**
 * Block edit function
 */
var Edit = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Edit, _Component);

  var _super = _createSuper(Edit);

  function Edit(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Edit);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Edit, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          attributes = _this$props.attributes,
          setAttributes = _this$props.setAttributes; // setAttributes( { paged: 1 } );
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          attributes = _this$props2.attributes,
          setAttributes = _this$props2.setAttributes; // Check if there are posts

      return /*#__PURE__*/React.createElement(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Fragment, null, /*#__PURE__*/React.createElement("section", {
        className: attributes.className
      }));
    }
  }]);

  return Edit;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Edit);

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/header/index.ts":
/*!***************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/header/index.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "category": () => (/* binding */ category),
/* harmony export */   "settings": () => (/* binding */ settings)
/* harmony export */ });
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _block_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./block.json */ "./resources/scripts/editor/super-blocks/header/block.json");
/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edit */ "./resources/scripts/editor/super-blocks/header/edit.tsx");
/* harmony import */ var _save__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./save */ "./resources/scripts/editor/super-blocks/header/save.tsx");
/* harmony import */ var _editor_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor.scss */ "./resources/scripts/editor/super-blocks/header/editor.scss");
/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style.scss */ "./resources/scripts/editor/super-blocks/header/style.scss");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Style dependencies
 */



/**
 * Block constants
 */

var name = _block_json__WEBPACK_IMPORTED_MODULE_1__.name,
    category = _block_json__WEBPACK_IMPORTED_MODULE_1__.category,
    attributes = _block_json__WEBPACK_IMPORTED_MODULE_1__.attributes,
    supports = _block_json__WEBPACK_IMPORTED_MODULE_1__.supports;
var settings = {
  title: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Gp Header', 'gameplay-blocks'),
  description: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Display Header of any type ', 'gameplay-blocks'),
  icon: 'excerpt-view',
  keywords: [(0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Header', 'gameplay-blocks'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('site header', 'gameplay-blocks')],
  attributes: attributes,
  supports: supports,
  edit: _edit__WEBPACK_IMPORTED_MODULE_2__["default"],
  save: _save__WEBPACK_IMPORTED_MODULE_3__["default"]
};


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/header/save.tsx":
/*!***************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/header/save.tsx ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @wordpress/block-editor */ "@wordpress/block-editor");
/* harmony import */ var _wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */



/**
 * Block edit function
 */
var Save = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Save, _Component);

  var _super = _createSuper(Save);

  function Save(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Save);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Save, [{
    key: "render",
    value: function render() {
      // let blockProps <T>( arg: T ) = useBlockProps.save();
      return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(_wordpress_block_editor__WEBPACK_IMPORTED_MODULE_6__.InnerBlocks.Content, null));
    }
  }]);

  return Save;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Save);

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/hero/edit.tsx":
/*!*************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/hero/edit.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var svelte_adapter_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! svelte-adapter/react */ "./node_modules/svelte-adapter/react.js");
/* harmony import */ var _admin_components_hero_HeroComponent_svelte__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../admin/components/hero/HeroComponent.svelte */ "./resources/scripts/admin/components/hero/HeroComponent.svelte");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */


 // declare module "svelte-adapter/react";

var baseStyle = {};
var SvelteInReact = (0,svelte_adapter_react__WEBPACK_IMPORTED_MODULE_6__["default"])(_admin_components_hero_HeroComponent_svelte__WEBPACK_IMPORTED_MODULE_7__["default"], baseStyle, "div");

// interface WebComponentProps {
// 	question: string;
// 	fixedBonus: number;
// 	variableBonus: number;
// 	minInvest: number;
// 	maxInvest: number;
//  }

/**
 * Block edit function
 */
//"editorStyle": "file:../../../../dist/styles/editor.min.css"
var Edit = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Edit, _Component);

  var _super = _createSuper(Edit);

  function Edit(props) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Edit);

    return _super.call(this, props);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Edit, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          attributes = _this$props.attributes,
          setAttributes = _this$props.setAttributes;
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
        className: attributes.className
      }, /*#__PURE__*/React.createElement(SvelteInReact, null)));
    }
  }]);

  return Edit;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Edit);

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/hero/index.ts":
/*!*************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/hero/index.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "category": () => (/* binding */ category),
/* harmony export */   "settings": () => (/* binding */ settings),
/* harmony export */   "attributes": () => (/* binding */ attributes)
/* harmony export */ });
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _block_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./block.json */ "./resources/scripts/editor/super-blocks/hero/block.json");
/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edit */ "./resources/scripts/editor/super-blocks/hero/edit.tsx");
/* harmony import */ var _save__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./save */ "./resources/scripts/editor/super-blocks/hero/save.tsx");
/* harmony import */ var _editor_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor.scss */ "./resources/scripts/editor/super-blocks/hero/editor.scss");
/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style.scss */ "./resources/scripts/editor/super-blocks/hero/style.scss");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Style dependencies
 */



/**
 * Block constants
 */

var name = _block_json__WEBPACK_IMPORTED_MODULE_1__.name,
    category = _block_json__WEBPACK_IMPORTED_MODULE_1__.category,
    attributes = _block_json__WEBPACK_IMPORTED_MODULE_1__.attributes,
    supports = _block_json__WEBPACK_IMPORTED_MODULE_1__.supports; // declare module  props {
// 	attributes: {
// 		className: string,
// 		content: string,
// 		currentTheme: string,
// 	};
// }
// function writeFile( filePath ) {
// 	const csvHeaders = 'name,quantity,price';
// 	fs.writeFile( filePath,  csvHeaders, { type: "application/json"} ,function(err) {
// 			if (err) throw err;
// 			fs.readFile(filePath, 'utf-8', function(err, data) {
// 				console.log(data);
// 			}	)
// 		}
// 	)
// }
// let filetest =  absolutePluginsDirPath + "/blueprints/test.json";
// console.log( filetest )
// writeFile( filetest )

var settings = {
  title: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Hero', 'gameplay blocks'),
  description: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Hero block', 'gameplay blocks'),
  icon: 'editor-kitchensink',
  keywords: [(0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('hero', 'gameplay-blocks'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('wrapper', 'block-builder'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('section', 'block-builder')],
  attributes: attributes,
  supports: supports,
  edit: _edit__WEBPACK_IMPORTED_MODULE_2__["default"],
  save: _save__WEBPACK_IMPORTED_MODULE_3__["default"]
};


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/hero/save.tsx":
/*!*************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/hero/save.tsx ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */
 // import { InnerBlocks } from '@wordpress/block-editor';

/**
 * Block edit function
 */
var Save = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Save, _Component);

  var _super = _createSuper(Save);

  function Save() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Save);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Save, [{
    key: "componentDidMount",
    value: function componentDidMount() {// let testt =  path.resolve('./blueprints/test.json');
      // console.log( testt )
      // async function writeFile( filePath ) {
      // 	try {
      // 		const csvHeaders = 'name,quantity,price';
      // 		await fs.writeFile( filePath,  csvHeaders )
      // 	} catch ( error ) {
      // 		console.error(`Got an error trying to write to a file: ${error.message}`);
      // 	}
      // }
      // writeFile( testt );
      // function writeFile( filePath ) {
      // 	const csvHeaders = 'name,quantity,price';
      // 	fs.writeFile( filePath,  csvHeaders, { type: "application/json"} ,function(err) {
      // 			if (err) throw err;
      // 			fs.readFile(filePath, 'utf-8', function(err, data) {
      // 				console.log(data);
      // 			}	)
      // 		}
      // 	)
      // }
      // let filetest =  absolutePluginsDirPath + +"/blueprints/test.json";
      // writeFile( filetest )
    }
  }, {
    key: "render",
    value: function render() {
      // const { className  } = this.props;
      // let dictstring = JSON.stringify(dict);
      // // const blockProps = useBlockProps.save();
      // let dict = {"one" : [15, 4.5],
      //     "two" : [34, 3.3],
      //     "three" : [67, 5.0],
      //     "four" : [32, 4.1]};
      // let testt =  'blueprints/test.json';
      // console.log( testt )
      // wp.data.select("core/editor").getEditorBlocks()
      // // let fs = require("fs");
      // // fs.writeFile( testt , dictstring )
      // //  new File( ["hello working"], "blueprints/test.json",
      // //  	{ type: "application/json"},
      // //  )
      return /*#__PURE__*/React.createElement("section", {
        className: "gp-hero-wrapper"
      });
    }
  }]);

  return Save;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Save);

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/index.ts":
/*!********************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerBlocks": () => (/* binding */ registerBlocks)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/blocks */ "@wordpress/blocks");
/* harmony import */ var _wordpress_blocks__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _footer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./footer */ "./resources/scripts/editor/super-blocks/footer/index.ts");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./header */ "./resources/scripts/editor/super-blocks/header/index.ts");
/* harmony import */ var _main_content__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./main-content */ "./resources/scripts/editor/super-blocks/main-content/index.ts");
/* harmony import */ var _hero__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hero */ "./resources/scripts/editor/super-blocks/hero/index.ts");


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Gutenberg Blocks
 *
 * All blocks related JavaScript files should be imported here.
 * You can create a new block folder in this dir and include code
 * for that block here as well.
 *
 * All blocks should be included here since this is the file that
 * Webpack is compiling as the input file.
 */

/**
 * WordPress dependencies
 */
 // Register Blocks
// import * as postslists from './dynamic-postslist';




 // You can specify which plugins you need
// import { Tooltip, Toast, Popover } from 'bootstrap';
// import "./scss/main.scss"
// First we get the viewport height and we multiple it by 1% to get a value for a vh unit

var vh = window.innerHeight * 0.01; // Then we set the value in the --vh custom property to the root of the document

document.documentElement.style.setProperty('--vh', "".concat(vh, "px"));
var vw = window.innerWidth * 0.01;
document.documentElement.style.setProperty('--vw', "".concat(vw, "px"));

if (vw > vh) {
  document.documentElement.style.setProperty('--vmin', "".concat(vw, "px"));
} else {
  document.documentElement.style.setProperty('--vmin', "".concat(vh, "px"));
}

function registerBlocks() {
  [_header__WEBPACK_IMPORTED_MODULE_3__, _footer__WEBPACK_IMPORTED_MODULE_2__, _main_content__WEBPACK_IMPORTED_MODULE_4__, _hero__WEBPACK_IMPORTED_MODULE_5__].forEach(function (block) {
    if (!block) {// return;
    }

    var name = block.name,
        category = block.category,
        settings = block.settings;
    (0,_wordpress_blocks__WEBPACK_IMPORTED_MODULE_1__.registerBlockType)("".concat(name), _objectSpread({
      category: category
    }, settings));
  });
}
registerBlocks();

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/main-content/edit.tsx":
/*!*********************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/main-content/edit.tsx ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

/**
 * WordPress dependencies
 */
// import { gql, useQuery } from '@apollo/client';
// import INITIAL_QUERY from '../../apollo/queries/initialStateQuery';

/**
 * Block edit function
 */
var Edit = function Edit() {
  // const { loading, error, data } = useQuery( INITIAL_QUERY );
  // if (loading) return 'Loading...';
  // if (error) return `Error! ${error.message}`;
  // console.log(loading, error, data)
  return /*#__PURE__*/React.createElement("div", {
    className: "gp-main-content"
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Edit);

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/main-content/index.ts":
/*!*********************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/main-content/index.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "category": () => (/* binding */ category),
/* harmony export */   "settings": () => (/* binding */ settings)
/* harmony export */ });
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wordpress/i18n */ "@wordpress/i18n");
/* harmony import */ var _wordpress_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _block_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./block.json */ "./resources/scripts/editor/super-blocks/main-content/block.json");
/* harmony import */ var _edit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edit */ "./resources/scripts/editor/super-blocks/main-content/edit.tsx");
/* harmony import */ var _save__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./save */ "./resources/scripts/editor/super-blocks/main-content/save.tsx");
/* harmony import */ var _editor_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./editor.scss */ "./resources/scripts/editor/super-blocks/main-content/editor.scss");
/* harmony import */ var _style_scss__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style.scss */ "./resources/scripts/editor/super-blocks/main-content/style.scss");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */




/**
 * Style dependencies
 */



/**
 * Block constants
 */

var name = _block_json__WEBPACK_IMPORTED_MODULE_1__.name,
    category = _block_json__WEBPACK_IMPORTED_MODULE_1__.category,
    attributes = _block_json__WEBPACK_IMPORTED_MODULE_1__.attributes,
    supports = _block_json__WEBPACK_IMPORTED_MODULE_1__.supports;
var settings = {
  title: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Main Content', 'gameplayblocks'),
  description: (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('Display posts list with defined number of items to be shown.', 'gameplayblocks'),
  icon: 'excerpt-view',
  keywords: [(0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('posts', 'gameplayblocks'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('post', 'gameplayblocks'), (0,_wordpress_i18n__WEBPACK_IMPORTED_MODULE_0__.__)('blog', 'gameplayblocks')],
  attributes: attributes,
  supports: supports,
  edit: _edit__WEBPACK_IMPORTED_MODULE_2__["default"],
  save: _save__WEBPACK_IMPORTED_MODULE_3__["default"]
};


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/main-content/save.tsx":
/*!*********************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/main-content/save.tsx ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wordpress/element */ "@wordpress/element");
/* harmony import */ var _wordpress_element__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * WordPress dependencies
 */


/**
 * Block edit function
 */
var Save = /*#__PURE__*/function (_Component) {
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__["default"])(Save, _Component);

  var _super = _createSuper(Save);

  function Save() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Save);

    return _super.apply(this, arguments);
  }

  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Save, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/React.createElement("div", {
        className: "gp-main-content"
      });
    }
  }]);

  return Save;
}(_wordpress_element__WEBPACK_IMPORTED_MODULE_5__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Save);

/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/latest-news/editor.scss":
/*!**********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/latest-news/editor.scss ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/latest-news/style.scss":
/*!*********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/latest-news/style.scss ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/most-popular/editor.scss":
/*!***********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/most-popular/editor.scss ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/most-popular/style.scss":
/*!**********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/most-popular/style.scss ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/footer/editor.scss":
/*!******************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/footer/editor.scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/footer/style.scss":
/*!*****************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/footer/style.scss ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/header/editor.scss":
/*!******************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/header/editor.scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/header/style.scss":
/*!*****************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/header/style.scss ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/hero/editor.scss":
/*!****************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/hero/editor.scss ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/hero/style.scss":
/*!***************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/hero/style.scss ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/main-content/editor.scss":
/*!************************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/main-content/editor.scss ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/scripts/editor/super-blocks/main-content/style.scss":
/*!***********************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/main-content/style.scss ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/styles/admin/index.scss":
/*!*******************************************!*\
  !*** ./resources/styles/admin/index.scss ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/@iconify-icons/heroicons-solid/arrow-circle-left.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@iconify-icons/heroicons-solid/arrow-circle-left.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var data = {
	"body": "<g fill=\"none\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10 18a8 8 0 1 0 0-16a8 8 0 0 0 0 16zm.707-10.293a1 1 0 0 0-1.414-1.414l-3 3a1 1 0 0 0 0 1.414l3 3a1 1 0 0 0 1.414-1.414L9.414 11H13a1 1 0 1 0 0-2H9.414l1.293-1.293z\" fill=\"currentColor\"/></g>",
	"width": 20,
	"height": 20
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (data);


/***/ }),

/***/ "./node_modules/@iconify-icons/heroicons-solid/arrow-circle-right.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@iconify-icons/heroicons-solid/arrow-circle-right.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var data = {
	"body": "<g fill=\"none\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M10 18a8 8 0 1 0 0-16a8 8 0 0 0 0 16zm3.707-8.707l-3-3a1 1 0 0 0-1.414 1.414L10.586 9H7a1 1 0 1 0 0 2h3.586l-1.293 1.293a1 1 0 1 0 1.414 1.414l3-3a1 1 0 0 0 0-1.414z\" fill=\"currentColor\"/></g>",
	"width": 20,
	"height": 20
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (data);


/***/ }),

/***/ "./node_modules/@iconify/icons-jam/play-circle.js":
/*!********************************************************!*\
  !*** ./node_modules/@iconify/icons-jam/play-circle.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

var data = {
	"body": "<path d=\"M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10s-4.477 10-10 10zm0-2a8 8 0 1 0 0-16a8 8 0 0 0 0 16zm4.126-6.254l-4.055 2.898c-.905.646-2.13.389-2.737-.576A2.201 2.201 0 0 1 9 14.898V9.102C9 7.942 9.883 7 10.972 7c.391 0 .774.124 1.099.356l4.055 2.898c.905.647 1.146 1.952.54 2.917a2.042 2.042 0 0 1-.54.575zm-5.154-4.644v5.796L15.027 12l-4.055-2.898z\" fill=\"currentColor\"/>",
	"width": 24,
	"height": 24
};
exports.__esModule = true;
exports["default"] = data;


/***/ }),

/***/ "./node_modules/svelte-adapter/react.js":
/*!**********************************************!*\
  !*** ./node_modules/svelte-adapter/react.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((Component, style = {}, tag = "span") => props => {
  const container = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const component = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const [mounted, setMount] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const eventRe = /on([A-Z]{1,}[a-zA-Z]*)/;
    const watchRe = /watch([A-Z]{1,}[a-zA-Z]*)/;

    component.current = new Component({ target: container.current, props });

    let watchers = [];
    for (const key in props) {
      const eventMatch = key.match(eventRe);
      const watchMatch = key.match(watchRe);

      if (eventMatch && typeof props[key] === "function") {
        component.current.$on(
          `${eventMatch[1][0].toLowerCase()}${eventMatch[1].slice(1)}`,
          props[key]
        );
      }

      if (watchMatch && typeof props[key] === "function") {
        watchers.push([
          `${watchMatch[1][0].toLowerCase()}${watchMatch[1].slice(1)}`,
          props[key]
        ]);
      }
    }

    if (watchers.length) {
      const update = component.current.$$.update;
      component.current.$$.update = function() {
        watchers.forEach(([name, callback]) => {
          const index = component.current.$$.props[name];
          callback(component.current.$$.ctx[index]);
        });
        update.apply(null, arguments);
      };
    }

    return () => {
      component.current.$destroy();
    };
  }, []);

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!mounted) {
      setMount(true);
      return;
    }

    component.current.$set(props);
  }, [props]);

  return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(tag, { ref: container, style });
});


/***/ }),

/***/ "./resources/scripts/admin/components/hero/HeroComponent.svelte":
/*!**********************************************************************!*\
  !*** ./resources/scripts/admin/components/hero/HeroComponent.svelte ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var _iconify_svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iconify/svelte */ "./node_modules/@iconify/svelte/dist/index.mjs");
/* harmony import */ var _iconify_icons_heroicons_solid_arrow_circle_right__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iconify-icons/heroicons-solid/arrow-circle-right */ "./node_modules/@iconify-icons/heroicons-solid/arrow-circle-right.js");
/* harmony import */ var _iconify_icons_heroicons_solid_arrow_circle_left__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iconify-icons/heroicons-solid/arrow-circle-left */ "./node_modules/@iconify-icons/heroicons-solid/arrow-circle-left.js");
/* harmony import */ var _iconify_icons_jam_play_circle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @iconify/icons-jam/play-circle */ "./node_modules/@iconify/icons-jam/play-circle.js");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var svelte_easing__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! svelte/easing */ "./node_modules/svelte/easing/index.mjs");
/* harmony import */ var _templates_CleanReddredmpTheme_Theme_svelte__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./templates/CleanReddredmpTheme/Theme.svelte */ "./resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/Theme.svelte");
/* resources/scripts/admin/components/hero/HeroComponent.svelte generated by Svelte v3.43.1 */


const { console: console_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;








const file = "resources/scripts/admin/components/hero/HeroComponent.svelte";

// (23:5) {#if show == true }
function create_if_block(ctx) {
	let h1;
	let h1_intro;
	let h1_outro;
	let current;

	const block = {
		c: function create() {
			h1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("h1");
			h1.textContent = "test";
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(h1, file, 23, 9, 819);
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, h1, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (h1_outro) h1_outro.end(1);
				h1_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(h1, svelte_transition__WEBPACK_IMPORTED_MODULE_6__.scale, {});
				h1_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			if (h1_intro) h1_intro.invalidate();
			h1_outro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_out_transition)(h1, svelte_transition__WEBPACK_IMPORTED_MODULE_6__.fade, {});
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(h1);
			if (detaching && h1_outro) h1_outro.end();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(23:5) {#if show == true }",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let section;
	let button;
	let t1;
	let t2;
	let p;
	let current;
	let mounted;
	let dispose;
	let if_block = /*show*/ ctx[0] == true && create_if_block(ctx);

	const block = {
		c: function create() {
			section = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("section");
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			button.textContent = "click me";
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block) if_block.c();
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			p = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			p.textContent = "Paragraph";
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 21, 5, 727);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p, file, 25, 4, 867);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(section, "class", "gp-hero__grid gp-hero ");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(section, file, 18, 2, 573);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, section, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(section, button);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(section, t1);
			if (if_block) if_block.m(section, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(section, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(section, p);
			current = true;

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", /*click_handler*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*show*/ ctx[0] == true) {
				if (if_block) {
					if (dirty & /*show*/ 1) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(section, t2);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(section);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('HeroComponent', slots, []);
	let show = false;

	setInterval(
		() => {
			
		},
		1000
	);

	let { ComponentTypeName = "portal" } = $$props;
	let { ComponentStyle = "classic-clean-white-style" } = $$props;
	console.log(_templates_CleanReddredmpTheme_Theme_svelte__WEBPACK_IMPORTED_MODULE_8__["default"]);
	const writable_props = ['ComponentTypeName', 'ComponentStyle'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<HeroComponent> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, show = !show);

	$$self.$$set = $$props => {
		if ('ComponentTypeName' in $$props) $$invalidate(1, ComponentTypeName = $$props.ComponentTypeName);
		if ('ComponentStyle' in $$props) $$invalidate(2, ComponentStyle = $$props.ComponentStyle);
	};

	$$self.$capture_state = () => ({
		fade: svelte_transition__WEBPACK_IMPORTED_MODULE_6__.fade,
		scale: svelte_transition__WEBPACK_IMPORTED_MODULE_6__.scale,
		show,
		ComponentTypeName,
		ComponentStyle,
		Theme: _templates_CleanReddredmpTheme_Theme_svelte__WEBPACK_IMPORTED_MODULE_8__["default"]
	});

	$$self.$inject_state = $$props => {
		if ('show' in $$props) $$invalidate(0, show = $$props.show);
		if ('ComponentTypeName' in $$props) $$invalidate(1, ComponentTypeName = $$props.ComponentTypeName);
		if ('ComponentStyle' in $$props) $$invalidate(2, ComponentStyle = $$props.ComponentStyle);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [show, ComponentTypeName, ComponentStyle, click_handler];
}

class HeroComponent extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { ComponentTypeName: 1, ComponentStyle: 2 });

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "HeroComponent",
			options,
			id: create_fragment.name
		});
	}

	get ComponentTypeName() {
		throw new Error("<HeroComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ComponentTypeName(value) {
		throw new Error("<HeroComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ComponentStyle() {
		throw new Error("<HeroComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ComponentStyle(value) {
		throw new Error("<HeroComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HeroComponent);

/***/ }),

/***/ "./resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/Theme.svelte":
/*!********************************************************************************************!*\
  !*** ./resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/Theme.svelte ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var _iconify_svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iconify/svelte */ "./node_modules/@iconify/svelte/dist/index.mjs");
/* harmony import */ var _iconify_icons_heroicons_solid_arrow_circle_right__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iconify-icons/heroicons-solid/arrow-circle-right */ "./node_modules/@iconify-icons/heroicons-solid/arrow-circle-right.js");
/* harmony import */ var _iconify_icons_heroicons_solid_arrow_circle_left__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iconify-icons/heroicons-solid/arrow-circle-left */ "./node_modules/@iconify-icons/heroicons-solid/arrow-circle-left.js");
/* harmony import */ var _iconify_icons_jam_play_circle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @iconify/icons-jam/play-circle */ "./node_modules/@iconify/icons-jam/play-circle.js");
/* harmony import */ var _portal_type_index_svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./portal-type/index.svelte */ "./resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/portal-type/index.svelte");
/* resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/Theme.svelte generated by Svelte v3.43.1 */







const file = "resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/Theme.svelte";

function create_fragment(ctx) {
	let div;
	let switch_instance;
	let current;
	var switch_value = _portal_type_index_svelte__WEBPACK_IMPORTED_MODULE_5__["default"];

	function switch_props(ctx) {
		return { $$inline: true };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div, file, 7, 0, 279);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div, anchor);

			if (switch_instance) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (switch_value !== (switch_value = _portal_type_index_svelte__WEBPACK_IMPORTED_MODULE_5__["default"])) {
				if (switch_instance) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
					const old_component = switch_instance;

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(old_component.$$.fragment, 1, 0, () => {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(old_component, 1);
					});

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, 1);
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div);
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(switch_instance);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('Theme', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Theme> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ ComponentType: _portal_type_index_svelte__WEBPACK_IMPORTED_MODULE_5__["default"] });
	return [];
}

class Theme extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Theme",
			options,
			id: create_fragment.name
		});
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Theme);

/***/ }),

/***/ "./resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/portal-type/index.svelte":
/*!********************************************************************************************************!*\
  !*** ./resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/portal-type/index.svelte ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var _iconify_svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iconify/svelte */ "./node_modules/@iconify/svelte/dist/index.mjs");
/* harmony import */ var _iconify_icons_heroicons_solid_arrow_circle_right__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iconify-icons/heroicons-solid/arrow-circle-right */ "./node_modules/@iconify-icons/heroicons-solid/arrow-circle-right.js");
/* harmony import */ var _iconify_icons_heroicons_solid_arrow_circle_left__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iconify-icons/heroicons-solid/arrow-circle-left */ "./node_modules/@iconify-icons/heroicons-solid/arrow-circle-left.js");
/* harmony import */ var _iconify_icons_jam_play_circle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @iconify/icons-jam/play-circle */ "./node_modules/@iconify/icons-jam/play-circle.js");
/* resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/portal-type/index.svelte generated by Svelte v3.43.1 */






const file = "resources/scripts/admin/components/hero/templates/CleanReddredmpTheme/portal-type/index.svelte";

function create_fragment(ctx) {
	let div10;
	let div1;
	let img0;
	let img0_src_value;
	let t0;
	let div0;
	let span0;
	let t2;
	let a0;
	let t4;
	let div3;
	let img1;
	let img1_src_value;
	let t5;
	let div2;
	let span1;
	let t7;
	let a1;
	let t9;
	let div5;
	let img2;
	let img2_src_value;
	let t10;
	let div4;
	let span2;
	let t12;
	let a2;
	let t14;
	let div7;
	let img3;
	let img3_src_value;
	let t15;
	let div6;
	let a3;
	let iconifyicon;
	let t16;
	let h3;
	let t18;
	let div9;
	let img4;
	let img4_src_value;
	let t19;
	let div8;
	let span3;
	let t21;
	let a4;
	let t23;
	let div13;
	let div12;
	let img5;
	let img5_src_value;
	let t24;
	let div11;
	let button;
	let a5;
	let t26;
	let switch_instance;
	let switch_instance_anchor;
	let current;

	iconifyicon = new _iconify_svelte__WEBPACK_IMPORTED_MODULE_1__["default"]({
			props: {
				icon: _iconify_icons_jam_play_circle__WEBPACK_IMPORTED_MODULE_4__["default"],
				class: "gp-card__play__icon"
			},
			$$inline: true
		});

	var switch_value = /*ComponentTheme*/ ctx[0];

	function switch_props(ctx) {
		return {
			props: {
				type: /*ComponentType*/ ctx[1],
				style: /*ComponentStyle*/ ctx[2]
			},
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			div10 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			img0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			span0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			span0.textContent = "News";
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			a0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");
			a0.textContent = "Red Dead Redemption 2 release date";
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			img1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			span1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			span1.textContent = "News";
			t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			a1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");
			a1.textContent = "Red Dead Redemption 2 release date";
			t9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			img2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t10 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			span2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			span2.textContent = "Report";
			t12 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			a2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");
			a2.textContent = "Just Cause 5";
			t14 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			img3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t15 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			a3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(iconifyicon.$$.fragment);
			t16 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			h3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("h3");
			h3.textContent = "Citzen Con 2948";
			t18 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			img4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t19 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			span3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			span3.textContent = "Review";
			t21 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			a4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");
			a4.textContent = "Reveiw: Breath of the wield";
			t23 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div13 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div12 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			img5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t24 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			div11 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			button = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");
			a5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");
			a5.textContent = "Buy Now";
			t26 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);
			switch_instance_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img0, "class", "gp-card__img gp-card__img--hero");
			if (!(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.src_url_equal)(img0.src, img0_src_value = "http://gameplay.test/wp-content/uploads/2021/05/reddead-redemption.jpgg")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img0, "src", img0_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img0, "alt", "");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(img0, file, 17, 24, 534);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span0, "class", "gp-tag gp-tag--news");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span0, file, 20, 36, 821);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a0, "class", "gp-card__title gp-card__title--hero");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a0, "href", "posts/reddredmp_post.html");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a0, file, 21, 36, 903);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "gp-card__img__overlay gp-card__img__overlay--hero ");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 19, 28, 720);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "gp-card gp-card--hero gp-card--hero__main");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 15, 20, 423);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img1, "class", "gp-card__img gp-card__img--hero");
			if (!(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.src_url_equal)(img1.src, img1_src_value = "http://gameplay.test/wp-content/uploads/2021/05/rtx2080ti.jpg")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img1, "src", img1_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img1, "alt", "");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(img1, file, 28, 24, 1246);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span1, "class", "gp-tag gp-tag--hardware");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span1, file, 31, 28, 1509);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a1, "class", "gp-card__title gp-card__title--hero");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a1, "href", "posts/reddredmp_post.html");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a1, file, 32, 28, 1589);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "gp-card__img__overlay gp-card__img__overlay--hero ");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 30, 24, 1415);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "gp-card gp-card--hero gp-card--hero__other");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 26, 20, 1137);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img2, "class", "gp-card__img gp-card__img--hero");
			if (!(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.src_url_equal)(img2.src, img2_src_value = "./images/just-cause4.jpg")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img2, "src", img2_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img2, "alt", "");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(img2, file, 37, 24, 1888);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span2, "class", "gp-tag gp-tag--report");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span2, file, 40, 28, 2117);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a2, "class", "gp-card__title gp-card__title--hero");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a2, "href", "http://localhost:5000/");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a2, file, 41, 28, 2196);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "gp-card__img__overlay gp-card__img__overlay--hero ");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 39, 24, 2023);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "gp-card gp-card--hero gp-card--hero__other");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 36, 20, 1805);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img3, "class", "gp-card__img gp-card__img--hero");
			if (!(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.src_url_equal)(img3.src, img3_src_value = "./images/CitizenCon-2948-Keynote.jpg")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img3, "src", img3_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img3, "alt", "");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(img3, file, 46, 24, 2454);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a3, "class", "gp-card__play");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a3, "href", "http://localhost:5000/");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a3, file, 49, 28, 2691);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(h3, "class", "gp-card__title gp-card__title--hero");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(h3, file, 50, 28, 2845);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "gp-card__img__overlay gp-card__img__overlay--hero ");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 48, 24, 2597);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div7, "class", "gp-card gp-card--hero gp-card--hero__other");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div7, file, 45, 20, 2370);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img4, "class", "gp-card__img gp-card__img--hero");
			if (!(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.src_url_equal)(img4.src, img4_src_value = "./images/legendofzelda.jpg")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img4, "src", img4_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img4, "alt", "");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(img4, file, 56, 24, 3131);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span3, "class", "gp-tag gp-tag--review");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span3, file, 59, 28, 3352);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a4, "class", "gp-card__title gp-card__title--hero");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a4, "href", "http://localhost:5000/");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a4, file, 60, 28, 3430);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div8, "class", "gp-card__img__overlay gp-card__img__overlay--hero");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div8, file, 58, 24, 3260);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div9, "class", "gp-card gp-card--hero gp-card--hero__other");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div9, file, 54, 20, 3023);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div10, "class", "gp-hero__grid");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div10, file, 13, 8, 373);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img5, "class", "card-img");
			if (!(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.src_url_equal)(img5.src, img5_src_value = "./images/assassins_creed_odessy.svg")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img5, "src", img5_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img5, "alt", "Assassin creed Ads");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(img5, file, 70, 16, 3799);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a5, "href", "https://example.com");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a5, file, 72, 44, 4027);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "buy-btn");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 72, 20, 4003);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div11, "class", "card-img-overlay tw-absolute gp-position-bottom-right tw-pr-2");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div11, file, 71, 16, 3907);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div12, "class", "gp-card gp-cover-container");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div12, file, 69, 12, 3742);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div13, "class", "tw-flex tw-mt-5vmin");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div13, file, 68, 8, 3695);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div10, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, div1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, img0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, span0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, a0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, div3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, img1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, span1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, a1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, t9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, div5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, img2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t10);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, span2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t12);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, a2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, t14);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, div7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, img3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, t15);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div7, div6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, a3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(iconifyicon, a3, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t16);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, h3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, t18);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div10, div9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div9, img4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div9, t19);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div9, div8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div8, span3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div8, t21);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div8, a4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t23, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div13, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div13, div12);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, img5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, t24);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div12, div11);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div11, button);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, a5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t26, anchor);

			if (switch_instance) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, target, anchor);
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = {};
			if (dirty & /*ComponentType*/ 2) switch_instance_changes.type = /*ComponentType*/ ctx[1];
			if (dirty & /*ComponentStyle*/ 4) switch_instance_changes.style = /*ComponentStyle*/ ctx[2];

			if (switch_value !== (switch_value = /*ComponentTheme*/ ctx[0])) {
				if (switch_instance) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
					const old_component = switch_instance;

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(old_component.$$.fragment, 1, 0, () => {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(old_component, 1);
					});

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, 1);
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(iconifyicon.$$.fragment, local);
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(iconifyicon.$$.fragment, local);
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div10);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(iconifyicon);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t23);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div13);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t26);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(switch_instance_anchor);
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(switch_instance, detaching);
		}
	};

	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)('Portal_type', slots, []);
	let { ComponentTheme } = $$props;
	let { ComponentType } = $$props;
	let { ComponentStyle } = $$props;
	const writable_props = ['ComponentTheme', 'ComponentType', 'ComponentStyle'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Portal_type> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('ComponentTheme' in $$props) $$invalidate(0, ComponentTheme = $$props.ComponentTheme);
		if ('ComponentType' in $$props) $$invalidate(1, ComponentType = $$props.ComponentType);
		if ('ComponentStyle' in $$props) $$invalidate(2, ComponentStyle = $$props.ComponentStyle);
	};

	$$self.$capture_state = () => ({
		IconifyIcon: _iconify_svelte__WEBPACK_IMPORTED_MODULE_1__["default"],
		playCircle: _iconify_icons_jam_play_circle__WEBPACK_IMPORTED_MODULE_4__["default"],
		ComponentTheme,
		ComponentType,
		ComponentStyle
	});

	$$self.$inject_state = $$props => {
		if ('ComponentTheme' in $$props) $$invalidate(0, ComponentTheme = $$props.ComponentTheme);
		if ('ComponentType' in $$props) $$invalidate(1, ComponentType = $$props.ComponentType);
		if ('ComponentStyle' in $$props) $$invalidate(2, ComponentStyle = $$props.ComponentStyle);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [ComponentTheme, ComponentType, ComponentStyle];
}

class Portal_type extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {
	constructor(options) {
		super(options);

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {
			ComponentTheme: 0,
			ComponentType: 1,
			ComponentStyle: 2
		});

		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Portal_type",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*ComponentTheme*/ ctx[0] === undefined && !('ComponentTheme' in props)) {
			console.warn("<Portal_type> was created without expected prop 'ComponentTheme'");
		}

		if (/*ComponentType*/ ctx[1] === undefined && !('ComponentType' in props)) {
			console.warn("<Portal_type> was created without expected prop 'ComponentType'");
		}

		if (/*ComponentStyle*/ ctx[2] === undefined && !('ComponentStyle' in props)) {
			console.warn("<Portal_type> was created without expected prop 'ComponentStyle'");
		}
	}

	get ComponentTheme() {
		throw new Error("<Portal_type>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ComponentTheme(value) {
		throw new Error("<Portal_type>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ComponentType() {
		throw new Error("<Portal_type>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ComponentType(value) {
		throw new Error("<Portal_type>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ComponentStyle() {
		throw new Error("<Portal_type>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ComponentStyle(value) {
		throw new Error("<Portal_type>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Portal_type);

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = window["React"];

/***/ }),

/***/ "@wordpress/block-editor":
/*!*************************************!*\
  !*** external ["wp","blockEditor"] ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = window["wp"]["blockEditor"];

/***/ }),

/***/ "@wordpress/blocks":
/*!********************************!*\
  !*** external ["wp","blocks"] ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = window["wp"]["blocks"];

/***/ }),

/***/ "@wordpress/compose":
/*!*********************************!*\
  !*** external ["wp","compose"] ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = window["wp"]["compose"];

/***/ }),

/***/ "@wordpress/data":
/*!******************************!*\
  !*** external ["wp","data"] ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = window["wp"]["data"];

/***/ }),

/***/ "@wordpress/element":
/*!*********************************!*\
  !*** external ["wp","element"] ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = window["wp"]["element"];

/***/ }),

/***/ "@wordpress/i18n":
/*!******************************!*\
  !*** external ["wp","i18n"] ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = window["wp"]["i18n"];

/***/ }),

/***/ "@wordpress/plugins":
/*!*********************************!*\
  !*** external ["wp","plugins"] ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = window["wp"]["plugins"];

/***/ }),

/***/ "./node_modules/@iconify/svelte/dist/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@iconify/svelte/dist/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "_api": () => (/* binding */ _api),
/* harmony export */   "addAPIProvider": () => (/* binding */ addAPIProvider),
/* harmony export */   "addCollection": () => (/* binding */ addCollection),
/* harmony export */   "addIcon": () => (/* binding */ addIcon),
/* harmony export */   "buildIcon": () => (/* binding */ buildIcon),
/* harmony export */   "calculateSize": () => (/* binding */ calculateSize),
/* harmony export */   "disableCache": () => (/* binding */ disableCache),
/* harmony export */   "enableCache": () => (/* binding */ enableCache),
/* harmony export */   "getIcon": () => (/* binding */ getIcon),
/* harmony export */   "iconExists": () => (/* binding */ iconExists),
/* harmony export */   "listIcons": () => (/* binding */ listIcons),
/* harmony export */   "loadIcons": () => (/* binding */ loadIcons),
/* harmony export */   "replaceIDs": () => (/* binding */ replaceIDs)
/* harmony export */ });
function noop() { }
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}

// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
let is_hydrating = false;
function start_hydrating() {
    is_hydrating = true;
}
function end_hydrating() {
    is_hydrating = false;
}
function upper_bound(low, high, key, value) {
    // Return first index of value larger than input value in the range [low, high)
    while (low < high) {
        const mid = low + ((high - low) >> 1);
        if (key(mid) <= value) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return low;
}
function init_hydrate(target) {
    if (target.hydrate_init)
        return;
    target.hydrate_init = true;
    // We know that all children have claim_order values since the unclaimed have been detached
    const children = target.childNodes;
    /*
    * Reorder claimed children optimally.
    * We can reorder claimed children optimally by finding the longest subsequence of
    * nodes that are already claimed in order and only moving the rest. The longest
    * subsequence subsequence of nodes that are claimed in order can be found by
    * computing the longest increasing subsequence of .claim_order values.
    *
    * This algorithm is optimal in generating the least amount of reorder operations
    * possible.
    *
    * Proof:
    * We know that, given a set of reordering operations, the nodes that do not move
    * always form an increasing subsequence, since they do not move among each other
    * meaning that they must be already ordered among each other. Thus, the maximal
    * set of nodes that do not move form a longest increasing subsequence.
    */
    // Compute longest increasing subsequence
    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
    const m = new Int32Array(children.length + 1);
    // Predecessor indices + 1
    const p = new Int32Array(children.length);
    m[0] = -1;
    let longest = 0;
    for (let i = 0; i < children.length; i++) {
        const current = children[i].claim_order;
        // Find the largest subsequence length such that it ends in a value less than our current value
        // upper_bound returns first greater value, so we subtract one
        const seqLen = upper_bound(1, longest + 1, idx => children[m[idx]].claim_order, current) - 1;
        p[i] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
        m[newLen] = i;
        longest = Math.max(newLen, longest);
    }
    // The longest increasing subsequence of nodes (initially reversed)
    const lis = [];
    // The rest of the nodes, nodes that will be moved
    const toMove = [];
    let last = children.length - 1;
    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
        lis.push(children[cur - 1]);
        for (; last >= cur; last--) {
            toMove.push(children[last]);
        }
        last--;
    }
    for (; last >= 0; last--) {
        toMove.push(children[last]);
    }
    lis.reverse();
    // We sort the nodes being moved to guarantee that their insertion order matches the claim order
    toMove.sort((a, b) => a.claim_order - b.claim_order);
    // Finally, we move the nodes
    for (let i = 0, j = 0; i < toMove.length; i++) {
        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
            j++;
        }
        const anchor = j < lis.length ? lis[j] : null;
        target.insertBefore(toMove[i], anchor);
    }
}
function append(target, node) {
    if (is_hydrating) {
        init_hydrate(target);
        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {
            target.actual_end_child = target.firstChild;
        }
        if (node !== target.actual_end_child) {
            target.insertBefore(node, target.actual_end_child);
        }
        else {
            target.actual_end_child = node.nextSibling;
        }
    }
    else if (node.parentNode !== target) {
        target.appendChild(node);
    }
}
function insert(target, node, anchor) {
    if (is_hydrating && !anchor) {
        append(target, node);
    }
    else if (node.parentNode !== target || (anchor && node.nextSibling !== anchor)) {
        target.insertBefore(node, anchor || null);
    }
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function empty() {
    return text('');
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function children(element) {
    return Array.from(element.childNodes);
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
const outroing = new Set();
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            start_hydrating();
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        end_hydrating();
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var icon = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.fullIcon = exports.iconDefaults = exports.minifyProps = exports.matchName = void 0;
/**
 * Expression to test part of icon name.
 */
exports.matchName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
/**
 * Properties that can be minified
 *
 * Values of all these properties are awalys numbers
 */
exports.minifyProps = [
    // All IconifyDimenisons properties
    'width',
    'height',
    'top',
    'left',
];
/**
 * Default values for all optional IconifyIcon properties
 */
exports.iconDefaults = Object.freeze({
    left: 0,
    top: 0,
    width: 16,
    height: 16,
    rotate: 0,
    vFlip: false,
    hFlip: false,
});
/**
 * Add optional properties to icon
 */
function fullIcon(data) {
    return { ...exports.iconDefaults, ...data };
}
exports.fullIcon = fullIcon;
});

var name = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateIcon = exports.stringToIcon = void 0;

/**
 * Convert string to Icon object.
 */
const stringToIcon = (value, validate, allowSimpleName, provider = '') => {
    const colonSeparated = value.split(':');
    // Check for provider with correct '@' at start
    if (value.slice(0, 1) === '@') {
        // First part is provider
        if (colonSeparated.length < 2 || colonSeparated.length > 3) {
            // "@provider:prefix:name" or "@provider:prefix-name"
            return null;
        }
        provider = colonSeparated.shift().slice(1);
    }
    // Check split by colon: "prefix:name", "provider:prefix:name"
    if (colonSeparated.length > 3 || !colonSeparated.length) {
        return null;
    }
    if (colonSeparated.length > 1) {
        // "prefix:name"
        const name = colonSeparated.pop();
        const prefix = colonSeparated.pop();
        const result = {
            // Allow provider without '@': "provider:prefix:name"
            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
            prefix,
            name,
        };
        return validate && !exports.validateIcon(result) ? null : result;
    }
    // Attempt to split by dash: "prefix-name"
    const name = colonSeparated[0];
    const dashSeparated = name.split('-');
    if (dashSeparated.length > 1) {
        const result = {
            provider: provider,
            prefix: dashSeparated.shift(),
            name: dashSeparated.join('-'),
        };
        return validate && !exports.validateIcon(result) ? null : result;
    }
    // If allowEmpty is set, allow empty provider and prefix, allowing names like "home"
    if (allowSimpleName && provider === '') {
        const result = {
            provider: provider,
            prefix: '',
            name,
        };
        return validate && !exports.validateIcon(result, allowSimpleName)
            ? null
            : result;
    }
    return null;
};
exports.stringToIcon = stringToIcon;
/**
 * Check if icon is valid.
 *
 * This function is not part of stringToIcon because validation is not needed for most code.
 */
const validateIcon = (icon$1, allowSimpleName) => {
    if (!icon$1) {
        return false;
    }
    return !!((icon$1.provider === '' || icon$1.provider.match(icon.matchName)) &&
        ((allowSimpleName && icon$1.prefix === '') ||
            icon$1.prefix.match(icon.matchName)) &&
        icon$1.name.match(icon.matchName));
};
exports.validateIcon = validateIcon;
});

var merge = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeIconData = void 0;

/**
 * Merge icon and alias
 */
function mergeIconData(icon$1, alias) {
    const result = { ...icon$1 };
    for (const key in icon.iconDefaults) {
        const prop = key;
        if (alias[prop] !== void 0) {
            const value = alias[prop];
            if (result[prop] === void 0) {
                // Missing value
                result[prop] = value;
                continue;
            }
            switch (prop) {
                case 'rotate':
                    result[prop] =
                        (result[prop] + value) % 4;
                    break;
                case 'hFlip':
                case 'vFlip':
                    result[prop] = value !== result[prop];
                    break;
                default:
                    // Overwrite value
                    result[prop] =
                        value;
            }
        }
    }
    return result;
}
exports.mergeIconData = mergeIconData;
});

var parse = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseIconSet = void 0;


/**
 * Get list of defaults keys
 */
const defaultsKeys = Object.keys(icon.iconDefaults);
/**
 * Resolve alias
 */
function resolveAlias(alias, icons, aliases, level = 0) {
    const parent = alias.parent;
    if (icons[parent] !== void 0) {
        return merge.mergeIconData(icons[parent], alias);
    }
    if (aliases[parent] !== void 0) {
        if (level > 2) {
            // icon + alias + alias + alias = too much nesting, possibly infinite
            return null;
        }
        const icon = resolveAlias(aliases[parent], icons, aliases, level + 1);
        if (icon) {
            return merge.mergeIconData(icon, alias);
        }
    }
    return null;
}
/**
 * Extract icons from an icon set
 */
function parseIconSet(data, callback, list = 'none') {
    const added = [];
    // Must be an object
    if (typeof data !== 'object') {
        return list === 'none' ? false : added;
    }
    // Check for missing icons list returned by API
    if (data.not_found instanceof Array) {
        data.not_found.forEach((name) => {
            callback(name, null);
            if (list === 'all') {
                added.push(name);
            }
        });
    }
    // Must have 'icons' object
    if (typeof data.icons !== 'object') {
        return list === 'none' ? false : added;
    }
    // Get default values
    const defaults = Object.create(null);
    defaultsKeys.forEach((key) => {
        if (data[key] !== void 0 && typeof data[key] !== 'object') {
            defaults[key] = data[key];
        }
    });
    // Get icons
    const icons = data.icons;
    Object.keys(icons).forEach((name) => {
        const icon$1 = icons[name];
        if (typeof icon$1.body !== 'string') {
            return;
        }
        // Freeze icon to make sure it will not be modified
        callback(name, Object.freeze({ ...icon.iconDefaults, ...defaults, ...icon$1 }));
        added.push(name);
    });
    // Get aliases
    if (typeof data.aliases === 'object') {
        const aliases = data.aliases;
        Object.keys(aliases).forEach((name) => {
            const icon$1 = resolveAlias(aliases[name], icons, aliases, 1);
            if (icon$1) {
                // Freeze icon to make sure it will not be modified
                callback(name, Object.freeze({ ...icon.iconDefaults, ...defaults, ...icon$1 }));
                added.push(name);
            }
        });
    }
    return list === 'none' ? added.length > 0 : added;
}
exports.parseIconSet = parseIconSet;
});

var storage_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.listIcons = exports.getIcon = exports.iconExists = exports.addIcon = exports.addIconSet = exports.getStorage = exports.newStorage = void 0;


/**
 * Storage by provider and prefix
 */
const storage = Object.create(null);
/**
 * Create new storage
 */
function newStorage(provider, prefix) {
    return {
        provider,
        prefix,
        icons: Object.create(null),
        missing: Object.create(null),
    };
}
exports.newStorage = newStorage;
/**
 * Get storage for provider and prefix
 */
function getStorage(provider, prefix) {
    if (storage[provider] === void 0) {
        storage[provider] = Object.create(null);
    }
    const providerStorage = storage[provider];
    if (providerStorage[prefix] === void 0) {
        providerStorage[prefix] = newStorage(provider, prefix);
    }
    return providerStorage[prefix];
}
exports.getStorage = getStorage;
/**
 * Add icon set to storage
 *
 * Returns array of added icons if 'list' is true and icons were added successfully
 */
function addIconSet(storage, data, list = 'none') {
    const t = Date.now();
    return parse.parseIconSet(data, (name, icon) => {
        if (icon === null) {
            storage.missing[name] = t;
        }
        else {
            storage.icons[name] = icon;
        }
    }, list);
}
exports.addIconSet = addIconSet;
/**
 * Add icon to storage
 */
function addIcon(storage, name, icon$1) {
    try {
        if (typeof icon$1.body === 'string') {
            // Freeze icon to make sure it will not be modified
            storage.icons[name] = Object.freeze(icon.fullIcon(icon$1));
            return true;
        }
    }
    catch (err) {
        // Do nothing
    }
    return false;
}
exports.addIcon = addIcon;
/**
 * Check if icon exists
 */
function iconExists(storage, name) {
    return storage.icons[name] !== void 0;
}
exports.iconExists = iconExists;
/**
 * Get icon data
 */
function getIcon(storage, name) {
    const value = storage.icons[name];
    return value === void 0 ? null : value;
}
exports.getIcon = getIcon;
/**
 * List available icons
 */
function listIcons(provider, prefix) {
    let allIcons = [];
    // Get providers
    let providers;
    if (typeof provider === 'string') {
        providers = [provider];
    }
    else {
        providers = Object.keys(storage);
    }
    // Get all icons
    providers.forEach((provider) => {
        let prefixes;
        if (typeof provider === 'string' && typeof prefix === 'string') {
            prefixes = [prefix];
        }
        else {
            prefixes =
                storage[provider] === void 0
                    ? []
                    : Object.keys(storage[provider]);
        }
        prefixes.forEach((prefix) => {
            const storage = getStorage(provider, prefix);
            const icons = Object.keys(storage.icons).map((name) => (provider !== '' ? '@' + provider + ':' : '') +
                prefix +
                ':' +
                name);
            allIcons = allIcons.concat(icons);
        });
    });
    return allIcons;
}
exports.listIcons = listIcons;
});

var functions$3 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.storageFunctions = exports.addCollection = exports.addIcon = exports.getIconData = exports.allowSimpleNames = void 0;



/**
 * Allow storing icons without provider or prefix, making it possible to store icons like "home"
 */
let simpleNames = false;
function allowSimpleNames(allow) {
    if (typeof allow === 'boolean') {
        simpleNames = allow;
    }
    return simpleNames;
}
exports.allowSimpleNames = allowSimpleNames;
/**
 * Get icon data
 */
function getIconData(name$1) {
    const icon = typeof name$1 === 'string' ? name.stringToIcon(name$1, true, simpleNames) : name$1;
    return icon
        ? storage_1.getIcon(storage_1.getStorage(icon.provider, icon.prefix), icon.name)
        : null;
}
exports.getIconData = getIconData;
/**
 * Add one icon
 */
function addIcon(name$1, data) {
    const icon = name.stringToIcon(name$1, true, simpleNames);
    if (!icon) {
        return false;
    }
    const storage = storage_1.getStorage(icon.provider, icon.prefix);
    return storage_1.addIcon(storage, icon.name, data);
}
exports.addIcon = addIcon;
/**
 * Add icon set
 */
function addCollection(data, provider) {
    if (typeof data !== 'object') {
        return false;
    }
    // Get provider
    if (typeof provider !== 'string') {
        provider = typeof data.provider === 'string' ? data.provider : '';
    }
    // Check for simple names: requires empty provider and prefix
    if (simpleNames &&
        provider === '' &&
        (typeof data.prefix !== 'string' || data.prefix === '')) {
        // Simple names: add icons one by one
        let added = false;
        parse.parseIconSet(data, (name, icon) => {
            if (icon !== null && addIcon(name, icon)) {
                added = true;
            }
        });
        return added;
    }
    // Validate provider and prefix
    if (typeof data.prefix !== 'string' ||
        !name.validateIcon({
            provider,
            prefix: data.prefix,
            name: 'a',
        })) {
        return false;
    }
    const storage = storage_1.getStorage(provider, data.prefix);
    return !!storage_1.addIconSet(storage, data);
}
exports.addCollection = addCollection;
/**
 * Export
 */
exports.storageFunctions = {
    // Check if icon exists
    iconExists: (name) => getIconData(name) !== null,
    // Get raw icon data
    getIcon: (name) => {
        const result = getIconData(name);
        return result ? { ...result } : null;
    },
    // List icons
    listIcons: storage_1.listIcons,
    // Add icon
    addIcon,
    // Add icon set
    addCollection,
};
});

var id = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceIDs = void 0;
/**
 * Regular expression for finding ids
 */
const regex = /\sid="(\S+)"/g;
/**
 * Match for allowed characters before and after id in replacement, including () for group
 */
const replaceValue = '([^A-Za-z0-9_-])';
/**
 * Escape value for 'new RegExp()'
 */
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
/**
 * New random-ish prefix for ids
 */
const randomPrefix = 'IconifyId-' +
    Date.now().toString(16) +
    '-' +
    ((Math.random() * 0x1000000) | 0).toString(16) +
    '-';
/**
 * Counter for ids, increasing with every replacement
 */
let counter = 0;
/**
 * Replace IDs in SVG output with unique IDs
 * Fast replacement without parsing XML, assuming commonly used patterns and clean XML (icon should have been cleaned up with Iconify Tools or SVGO).
 */
function replaceIDs(body, prefix = randomPrefix) {
    // Find all IDs
    const ids = [];
    let match;
    while ((match = regex.exec(body))) {
        ids.push(match[1]);
    }
    if (!ids.length) {
        return body;
    }
    // Replace with unique ids
    ids.forEach((id) => {
        const newID = typeof prefix === 'function' ? prefix() : prefix + counter++;
        body = body.replace(new RegExp(replaceValue + '(' + escapeRegExp(id) + ')' + replaceValue, 'g'), '$1' + newID + '$3');
    });
    return body;
}
exports.replaceIDs = replaceIDs;
});

var size = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateSize = void 0;
/**
 * Regular expressions for calculating dimensions
 */
const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
/**
 * Calculate second dimension when only 1 dimension is set
 *
 * @param {string|number} size One dimension (such as width)
 * @param {number} ratio Width/height ratio.
 *      If size is width, ratio = height/width
 *      If size is height, ratio = width/height
 * @param {number} [precision] Floating number precision in result to minimize output. Default = 2
 * @return {string|number} Another dimension
 */
function calculateSize(size, ratio, precision) {
    if (ratio === 1) {
        return size;
    }
    precision = precision === void 0 ? 100 : precision;
    if (typeof size === 'number') {
        return Math.ceil(size * ratio * precision) / precision;
    }
    if (typeof size !== 'string') {
        return size;
    }
    // Split code into sets of strings and numbers
    const oldParts = size.split(unitsSplit);
    if (oldParts === null || !oldParts.length) {
        return size;
    }
    const newParts = [];
    let code = oldParts.shift();
    let isNumber = unitsTest.test(code);
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (isNumber) {
            const num = parseFloat(code);
            if (isNaN(num)) {
                newParts.push(code);
            }
            else {
                newParts.push(Math.ceil(num * ratio * precision) / precision);
            }
        }
        else {
            newParts.push(code);
        }
        // next
        code = oldParts.shift();
        if (code === void 0) {
            return newParts.join('');
        }
        isNumber = !isNumber;
    }
}
exports.calculateSize = calculateSize;
});

var customisations = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeCustomisations = exports.defaults = void 0;
/**
 * Default icon customisations values
 */
exports.defaults = Object.freeze({
    // Display mode
    inline: false,
    // Dimensions
    width: null,
    height: null,
    // Alignment
    hAlign: 'center',
    vAlign: 'middle',
    slice: false,
    // Transformations
    hFlip: false,
    vFlip: false,
    rotate: 0,
});
/**
 * Convert IconifyIconCustomisations to FullIconCustomisations
 */
function mergeCustomisations(defaults, item) {
    const result = {};
    for (const key in defaults) {
        const attr = key;
        // Copy old value
        result[attr] = defaults[attr];
        if (item[attr] === void 0) {
            continue;
        }
        // Validate new value
        const value = item[attr];
        switch (attr) {
            // Boolean attributes that override old value
            case 'inline':
            case 'slice':
                if (typeof value === 'boolean') {
                    result[attr] = value;
                }
                break;
            // Boolean attributes that are merged
            case 'hFlip':
            case 'vFlip':
                if (value === true) {
                    result[attr] = !result[attr];
                }
                break;
            // Non-empty string
            case 'hAlign':
            case 'vAlign':
                if (typeof value === 'string' && value !== '') {
                    result[attr] = value;
                }
                break;
            // Non-empty string / non-zero number / null
            case 'width':
            case 'height':
                if ((typeof value === 'string' && value !== '') ||
                    (typeof value === 'number' && value) ||
                    value === null) {
                    result[attr] = value;
                }
                break;
            // Rotation
            case 'rotate':
                if (typeof value === 'number') {
                    result[attr] += value;
                }
                break;
        }
    }
    return result;
}
exports.mergeCustomisations = mergeCustomisations;
});

var build = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.iconToSVG = void 0;

/**
 * Get preserveAspectRatio value
 */
function preserveAspectRatio(props) {
    let result = '';
    switch (props.hAlign) {
        case 'left':
            result += 'xMin';
            break;
        case 'right':
            result += 'xMax';
            break;
        default:
            result += 'xMid';
    }
    switch (props.vAlign) {
        case 'top':
            result += 'YMin';
            break;
        case 'bottom':
            result += 'YMax';
            break;
        default:
            result += 'YMid';
    }
    result += props.slice ? ' slice' : ' meet';
    return result;
}
/**
 * Get SVG attributes and content from icon + customisations
 *
 * Does not generate style to make it compatible with frameworks that use objects for style, such as React.
 * Instead, it generates 'inline' value. If true, rendering engine should add verticalAlign: -0.125em to icon.
 *
 * Customisations should be normalised by platform specific parser.
 * Result should be converted to <svg> by platform specific parser.
 * Use replaceIDs to generate unique IDs for body.
 */
function iconToSVG(icon, customisations) {
    // viewBox
    const box = {
        left: icon.left,
        top: icon.top,
        width: icon.width,
        height: icon.height,
    };
    // Body
    let body = icon.body;
    // Apply transformations
    [icon, customisations].forEach((props) => {
        const transformations = [];
        const hFlip = props.hFlip;
        const vFlip = props.vFlip;
        let rotation = props.rotate;
        // Icon is flipped first, then rotated
        if (hFlip) {
            if (vFlip) {
                rotation += 2;
            }
            else {
                // Horizontal flip
                transformations.push('translate(' +
                    (box.width + box.left) +
                    ' ' +
                    (0 - box.top) +
                    ')');
                transformations.push('scale(-1 1)');
                box.top = box.left = 0;
            }
        }
        else if (vFlip) {
            // Vertical flip
            transformations.push('translate(' +
                (0 - box.left) +
                ' ' +
                (box.height + box.top) +
                ')');
            transformations.push('scale(1 -1)');
            box.top = box.left = 0;
        }
        let tempValue;
        if (rotation < 0) {
            rotation -= Math.floor(rotation / 4) * 4;
        }
        rotation = rotation % 4;
        switch (rotation) {
            case 1:
                // 90deg
                tempValue = box.height / 2 + box.top;
                transformations.unshift('rotate(90 ' + tempValue + ' ' + tempValue + ')');
                break;
            case 2:
                // 180deg
                transformations.unshift('rotate(180 ' +
                    (box.width / 2 + box.left) +
                    ' ' +
                    (box.height / 2 + box.top) +
                    ')');
                break;
            case 3:
                // 270deg
                tempValue = box.width / 2 + box.left;
                transformations.unshift('rotate(-90 ' + tempValue + ' ' + tempValue + ')');
                break;
        }
        if (rotation % 2 === 1) {
            // Swap width/height and x/y for 90deg or 270deg rotation
            if (box.left !== 0 || box.top !== 0) {
                tempValue = box.left;
                box.left = box.top;
                box.top = tempValue;
            }
            if (box.width !== box.height) {
                tempValue = box.width;
                box.width = box.height;
                box.height = tempValue;
            }
        }
        if (transformations.length) {
            body =
                '<g transform="' +
                    transformations.join(' ') +
                    '">' +
                    body +
                    '</g>';
        }
    });
    // Calculate dimensions
    let width, height;
    if (customisations.width === null && customisations.height === null) {
        // Set height to '1em', calculate width
        height = '1em';
        width = size.calculateSize(height, box.width / box.height);
    }
    else if (customisations.width !== null &&
        customisations.height !== null) {
        // Values are set
        width = customisations.width;
        height = customisations.height;
    }
    else if (customisations.height !== null) {
        // Height is set
        height = customisations.height;
        width = size.calculateSize(height, box.width / box.height);
    }
    else {
        // Width is set
        width = customisations.width;
        height = size.calculateSize(width, box.height / box.width);
    }
    // Check for 'auto'
    if (width === 'auto') {
        width = box.width;
    }
    if (height === 'auto') {
        height = box.height;
    }
    // Convert to string
    width = typeof width === 'string' ? width : width + '';
    height = typeof height === 'string' ? height : height + '';
    // Result
    const result = {
        attributes: {
            width,
            height,
            preserveAspectRatio: preserveAspectRatio(customisations),
            viewBox: box.left + ' ' + box.top + ' ' + box.width + ' ' + box.height,
        },
        body,
    };
    if (customisations.inline) {
        result.inline = true;
    }
    return result;
}
exports.iconToSVG = iconToSVG;
});

var functions$2 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.builderFunctions = void 0;





/**
 * Exported builder functions
 */
exports.builderFunctions = {
    replaceIDs: id.replaceIDs,
    calculateSize: size.calculateSize,
    buildIcon: (icon$1, customisations$1) => {
        return build.iconToSVG(icon.fullIcon(icon$1), customisations.mergeCustomisations(customisations.defaults, customisations$1));
    },
};
});

var modules$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.coreModules = void 0;
exports.coreModules = {};
});

var config$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = void 0;
/**
 * Default RedundancyConfig for API calls
 */
exports.defaultConfig = {
    resources: [],
    index: 0,
    timeout: 2000,
    rotate: 750,
    random: false,
    dataAfterTimeout: false,
};
});

var query = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendQuery = void 0;
/**
 * Send query
 */
function sendQuery(config, payload, query, done, success) {
    // Get number of resources
    const resourcesCount = config.resources.length;
    // Save start index
    const startIndex = config.random
        ? Math.floor(Math.random() * resourcesCount)
        : config.index;
    // Get resources
    let resources;
    if (config.random) {
        // Randomise array
        let list = config.resources.slice(0);
        resources = [];
        while (list.length > 1) {
            const nextIndex = Math.floor(Math.random() * list.length);
            resources.push(list[nextIndex]);
            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
        }
        resources = resources.concat(list);
    }
    else {
        // Rearrange resources to start with startIndex
        resources = config.resources
            .slice(startIndex)
            .concat(config.resources.slice(0, startIndex));
    }
    // Counters, status
    const startTime = Date.now();
    let status = 'pending';
    let queriesSent = 0;
    let lastError = void 0;
    // Timer
    let timer = null;
    // Execution queue
    let queue = [];
    // Callbacks to call when query is complete
    let doneCallbacks = [];
    if (typeof done === 'function') {
        doneCallbacks.push(done);
    }
    /**
     * Reset timer
     */
    function resetTimer() {
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    }
    /**
     * Abort everything
     */
    function abort() {
        // Change status
        if (status === 'pending') {
            status = 'aborted';
        }
        // Reset timer
        resetTimer();
        // Abort all queued items
        queue.forEach((item) => {
            if (item.abort) {
                item.abort();
            }
            if (item.status === 'pending') {
                item.status = 'aborted';
            }
        });
        queue = [];
    }
    /**
     * Add / replace callback to call when execution is complete.
     * This can be used to abort pending query implementations when query is complete or aborted.
     */
    function subscribe(callback, overwrite) {
        if (overwrite) {
            doneCallbacks = [];
        }
        if (typeof callback === 'function') {
            doneCallbacks.push(callback);
        }
    }
    /**
     * Get query status
     */
    function getQueryStatus() {
        return {
            startTime,
            payload,
            status,
            queriesSent,
            queriesPending: queue.length,
            subscribe,
            abort,
        };
    }
    /**
     * Fail query
     */
    function failQuery() {
        status = 'failed';
        // Send notice to all callbacks
        doneCallbacks.forEach((callback) => {
            callback(void 0, lastError);
        });
    }
    /**
     * Clear queue
     */
    function clearQueue() {
        queue = queue.filter((item) => {
            if (item.status === 'pending') {
                item.status = 'aborted';
            }
            if (item.abort) {
                item.abort();
            }
            return false;
        });
    }
    /**
     * Got response from module
     */
    function moduleResponse(item, data, error) {
        const isError = data === void 0;
        // Remove item from queue
        queue = queue.filter((queued) => queued !== item);
        // Check status
        switch (status) {
            case 'pending':
                // Pending
                break;
            case 'failed':
                if (isError || !config.dataAfterTimeout) {
                    // Query has already timed out or dataAfterTimeout is disabled
                    return;
                }
                // Success after failure
                break;
            default:
                // Aborted or completed
                return;
        }
        // Error
        if (isError) {
            if (error !== void 0) {
                lastError = error;
            }
            if (!queue.length) {
                if (!resources.length) {
                    // Nothing else queued, nothing can be queued
                    failQuery();
                }
                else {
                    // Queue is empty: run next item immediately
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    execNext();
                }
            }
            return;
        }
        // Reset timers, abort pending queries
        resetTimer();
        clearQueue();
        // Update index in Redundancy
        if (success && !config.random) {
            const index = config.resources.indexOf(item.resource);
            if (index !== -1 && index !== config.index) {
                success(index);
            }
        }
        // Mark as completed and call callbacks
        status = 'completed';
        doneCallbacks.forEach((callback) => {
            callback(data);
        });
    }
    /**
     * Execute next query
     */
    function execNext() {
        // Check status
        if (status !== 'pending') {
            return;
        }
        // Reset timer
        resetTimer();
        // Get resource
        const resource = resources.shift();
        if (resource === void 0) {
            // Nothing to execute: wait for final timeout before failing
            if (queue.length) {
                const timeout = typeof config.timeout === 'function'
                    ? config.timeout(startTime)
                    : config.timeout;
                if (timeout) {
                    // Last timeout before failing to allow late response
                    timer = setTimeout(() => {
                        resetTimer();
                        if (status === 'pending') {
                            // Clear queue
                            clearQueue();
                            failQuery();
                        }
                    }, timeout);
                    return;
                }
            }
            // Fail
            failQuery();
            return;
        }
        // Create new item
        const item = {
            getQueryStatus,
            status: 'pending',
            resource,
            done: (data, error) => {
                moduleResponse(item, data, error);
            },
        };
        // Add to queue
        queue.push(item);
        // Bump next index
        queriesSent++;
        // Get timeout for next item
        const timeout = typeof config.rotate === 'function'
            ? config.rotate(queriesSent, startTime)
            : config.rotate;
        // Create timer
        timer = setTimeout(execNext, timeout);
        // Execute it
        query(resource, payload, item);
    }
    // Execute first query on next tick
    setTimeout(execNext);
    // Return getQueryStatus()
    return getQueryStatus;
}
exports.sendQuery = sendQuery;
});

var redundancy = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.initRedundancy = void 0;


/**
 * Set configuration
 */
function setConfig(config) {
    if (typeof config !== 'object' ||
        typeof config.resources !== 'object' ||
        !(config.resources instanceof Array) ||
        !config.resources.length) {
        throw new Error('Invalid Reduncancy configuration');
    }
    const newConfig = Object.create(null);
    let key;
    for (key in config$1.defaultConfig) {
        if (config[key] !== void 0) {
            newConfig[key] = config[key];
        }
        else {
            newConfig[key] = config$1.defaultConfig[key];
        }
    }
    return newConfig;
}
/**
 * Redundancy instance
 */
function initRedundancy(cfg) {
    // Configuration
    const config = setConfig(cfg);
    // List of queries
    let queries = [];
    /**
     * Remove aborted and completed queries
     */
    function cleanup() {
        queries = queries.filter((item) => item().status === 'pending');
    }
    /**
     * Send query
     */
    function query$1(payload, queryCallback, doneCallback) {
        const query$1 = query.sendQuery(config, payload, queryCallback, (data, error) => {
            // Remove query from list
            cleanup();
            // Call callback
            if (doneCallback) {
                doneCallback(data, error);
            }
        }, (newIndex) => {
            // Update start index
            config.index = newIndex;
        });
        queries.push(query$1);
        return query$1;
    }
    /**
     * Find instance
     */
    function find(callback) {
        const result = queries.find((value) => {
            return callback(value);
        });
        return result !== void 0 ? result : null;
    }
    // Create and return functions
    const instance = {
        query: query$1,
        find,
        setIndex: (index) => {
            config.index = index;
        },
        getIndex: () => config.index,
        cleanup,
    };
    return instance;
}
exports.initRedundancy = initRedundancy;
});

var sort = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortIcons = void 0;

/**
 * Check if icons have been loaded
 */
function sortIcons(icons) {
    const result = {
        loaded: [],
        missing: [],
        pending: [],
    };
    const storage = Object.create(null);
    // Sort icons alphabetically to prevent duplicates and make sure they are sorted in API queries
    icons.sort((a, b) => {
        if (a.provider !== b.provider) {
            return a.provider.localeCompare(b.provider);
        }
        if (a.prefix !== b.prefix) {
            return a.prefix.localeCompare(b.prefix);
        }
        return a.name.localeCompare(b.name);
    });
    let lastIcon = {
        provider: '',
        prefix: '',
        name: '',
    };
    icons.forEach((icon) => {
        if (lastIcon.name === icon.name &&
            lastIcon.prefix === icon.prefix &&
            lastIcon.provider === icon.provider) {
            return;
        }
        lastIcon = icon;
        // Check icon
        const provider = icon.provider;
        const prefix = icon.prefix;
        const name = icon.name;
        if (storage[provider] === void 0) {
            storage[provider] = Object.create(null);
        }
        const providerStorage = storage[provider];
        if (providerStorage[prefix] === void 0) {
            providerStorage[prefix] = storage_1.getStorage(provider, prefix);
        }
        const localStorage = providerStorage[prefix];
        let list;
        if (localStorage.icons[name] !== void 0) {
            list = result.loaded;
        }
        else if (prefix === '' || localStorage.missing[name] !== void 0) {
            // Mark icons without prefix as missing because they cannot be loaded from API
            list = result.missing;
        }
        else {
            list = result.pending;
        }
        const item = {
            provider,
            prefix,
            name,
        };
        list.push(item);
    });
    return result;
}
exports.sortIcons = sortIcons;
});

var callbacks = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeCallback = exports.updateCallbacks = exports.callbacks = void 0;

// Records sorted by provider and prefix
// This export is only for unit testing, should not be used
exports.callbacks = Object.create(null);
const pendingUpdates = Object.create(null);
/**
 * Remove callback
 */
function removeCallback(sources, id) {
    sources.forEach((source) => {
        const provider = source.provider;
        if (exports.callbacks[provider] === void 0) {
            return;
        }
        const providerCallbacks = exports.callbacks[provider];
        const prefix = source.prefix;
        const items = providerCallbacks[prefix];
        if (items) {
            providerCallbacks[prefix] = items.filter((row) => row.id !== id);
        }
    });
}
/**
 * Update all callbacks for provider and prefix
 */
function updateCallbacks(provider, prefix) {
    if (pendingUpdates[provider] === void 0) {
        pendingUpdates[provider] = Object.create(null);
    }
    const providerPendingUpdates = pendingUpdates[provider];
    if (!providerPendingUpdates[prefix]) {
        providerPendingUpdates[prefix] = true;
        setTimeout(() => {
            providerPendingUpdates[prefix] = false;
            if (exports.callbacks[provider] === void 0 ||
                exports.callbacks[provider][prefix] === void 0) {
                return;
            }
            // Get all items
            const items = exports.callbacks[provider][prefix].slice(0);
            if (!items.length) {
                return;
            }
            const storage = storage_1.getStorage(provider, prefix);
            // Check each item for changes
            let hasPending = false;
            items.forEach((item) => {
                const icons = item.icons;
                const oldLength = icons.pending.length;
                icons.pending = icons.pending.filter((icon) => {
                    if (icon.prefix !== prefix) {
                        // Checking only current prefix
                        return true;
                    }
                    const name = icon.name;
                    if (storage.icons[name] !== void 0) {
                        // Loaded
                        icons.loaded.push({
                            provider,
                            prefix,
                            name,
                        });
                    }
                    else if (storage.missing[name] !== void 0) {
                        // Missing
                        icons.missing.push({
                            provider,
                            prefix,
                            name,
                        });
                    }
                    else {
                        // Pending
                        hasPending = true;
                        return true;
                    }
                    return false;
                });
                // Changes detected - call callback
                if (icons.pending.length !== oldLength) {
                    if (!hasPending) {
                        // All icons have been loaded - remove callback from prefix
                        removeCallback([
                            {
                                provider,
                                prefix,
                            },
                        ], item.id);
                    }
                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);
                }
            });
        });
    }
}
exports.updateCallbacks = updateCallbacks;
/**
 * Unique id counter for callbacks
 */
let idCounter = 0;
/**
 * Add callback
 */
function storeCallback(callback, icons, pendingSources) {
    // Create unique id and abort function
    const id = idCounter++;
    const abort = removeCallback.bind(null, pendingSources, id);
    if (!icons.pending.length) {
        // Do not store item without pending icons and return function that does nothing
        return abort;
    }
    // Create item and store it for all pending prefixes
    const item = {
        id,
        icons,
        callback,
        abort: abort,
    };
    pendingSources.forEach((source) => {
        const provider = source.provider;
        const prefix = source.prefix;
        if (exports.callbacks[provider] === void 0) {
            exports.callbacks[provider] = Object.create(null);
        }
        const providerCallbacks = exports.callbacks[provider];
        if (providerCallbacks[prefix] === void 0) {
            providerCallbacks[prefix] = [];
        }
        providerCallbacks[prefix].push(item);
    });
    return abort;
}
exports.storeCallback = storeCallback;
});

var modules = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAPIModule = exports.setAPIModule = void 0;
/**
 * Local storate types and entries
 */
const storage = Object.create(null);
/**
 * Set API module
 */
function setAPIModule(provider, item) {
    storage[provider] = item;
}
exports.setAPIModule = setAPIModule;
/**
 * Get API module
 */
function getAPIModule(provider) {
    return storage[provider] === void 0 ? storage[''] : storage[provider];
}
exports.getAPIModule = getAPIModule;
});

var config = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAPIConfig = exports.setAPIConfig = void 0;
/**
 * Create full API configuration from partial data
 */
function createConfig(source) {
    let resources;
    if (typeof source.resources === 'string') {
        resources = [source.resources];
    }
    else {
        resources = source.resources;
        if (!(resources instanceof Array) || !resources.length) {
            return null;
        }
    }
    const result = {
        // API hosts
        resources: resources,
        // Root path
        path: source.path === void 0 ? '/' : source.path,
        // URL length limit
        maxURL: source.maxURL ? source.maxURL : 500,
        // Timeout before next host is used.
        rotate: source.rotate ? source.rotate : 750,
        // Timeout before failing query.
        timeout: source.timeout ? source.timeout : 5000,
        // Randomise default API end point.
        random: source.random === true,
        // Start index
        index: source.index ? source.index : 0,
        // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
        dataAfterTimeout: source.dataAfterTimeout !== false,
    };
    return result;
}
/**
 * Local storage
 */
const configStorage = Object.create(null);
/**
 * Redundancy for API servers.
 *
 * API should have very high uptime because of implemented redundancy at server level, but
 * sometimes bad things happen. On internet 100% uptime is not possible.
 *
 * There could be routing problems. Server might go down for whatever reason, but it takes
 * few minutes to detect that downtime, so during those few minutes API might not be accessible.
 *
 * This script has some redundancy to mitigate possible network issues.
 *
 * If one host cannot be reached in 'rotate' (750 by default) ms, script will try to retrieve
 * data from different host. Hosts have different configurations, pointing to different
 * API servers hosted at different providers.
 */
const fallBackAPISources = [
    'https://api.simplesvg.com',
    'https://api.unisvg.com',
];
// Shuffle fallback API
const fallBackAPI = [];
while (fallBackAPISources.length > 0) {
    if (fallBackAPISources.length === 1) {
        fallBackAPI.push(fallBackAPISources.shift());
    }
    else {
        // Get first or last item
        if (Math.random() > 0.5) {
            fallBackAPI.push(fallBackAPISources.shift());
        }
        else {
            fallBackAPI.push(fallBackAPISources.pop());
        }
    }
}
// Add default API
configStorage[''] = createConfig({
    resources: ['https://api.iconify.design'].concat(fallBackAPI),
});
/**
 * Add custom config for provider
 */
function setAPIConfig(provider, customConfig) {
    const config = createConfig(customConfig);
    if (config === null) {
        return false;
    }
    configStorage[provider] = config;
    return true;
}
exports.setAPIConfig = setAPIConfig;
/**
 * Get API configuration
 */
const getAPIConfig = (provider) => configStorage[provider];
exports.getAPIConfig = getAPIConfig;
});

var list = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProviders = exports.listToIcons = void 0;

/**
 * Convert icons list from string/icon mix to icons and validate them
 */
function listToIcons(list, validate = true, simpleNames = false) {
    const result = [];
    list.forEach((item) => {
        const icon = typeof item === 'string'
            ? name.stringToIcon(item, false, simpleNames)
            : item;
        if (!validate || name.validateIcon(icon, simpleNames)) {
            result.push({
                provider: icon.provider,
                prefix: icon.prefix,
                name: icon.name,
            });
        }
    });
    return result;
}
exports.listToIcons = listToIcons;
/**
 * Get all providers
 */
function getProviders(list) {
    const providers = Object.create(null);
    list.forEach((icon) => {
        providers[icon.provider] = true;
    });
    return Object.keys(providers);
}
exports.getProviders = getProviders;
});

var api = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.API = exports.getRedundancyCache = void 0;









// Empty abort callback for loadIcons()
function emptyCallback() {
    // Do nothing
}
const pendingIcons = Object.create(null);
/**
 * List of icons that are waiting to be loaded.
 *
 * List is passed to API module, then cleared.
 *
 * This list should not be used for any checks, use pendingIcons to check
 * if icons is being loaded.
 *
 * [provider][prefix] = array of icon names
 */
const iconsToLoad = Object.create(null);
// Flags to merge multiple synchronous icon requests in one asynchronous request
const loaderFlags = Object.create(null);
const queueFlags = Object.create(null);
const redundancyCache = Object.create(null);
/**
 * Get Redundancy instance for provider
 */
function getRedundancyCache(provider) {
    if (redundancyCache[provider] === void 0) {
        const config$1 = config.getAPIConfig(provider);
        if (!config$1) {
            // No way to load icons because configuration is not set!
            return;
        }
        const redundancy$1 = redundancy.initRedundancy(config$1);
        const cachedReundancy = {
            config: config$1,
            redundancy: redundancy$1,
        };
        redundancyCache[provider] = cachedReundancy;
    }
    return redundancyCache[provider];
}
exports.getRedundancyCache = getRedundancyCache;
/**
 * Function called when new icons have been loaded
 */
function loadedNewIcons(provider, prefix) {
    // Run only once per tick, possibly joining multiple API responses in one call
    if (loaderFlags[provider] === void 0) {
        loaderFlags[provider] = Object.create(null);
    }
    const providerLoaderFlags = loaderFlags[provider];
    if (!providerLoaderFlags[prefix]) {
        providerLoaderFlags[prefix] = true;
        setTimeout(() => {
            providerLoaderFlags[prefix] = false;
            callbacks.updateCallbacks(provider, prefix);
        });
    }
}
// Storage for errors for loadNewIcons(). Used to avoid spamming log with identical errors.
const errorsCache = Object.create(null);
/**
 * Load icons
 */
function loadNewIcons(provider, prefix, icons) {
    function err() {
        const key = (provider === '' ? '' : '@' + provider + ':') + prefix;
        const time = Math.floor(Date.now() / 60000); // log once in a minute
        if (errorsCache[key] < time) {
            errorsCache[key] = time;
            console.error('Unable to retrieve icons for "' +
                key +
                '" because API is not configured properly.');
        }
    }
    // Create nested objects if needed
    if (iconsToLoad[provider] === void 0) {
        iconsToLoad[provider] = Object.create(null);
    }
    const providerIconsToLoad = iconsToLoad[provider];
    if (queueFlags[provider] === void 0) {
        queueFlags[provider] = Object.create(null);
    }
    const providerQueueFlags = queueFlags[provider];
    if (pendingIcons[provider] === void 0) {
        pendingIcons[provider] = Object.create(null);
    }
    const providerPendingIcons = pendingIcons[provider];
    // Add icons to queue
    if (providerIconsToLoad[prefix] === void 0) {
        providerIconsToLoad[prefix] = icons;
    }
    else {
        providerIconsToLoad[prefix] = providerIconsToLoad[prefix]
            .concat(icons)
            .sort();
    }
    // Redundancy item
    let cachedReundancy;
    // Trigger update on next tick, mering multiple synchronous requests into one asynchronous request
    if (!providerQueueFlags[prefix]) {
        providerQueueFlags[prefix] = true;
        setTimeout(() => {
            providerQueueFlags[prefix] = false;
            // Get icons and delete queue
            const icons = providerIconsToLoad[prefix];
            delete providerIconsToLoad[prefix];
            // Get API module
            const api = modules.getAPIModule(provider);
            if (!api) {
                // No way to load icons!
                err();
                return;
            }
            // Get API config and Redundancy instance
            if (cachedReundancy === void 0) {
                const redundancy = getRedundancyCache(provider);
                if (redundancy === void 0) {
                    // No way to load icons because configuration is not set!
                    err();
                    return;
                }
                cachedReundancy = redundancy;
            }
            // Prepare parameters and run queries
            const params = api.prepare(provider, prefix, icons);
            params.forEach((item) => {
                cachedReundancy.redundancy.query(item, api.send, (data, error) => {
                    const storage = storage_1.getStorage(provider, prefix);
                    // Check for error
                    if (typeof data !== 'object') {
                        if (error !== 404) {
                            // Do not handle error unless it is 404
                            return;
                        }
                        // Not found: mark as missing
                        const t = Date.now();
                        item.icons.forEach((name) => {
                            storage.missing[name] = t;
                        });
                    }
                    else {
                        // Add icons to storage
                        try {
                            const added = storage_1.addIconSet(storage, data, 'all');
                            if (typeof added === 'boolean') {
                                return;
                            }
                            // Remove added icons from pending list
                            const pending = providerPendingIcons[prefix];
                            added.forEach((name) => {
                                delete pending[name];
                            });
                            // Cache API response
                            if (modules$1.coreModules.cache) {
                                modules$1.coreModules.cache(provider, data);
                            }
                        }
                        catch (err) {
                            console.error(err);
                        }
                    }
                    // Trigger update on next tick
                    loadedNewIcons(provider, prefix);
                });
            });
        });
    }
}
/**
 * Check if icon is being loaded
 */
const isPending = (icon) => {
    return (pendingIcons[icon.provider] !== void 0 &&
        pendingIcons[icon.provider][icon.prefix] !== void 0 &&
        pendingIcons[icon.provider][icon.prefix][icon.name] !== void 0);
};
/**
 * Load icons
 */
const loadIcons = (icons, callback) => {
    // Clean up and copy icons list
    const cleanedIcons = list.listToIcons(icons, true, functions$3.allowSimpleNames());
    // Sort icons by missing/loaded/pending
    // Pending means icon is either being requsted or is about to be requested
    const sortedIcons = sort.sortIcons(cleanedIcons);
    if (!sortedIcons.pending.length) {
        // Nothing to load
        let callCallback = true;
        if (callback) {
            setTimeout(() => {
                if (callCallback) {
                    callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);
                }
            });
        }
        return () => {
            callCallback = false;
        };
    }
    // Get all sources for pending icons
    const newIcons = Object.create(null);
    const sources = [];
    let lastProvider, lastPrefix;
    sortedIcons.pending.forEach((icon) => {
        const provider = icon.provider;
        const prefix = icon.prefix;
        if (prefix === lastPrefix && provider === lastProvider) {
            return;
        }
        lastProvider = provider;
        lastPrefix = prefix;
        sources.push({
            provider,
            prefix,
        });
        if (pendingIcons[provider] === void 0) {
            pendingIcons[provider] = Object.create(null);
        }
        const providerPendingIcons = pendingIcons[provider];
        if (providerPendingIcons[prefix] === void 0) {
            providerPendingIcons[prefix] = Object.create(null);
        }
        if (newIcons[provider] === void 0) {
            newIcons[provider] = Object.create(null);
        }
        const providerNewIcons = newIcons[provider];
        if (providerNewIcons[prefix] === void 0) {
            providerNewIcons[prefix] = [];
        }
    });
    // List of new icons
    const time = Date.now();
    // Filter pending icons list: find icons that are not being loaded yet
    // If icon was called before, it must exist in pendingIcons or storage, but because this
    // function is called right after sortIcons() that checks storage, icon is definitely not in storage.
    sortedIcons.pending.forEach((icon) => {
        const provider = icon.provider;
        const prefix = icon.prefix;
        const name = icon.name;
        const pendingQueue = pendingIcons[provider][prefix];
        if (pendingQueue[name] === void 0) {
            // New icon - add to pending queue to mark it as being loaded
            pendingQueue[name] = time;
            // Add it to new icons list to pass it to API module for loading
            newIcons[provider][prefix].push(name);
        }
    });
    // Load icons on next tick to make sure result is not returned before callback is stored and
    // to consolidate multiple synchronous loadIcons() calls into one asynchronous API call
    sources.forEach((source) => {
        const provider = source.provider;
        const prefix = source.prefix;
        if (newIcons[provider][prefix].length) {
            loadNewIcons(provider, prefix, newIcons[provider][prefix]);
        }
    });
    // Store callback and return abort function
    return callback
        ? callbacks.storeCallback(callback, sortedIcons, sources)
        : emptyCallback;
};
/**
 * Export module
 */
exports.API = {
    isPending,
    loadIcons,
};
});

var functions$1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.APIInternalFunctions = exports.APIFunctions = void 0;



exports.APIFunctions = {
    loadIcons: api.API.loadIcons,
    addAPIProvider: config.setAPIConfig,
};
exports.APIInternalFunctions = {
    getAPI: api.getRedundancyCache,
    getAPIConfig: config.getAPIConfig,
    setAPIModule: modules.setAPIModule,
};
});

var jsonp = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAPIModule = void 0;
let rootVar = null;
/**
 * Endpoint
 */
let endPoint = '{prefix}.js?icons={icons}&callback={callback}';
/**
 * Cache: provider:prefix = value
 */
const maxLengthCache = Object.create(null);
const pathCache = Object.create(null);
/**
 * Get hash for query
 *
 * Hash is used in JSONP callback name, so same queries end up with same JSONP callback,
 * allowing response to be cached in browser.
 */
function hash(str) {
    let total = 0, i;
    for (i = str.length - 1; i >= 0; i--) {
        total += str.charCodeAt(i);
    }
    return total % 999;
}
/**
 * Get root object
 */
function getGlobal() {
    // Create root
    if (rootVar === null) {
        // window
        const globalRoot = self;
        // Test for window.Iconify. If missing, create 'IconifyJSONP'
        let prefix = 'Iconify';
        let extraPrefix = '.cb';
        if (globalRoot[prefix] === void 0) {
            // Use 'IconifyJSONP' global
            prefix = 'IconifyJSONP';
            extraPrefix = '';
            if (globalRoot[prefix] === void 0) {
                globalRoot[prefix] = Object.create(null);
            }
            rootVar = globalRoot[prefix];
        }
        else {
            // Use 'Iconify.cb'
            const iconifyRoot = globalRoot[prefix];
            if (iconifyRoot.cb === void 0) {
                iconifyRoot.cb = Object.create(null);
            }
            rootVar = iconifyRoot.cb;
        }
        // Change end point
        endPoint = endPoint.replace('{callback}', prefix + extraPrefix + '.{cb}');
    }
    return rootVar;
}
/**
 * Return API module
 */
const getAPIModule = (getAPIConfig) => {
    /**
     * Calculate maximum icons list length for prefix
     */
    function calculateMaxLength(provider, prefix) {
        // Get config and store path
        const config = getAPIConfig(provider);
        if (!config) {
            return 0;
        }
        // Calculate
        let result;
        if (!config.maxURL) {
            result = 0;
        }
        else {
            let maxHostLength = 0;
            config.resources.forEach((item) => {
                const host = item;
                maxHostLength = Math.max(maxHostLength, host.length);
            });
            // Make sure global is set
            getGlobal();
            // Extra width: prefix (3) + counter (4) - '{cb}' (4)
            const extraLength = 3;
            // Get available length
            result =
                config.maxURL -
                    maxHostLength -
                    config.path.length -
                    endPoint
                        .replace('{provider}', provider)
                        .replace('{prefix}', prefix)
                        .replace('{icons}', '').length -
                    extraLength;
        }
        // Cache stuff and return result
        const cacheKey = provider + ':' + prefix;
        pathCache[cacheKey] = config.path;
        maxLengthCache[cacheKey] = result;
        return result;
    }
    /**
     * Prepare params
     */
    const prepare = (provider, prefix, icons) => {
        const results = [];
        // Get maximum icons list length
        const cacheKey = provider + ':' + prefix;
        let maxLength = maxLengthCache[cacheKey];
        if (maxLength === void 0) {
            maxLength = calculateMaxLength(provider, prefix);
        }
        // Split icons
        let item = {
            provider,
            prefix,
            icons: [],
        };
        let length = 0;
        icons.forEach((name, index) => {
            length += name.length + 1;
            if (length >= maxLength && index > 0) {
                // Next set
                results.push(item);
                item = {
                    provider,
                    prefix,
                    icons: [],
                };
                length = name.length;
            }
            item.icons.push(name);
        });
        results.push(item);
        return results;
    };
    /**
     * Load icons
     */
    const send = (host, params, status) => {
        const provider = params.provider;
        const prefix = params.prefix;
        const icons = params.icons;
        const iconsList = icons.join(',');
        const cacheKey = provider + ':' + prefix;
        // Create callback prefix
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const cbPrefix = prefix.split('-').shift().slice(0, 3);
        const global = getGlobal();
        // Callback hash
        let cbCounter = hash(provider + ':' + host + ':' + prefix + ':' + iconsList);
        while (global[cbPrefix + cbCounter] !== void 0) {
            cbCounter++;
        }
        const callbackName = cbPrefix + cbCounter;
        const path = pathCache[cacheKey] +
            endPoint
                .replace('{provider}', provider)
                .replace('{prefix}', prefix)
                .replace('{icons}', iconsList)
                .replace('{cb}', callbackName);
        global[callbackName] = (data) => {
            // Remove callback and complete query
            delete global[callbackName];
            status.done(data);
        };
        // Create URI
        const uri = host + path;
        // console.log('API query:', uri);
        // Create script and append it to head
        const script = document.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.src = uri;
        document.head.appendChild(script);
    };
    // Return functions
    return {
        prepare,
        send,
    };
};
exports.getAPIModule = getAPIModule;
});

var fetch_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAPIModule = exports.setFetch = void 0;
/**
 * Endpoint
 */
const endPoint = '{prefix}.json?icons={icons}';
/**
 * Cache
 */
const maxLengthCache = Object.create(null);
const pathCache = Object.create(null);
/**
 * Fetch function
 *
 * Use this to set 'cross-fetch' in node.js environment if you are retrieving icons on server side.
 * Not needed when using stuff like Next.js or SvelteKit because components use API only on client side.
 */
let fetchModule = null;
try {
    fetchModule = fetch;
}
catch (err) {
    //
}
function setFetch(fetch) {
    fetchModule = fetch;
}
exports.setFetch = setFetch;
/**
 * Return API module
 */
const getAPIModule = (getAPIConfig) => {
    /**
     * Calculate maximum icons list length for prefix
     */
    function calculateMaxLength(provider, prefix) {
        // Get config and store path
        const config = getAPIConfig(provider);
        if (!config) {
            return 0;
        }
        // Calculate
        let result;
        if (!config.maxURL) {
            result = 0;
        }
        else {
            let maxHostLength = 0;
            config.resources.forEach((item) => {
                const host = item;
                maxHostLength = Math.max(maxHostLength, host.length);
            });
            // Get available length
            result =
                config.maxURL -
                    maxHostLength -
                    config.path.length -
                    endPoint
                        .replace('{provider}', provider)
                        .replace('{prefix}', prefix)
                        .replace('{icons}', '').length;
        }
        // Cache stuff and return result
        const cacheKey = provider + ':' + prefix;
        pathCache[cacheKey] = config.path;
        maxLengthCache[cacheKey] = result;
        return result;
    }
    /**
     * Prepare params
     */
    const prepare = (provider, prefix, icons) => {
        const results = [];
        // Get maximum icons list length
        let maxLength = maxLengthCache[prefix];
        if (maxLength === void 0) {
            maxLength = calculateMaxLength(provider, prefix);
        }
        // Split icons
        let item = {
            provider,
            prefix,
            icons: [],
        };
        let length = 0;
        icons.forEach((name, index) => {
            length += name.length + 1;
            if (length >= maxLength && index > 0) {
                // Next set
                results.push(item);
                item = {
                    provider,
                    prefix,
                    icons: [],
                };
                length = name.length;
            }
            item.icons.push(name);
        });
        results.push(item);
        return results;
    };
    /**
     * Load icons
     */
    const send = (host, params, status) => {
        const provider = params.provider;
        const prefix = params.prefix;
        const icons = params.icons;
        const iconsList = icons.join(',');
        const cacheKey = provider + ':' + prefix;
        const path = pathCache[cacheKey] +
            endPoint
                .replace('{provider}', provider)
                .replace('{prefix}', prefix)
                .replace('{icons}', iconsList);
        if (!fetchModule) {
            // Fail: return 424 Failed Dependency (its not meant to be used like that, but it is the best match)
            status.done(void 0, 424);
            return;
        }
        // console.log('API query:', host + path);
        fetchModule(host + path)
            .then((response) => {
            if (response.status !== 200) {
                status.done(void 0, response.status);
                return;
            }
            return response.json();
        })
            .then((data) => {
            if (typeof data !== 'object' || data === null) {
                return;
            }
            // Store cache and complete
            status.done(data);
        })
            .catch((err) => {
            // Error
            status.done(void 0, err.errno);
        });
    };
    // Return functions
    return {
        prepare,
        send,
    };
};
exports.getAPIModule = getAPIModule;
});

var browserStorage = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeCache = exports.loadCache = exports.mock = exports.emptyList = exports.count = exports.config = void 0;

// After changing configuration change it in tests/*/fake_cache.ts
// Cache version. Bump when structure changes
const cacheVersion = 'iconify2';
// Cache keys
const cachePrefix = 'iconify';
const countKey = cachePrefix + '-count';
const versionKey = cachePrefix + '-version';
/**
 * Cache expiration
 */
const hour = 3600000;
const cacheExpiration = 168; // In hours
/**
 * Storage configuration
 */
exports.config = {
    local: true,
    session: true,
};
/**
 * Flag to check if storage has been loaded
 */
let loaded = false;
/**
 * Items counter
 */
exports.count = {
    local: 0,
    session: 0,
};
/**
 * List of empty items
 */
exports.emptyList = {
    local: [],
    session: [],
};
let _window = typeof window === 'undefined' ? {} : window;
function mock(fakeWindow) {
    loaded = false;
    _window = fakeWindow;
}
exports.mock = mock;
/**
 * Get global
 *
 * @param key
 */
function getGlobal(key) {
    const attr = key + 'Storage';
    try {
        if (_window &&
            _window[attr] &&
            typeof _window[attr].length === 'number') {
            return _window[attr];
        }
    }
    catch (err) {
        //
    }
    // Failed - mark as disabled
    exports.config[key] = false;
    return null;
}
/**
 * Change current count for storage
 */
function setCount(storage, key, value) {
    try {
        storage.setItem(countKey, value + '');
        exports.count[key] = value;
        return true;
    }
    catch (err) {
        return false;
    }
}
/**
 * Get current count from storage
 *
 * @param storage
 */
function getCount(storage) {
    const count = storage.getItem(countKey);
    if (count) {
        const total = parseInt(count);
        return total ? total : 0;
    }
    return 0;
}
/**
 * Initialize storage
 *
 * @param storage
 * @param key
 */
function initCache(storage, key) {
    try {
        storage.setItem(versionKey, cacheVersion);
    }
    catch (err) {
        //
    }
    setCount(storage, key, 0);
}
/**
 * Destroy old cache
 *
 * @param storage
 */
function destroyCache(storage) {
    try {
        const total = getCount(storage);
        for (let i = 0; i < total; i++) {
            storage.removeItem(cachePrefix + i);
        }
    }
    catch (err) {
        //
    }
}
/**
 * Load icons from cache
 */
const loadCache = () => {
    if (loaded) {
        return;
    }
    loaded = true;
    // Minimum time
    const minTime = Math.floor(Date.now() / hour) - cacheExpiration;
    // Load data from storage
    function load(key) {
        const func = getGlobal(key);
        if (!func) {
            return;
        }
        // Get one item from storage
        const getItem = (index) => {
            const name = cachePrefix + index;
            const item = func.getItem(name);
            if (typeof item !== 'string') {
                // Does not exist
                return false;
            }
            // Get item, validate it
            let valid = true;
            try {
                // Parse, check time stamp
                const data = JSON.parse(item);
                if (typeof data !== 'object' ||
                    typeof data.cached !== 'number' ||
                    data.cached < minTime ||
                    typeof data.provider !== 'string' ||
                    typeof data.data !== 'object' ||
                    typeof data.data.prefix !== 'string') {
                    valid = false;
                }
                else {
                    // Add icon set
                    const provider = data.provider;
                    const prefix = data.data.prefix;
                    const storage = storage_1.getStorage(provider, prefix);
                    valid = storage_1.addIconSet(storage, data.data);
                }
            }
            catch (err) {
                valid = false;
            }
            if (!valid) {
                func.removeItem(name);
            }
            return valid;
        };
        try {
            // Get version
            const version = func.getItem(versionKey);
            if (version !== cacheVersion) {
                if (version) {
                    // Version is set, but invalid - remove old entries
                    destroyCache(func);
                }
                // Empty data
                initCache(func, key);
                return;
            }
            // Get number of stored items
            let total = getCount(func);
            for (let i = total - 1; i >= 0; i--) {
                if (!getItem(i)) {
                    // Remove item
                    if (i === total - 1) {
                        // Last item - reduce country
                        total--;
                    }
                    else {
                        // Mark as empty
                        exports.emptyList[key].push(i);
                    }
                }
            }
            // Update total
            setCount(func, key, total);
        }
        catch (err) {
            //
        }
    }
    for (const key in exports.config) {
        load(key);
    }
};
exports.loadCache = loadCache;
/**
 * Function to cache icons
 */
const storeCache = (provider, data) => {
    if (!loaded) {
        exports.loadCache();
    }
    function store(key) {
        if (!exports.config[key]) {
            return false;
        }
        const func = getGlobal(key);
        if (!func) {
            return false;
        }
        // Get item index
        let index = exports.emptyList[key].shift();
        if (index === void 0) {
            // Create new index
            index = exports.count[key];
            if (!setCount(func, key, index + 1)) {
                return false;
            }
        }
        // Create and save item
        try {
            const item = {
                cached: Math.floor(Date.now() / hour),
                provider,
                data,
            };
            func.setItem(cachePrefix + index, JSON.stringify(item));
        }
        catch (err) {
            return false;
        }
        return true;
    }
    // Attempt to store at localStorage first, then at sessionStorage
    if (!store('local')) {
        store('session');
    }
};
exports.storeCache = storeCache;
});

var functions = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.toggleBrowserCache = void 0;

/**
 * Toggle cache
 */
function toggleBrowserCache(storage, value) {
    switch (storage) {
        case 'local':
        case 'session':
            browserStorage.config[storage] = value;
            break;
        case 'all':
            for (const key in browserStorage.config) {
                browserStorage.config[key] = value;
            }
            break;
    }
}
exports.toggleBrowserCache = toggleBrowserCache;
});

var shorthand = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.alignmentFromString = exports.flipFromString = void 0;
const separator = /[\s,]+/;
/**
 * Apply "flip" string to icon customisations
 */
function flipFromString(custom, flip) {
    flip.split(separator).forEach((str) => {
        const value = str.trim();
        switch (value) {
            case 'horizontal':
                custom.hFlip = true;
                break;
            case 'vertical':
                custom.vFlip = true;
                break;
        }
    });
}
exports.flipFromString = flipFromString;
/**
 * Apply "align" string to icon customisations
 */
function alignmentFromString(custom, align) {
    align.split(separator).forEach((str) => {
        const value = str.trim();
        switch (value) {
            case 'left':
            case 'center':
            case 'right':
                custom.hAlign = value;
                break;
            case 'top':
            case 'middle':
            case 'bottom':
                custom.vAlign = value;
                break;
            case 'slice':
            case 'crop':
                custom.slice = true;
                break;
            case 'meet':
                custom.slice = false;
        }
    });
}
exports.alignmentFromString = alignmentFromString;
});

var rotate = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.rotateFromString = void 0;
/**
 * Get rotation value
 */
function rotateFromString(value) {
    const units = value.replace(/^-?[0-9.]*/, '');
    function cleanup(value) {
        while (value < 0) {
            value += 4;
        }
        return value % 4;
    }
    if (units === '') {
        const num = parseInt(value);
        return isNaN(num) ? 0 : cleanup(num);
    }
    else if (units !== value) {
        let split = 0;
        switch (units) {
            case '%':
                // 25% -> 1, 50% -> 2, ...
                split = 25;
                break;
            case 'deg':
                // 90deg -> 1, 180deg -> 2, ...
                split = 90;
        }
        if (split) {
            let num = parseFloat(value.slice(0, value.length - units.length));
            if (isNaN(num)) {
                return 0;
            }
            num = num / split;
            return num % 1 === 0 ? cleanup(num) : 0;
        }
    }
    return 0;
}
exports.rotateFromString = rotateFromString;
});

/**
 * Default SVG attributes
 */
const svgDefaults = {
    'xmlns': 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    'aria-hidden': true,
    'role': 'img',
};
/**
 * Generate icon from properties
 */
function render(
// Icon must be validated before calling this function
icon, 
// Properties
props) {
    const customisations$1 = customisations.mergeCustomisations(customisations.defaults, props);
    const componentProps = Object.assign({}, svgDefaults);
    // Create style if missing
    let style = typeof props.style === 'string' ? props.style : '';
    // Get element properties
    for (let key in props) {
        const value = props[key];
        if (value === void 0) {
            continue;
        }
        switch (key) {
            // Properties to ignore
            case 'icon':
            case 'style':
            case 'onLoad':
                break;
            // Boolean attributes
            case 'inline':
            case 'hFlip':
            case 'vFlip':
                customisations$1[key] =
                    value === true || value === 'true' || value === 1;
                break;
            // Flip as string: 'horizontal,vertical'
            case 'flip':
                if (typeof value === 'string') {
                    shorthand.flipFromString(customisations$1, value);
                }
                break;
            // Alignment as string
            case 'align':
                if (typeof value === 'string') {
                    shorthand.alignmentFromString(customisations$1, value);
                }
                break;
            // Color: copy to style, add extra ';' in case style is missing it
            case 'color':
                style =
                    style +
                        (style.length > 0 && style.trim().slice(-1) !== ';'
                            ? ';'
                            : '') +
                        'color: ' +
                        value +
                        '; ';
                break;
            // Rotation as string
            case 'rotate':
                if (typeof value === 'string') {
                    customisations$1[key] = rotate.rotateFromString(value);
                }
                else if (typeof value === 'number') {
                    customisations$1[key] = value;
                }
                break;
            // Remove aria-hidden
            case 'ariaHidden':
            case 'aria-hidden':
                if (value !== true && value !== 'true') {
                    delete componentProps['aria-hidden'];
                }
                break;
            // Copy missing property if it does not exist in customisations
            default:
                if (customisations.defaults[key] === void 0) {
                    componentProps[key] = value;
                }
        }
    }
    // Generate icon
    const item = build.iconToSVG(icon, customisations$1);
    // Add icon stuff
    for (let key in item.attributes) {
        componentProps[key] =
            item.attributes[key];
    }
    if (item.inline) {
        // Style overrides it
        style = 'vertical-align: -0.125em; ' + style;
    }
    // Style
    if (style !== '') {
        componentProps.style = style;
    }
    // Counter for ids based on "id" property to render icons consistently on server and client
    let localCounter = 0;
    const id$1 = props.id;
    // Generate HTML
    return {
        attributes: componentProps,
        body: id.replaceIDs(item.body, id$1 ? () => id$1 + '-' + localCounter++ : 'iconify-svelte-'),
    };
}

// Core
/**
 * Enable and disable browser cache
 */
const enableCache = (storage) => functions.toggleBrowserCache(storage, true);
const disableCache = (storage) => functions.toggleBrowserCache(storage, false);
/* Storage functions */
/**
 * Check if icon exists
 */
const iconExists = functions$3.storageFunctions.iconExists;
/**
 * Get icon data
 */
const getIcon = functions$3.storageFunctions.getIcon;
/**
 * List available icons
 */
const listIcons = functions$3.storageFunctions.listIcons;
/**
 * Add one icon
 */
const addIcon = functions$3.storageFunctions.addIcon;
/**
 * Add icon set
 */
const addCollection = functions$3.storageFunctions.addCollection;
/* Builder functions */
/**
 * Calculate icon size
 */
const calculateSize = functions$2.builderFunctions.calculateSize;
/**
 * Replace unique ids in content
 */
const replaceIDs = functions$2.builderFunctions.replaceIDs;
/**
 * Build SVG
 */
const buildIcon = functions$2.builderFunctions.buildIcon;
/* API functions */
/**
 * Load icons
 */
const loadIcons = functions$1.APIFunctions.loadIcons;
/**
 * Add API provider
 */
const addAPIProvider = functions$1.APIFunctions.addAPIProvider;
/**
 * Export internal functions that can be used by third party implementations
 */
const _api = functions$1.APIInternalFunctions;
/**
 * Initialise stuff
 */
// Enable short names
functions$3.allowSimpleNames(true);
// Set API
modules$1.coreModules.api = api.API;
// Use Fetch API by default
let getAPIModule = fetch_1.getAPIModule;
try {
    if (typeof document !== 'undefined' && typeof window !== 'undefined') {
        // If window and document exist, attempt to load whatever module is available, otherwise use Fetch API
        getAPIModule =
            typeof fetch === 'function' && typeof Promise === 'function'
                ? fetch_1.getAPIModule
                : jsonp.getAPIModule;
    }
}
catch (err) {
    //
}
modules.setAPIModule('', getAPIModule(config.getAPIConfig));
/**
 * Function to enable node-fetch for getting icons on server side
 */
_api.setFetch = (nodeFetch) => {
    fetch_1.setFetch(nodeFetch);
    if (getAPIModule !== fetch_1.getAPIModule) {
        getAPIModule = fetch_1.getAPIModule;
        modules.setAPIModule('', getAPIModule(config.getAPIConfig));
    }
};
/**
 * Browser stuff
 */
if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    // Set cache and load existing cache
    modules$1.coreModules.cache = browserStorage.storeCache;
    browserStorage.loadCache();
    const _window = window;
    // Load icons from global "IconifyPreload"
    if (_window.IconifyPreload !== void 0) {
        const preload = _window.IconifyPreload;
        const err = 'Invalid IconifyPreload syntax.';
        if (typeof preload === 'object' && preload !== null) {
            (preload instanceof Array ? preload : [preload]).forEach((item) => {
                try {
                    if (
                    // Check if item is an object and not null/array
                    typeof item !== 'object' ||
                        item === null ||
                        item instanceof Array ||
                        // Check for 'icons' and 'prefix'
                        typeof item.icons !== 'object' ||
                        typeof item.prefix !== 'string' ||
                        // Add icon set
                        !addCollection(item)) {
                        console.error(err);
                    }
                }
                catch (e) {
                    console.error(err);
                }
            });
        }
    }
    // Set API from global "IconifyProviders"
    if (_window.IconifyProviders !== void 0) {
        const providers = _window.IconifyProviders;
        if (typeof providers === 'object' && providers !== null) {
            for (let key in providers) {
                const err = 'IconifyProviders[' + key + '] is invalid.';
                try {
                    const value = providers[key];
                    if (typeof value !== 'object' ||
                        !value ||
                        value.resources === void 0) {
                        continue;
                    }
                    if (!config.setAPIConfig(key, value)) {
                        console.error(err);
                    }
                }
                catch (e) {
                    console.error(err);
                }
            }
        }
    }
}
/**
 * Check if component needs to be updated
 */
function checkIconState(icon$1, state, mounted, callback, onload) {
    // Abort loading icon
    function abortLoading() {
        if (state.loading) {
            state.loading.abort();
            state.loading = null;
        }
    }
    // Icon is an object
    if (typeof icon$1 === 'object' &&
        icon$1 !== null &&
        typeof icon$1.body === 'string') {
        // Stop loading
        state.name = '';
        abortLoading();
        return { data: icon.fullIcon(icon$1) };
    }
    // Invalid icon?
    let iconName;
    if (typeof icon$1 !== 'string' ||
        (iconName = name.stringToIcon(icon$1, false, true)) === null) {
        abortLoading();
        return null;
    }
    // Load icon
    const data = functions$3.getIconData(iconName);
    if (data === null) {
        // Icon needs to be loaded
        // Do not load icon until component is mounted
        if (mounted && (!state.loading || state.loading.name !== icon$1)) {
            // New icon to load
            abortLoading();
            state.name = '';
            state.loading = {
                name: icon$1,
                abort: api.API.loadIcons([iconName], callback),
            };
        }
        return null;
    }
    // Icon data is available
    abortLoading();
    if (state.name !== icon$1) {
        state.name = icon$1;
        if (onload && !state.destroyed) {
            onload(icon$1);
        }
    }
    // Add classes
    const classes = ['iconify'];
    if (iconName.prefix !== '') {
        classes.push('iconify--' + iconName.prefix);
    }
    if (iconName.provider !== '') {
        classes.push('iconify--' + iconName.provider);
    }
    return { data, classes };
}
/**
 * Generate icon
 */
function generateIcon(icon, props) {
    return icon ? render(icon, props) : null;
}

/* src/Icon.svelte generated by Svelte v3.38.3 */

function create_if_block(ctx) {
	let svg;
	let raw_value = /*data*/ ctx[0].body + "";
	let svg_levels = [/*data*/ ctx[0].attributes];
	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	return {
		c() {
			svg = svg_element("svg");
			set_svg_attributes(svg, svg_data);
		},
		m(target, anchor) {
			insert(target, svg, anchor);
			svg.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*data*/ 1 && raw_value !== (raw_value = /*data*/ ctx[0].body + "")) svg.innerHTML = raw_value;			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [dirty & /*data*/ 1 && /*data*/ ctx[0].attributes]));
		},
		d(detaching) {
			if (detaching) detach(svg);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*data*/ ctx[0] !== null && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*data*/ ctx[0] !== null) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const state = {
		// Last icon name
		name: "",
		// Loading status
		loading: null,
		// Destroyed status
		destroyed: false
	};

	// Mounted status
	let mounted = false;

	// Callback counter
	let counter = 0;

	// Generated data
	let data;

	// Increase counter when loaded to force re-calculation of data
	function loaded() {
		$$invalidate(3, counter++, counter);
	}

	// Force re-render
	onMount(() => {
		$$invalidate(2, mounted = true);
	});

	// Abort loading when component is destroyed
	onDestroy(() => {
		$$invalidate(1, state.destroyed = true, state);

		if (state.loading) {
			state.loading.abort();
			$$invalidate(1, state.loading = null, state);
		}
	});

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$$.update = () => {
		{
			const iconData = checkIconState($$props.icon, state, mounted, loaded, $$props.onLoad);
			$$invalidate(0, data = iconData ? generateIcon(iconData.data, $$props) : null);

			if (data && iconData.classes) {
				// Add classes
				$$invalidate(
					0,
					data.attributes["class"] = (typeof $$props["class"] === "string"
					? $$props["class"] + " "
					: "") + iconData.classes.join(" "),
					data
				);
			}
		}
	};

	$$props = exclude_internal_props($$props);
	return [data, state, mounted, counter];
}

class Icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Icon);



/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _assertThisInitialized)
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classCallCheck)
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _defineProperty)
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _getPrototypeOf)
/* harmony export */ });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _inherits)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _possibleConstructorReturn)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "./node_modules/svelte/easing/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/svelte/easing/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linear": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.identity),
/* harmony export */   "backIn": () => (/* binding */ backIn),
/* harmony export */   "backInOut": () => (/* binding */ backInOut),
/* harmony export */   "backOut": () => (/* binding */ backOut),
/* harmony export */   "bounceIn": () => (/* binding */ bounceIn),
/* harmony export */   "bounceInOut": () => (/* binding */ bounceInOut),
/* harmony export */   "bounceOut": () => (/* binding */ bounceOut),
/* harmony export */   "circIn": () => (/* binding */ circIn),
/* harmony export */   "circInOut": () => (/* binding */ circInOut),
/* harmony export */   "circOut": () => (/* binding */ circOut),
/* harmony export */   "cubicIn": () => (/* binding */ cubicIn),
/* harmony export */   "cubicInOut": () => (/* binding */ cubicInOut),
/* harmony export */   "cubicOut": () => (/* binding */ cubicOut),
/* harmony export */   "elasticIn": () => (/* binding */ elasticIn),
/* harmony export */   "elasticInOut": () => (/* binding */ elasticInOut),
/* harmony export */   "elasticOut": () => (/* binding */ elasticOut),
/* harmony export */   "expoIn": () => (/* binding */ expoIn),
/* harmony export */   "expoInOut": () => (/* binding */ expoInOut),
/* harmony export */   "expoOut": () => (/* binding */ expoOut),
/* harmony export */   "quadIn": () => (/* binding */ quadIn),
/* harmony export */   "quadInOut": () => (/* binding */ quadInOut),
/* harmony export */   "quadOut": () => (/* binding */ quadOut),
/* harmony export */   "quartIn": () => (/* binding */ quartIn),
/* harmony export */   "quartInOut": () => (/* binding */ quartInOut),
/* harmony export */   "quartOut": () => (/* binding */ quartOut),
/* harmony export */   "quintIn": () => (/* binding */ quintIn),
/* harmony export */   "quintInOut": () => (/* binding */ quintInOut),
/* harmony export */   "quintOut": () => (/* binding */ quintOut),
/* harmony export */   "sineIn": () => (/* binding */ sineIn),
/* harmony export */   "sineInOut": () => (/* binding */ sineInOut),
/* harmony export */   "sineOut": () => (/* binding */ sineOut)
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");


/*
Adapted from https://github.com/mattdesl
Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
*/
function backInOut(t) {
    const s = 1.70158 * 1.525;
    if ((t *= 2) < 1)
        return 0.5 * (t * t * ((s + 1) * t - s));
    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);
}
function backIn(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
}
function backOut(t) {
    const s = 1.70158;
    return --t * t * ((s + 1) * t + s) + 1;
}
function bounceOut(t) {
    const a = 4.0 / 11.0;
    const b = 8.0 / 11.0;
    const c = 9.0 / 10.0;
    const ca = 4356.0 / 361.0;
    const cb = 35442.0 / 1805.0;
    const cc = 16061.0 / 1805.0;
    const t2 = t * t;
    return t < a
        ? 7.5625 * t2
        : t < b
            ? 9.075 * t2 - 9.9 * t + 3.4
            : t < c
                ? ca * t2 - cb * t + cc
                : 10.8 * t * t - 20.52 * t + 10.72;
}
function bounceInOut(t) {
    return t < 0.5
        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))
        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;
}
function bounceIn(t) {
    return 1.0 - bounceOut(1.0 - t);
}
function circInOut(t) {
    if ((t *= 2) < 1)
        return -0.5 * (Math.sqrt(1 - t * t) - 1);
    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
}
function circIn(t) {
    return 1.0 - Math.sqrt(1.0 - t * t);
}
function circOut(t) {
    return Math.sqrt(1 - --t * t);
}
function cubicInOut(t) {
    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}
function cubicIn(t) {
    return t * t * t;
}
function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}
function elasticInOut(t) {
    return t < 0.5
        ? 0.5 *
            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *
            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))
        : 0.5 *
            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *
            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +
            1.0;
}
function elasticIn(t) {
    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));
}
function elasticOut(t) {
    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);
}
function expoInOut(t) {
    return t === 0.0 || t === 1.0
        ? t
        : t < 0.5
            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)
            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;
}
function expoIn(t) {
    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));
}
function expoOut(t) {
    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);
}
function quadInOut(t) {
    t /= 0.5;
    if (t < 1)
        return 0.5 * t * t;
    t--;
    return -0.5 * (t * (t - 2) - 1);
}
function quadIn(t) {
    return t * t;
}
function quadOut(t) {
    return -t * (t - 2.0);
}
function quartInOut(t) {
    return t < 0.5
        ? +8.0 * Math.pow(t, 4.0)
        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;
}
function quartIn(t) {
    return Math.pow(t, 4.0);
}
function quartOut(t) {
    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;
}
function quintInOut(t) {
    if ((t *= 2) < 1)
        return 0.5 * t * t * t * t * t;
    return 0.5 * ((t -= 2) * t * t * t * t + 2);
}
function quintIn(t) {
    return t * t * t * t * t;
}
function quintOut(t) {
    return --t * t * t * t * t + 1;
}
function sineInOut(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
}
function sineIn(t) {
    const v = Math.cos(t * Math.PI * 0.5);
    if (Math.abs(v) < 1e-14)
        return 1;
    else
        return 1 - v;
}
function sineOut(t) {
    return Math.sin((t * Math.PI) / 2);
}




/***/ }),

/***/ "./node_modules/svelte/index.mjs":
/*!***************************************!*\
  !*** ./node_modules/svelte/index.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SvelteComponent": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev),
/* harmony export */   "SvelteComponentTyped": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentTyped),
/* harmony export */   "afterUpdate": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.afterUpdate),
/* harmony export */   "beforeUpdate": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.beforeUpdate),
/* harmony export */   "createEventDispatcher": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.createEventDispatcher),
/* harmony export */   "getAllContexts": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getAllContexts),
/* harmony export */   "getContext": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getContext),
/* harmony export */   "hasContext": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.hasContext),
/* harmony export */   "onDestroy": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onDestroy),
/* harmony export */   "onMount": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onMount),
/* harmony export */   "setContext": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.setContext),
/* harmony export */   "tick": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.tick)
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");



/***/ }),

/***/ "./node_modules/svelte/internal/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/svelte/internal/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HtmlTag": () => (/* binding */ HtmlTag),
/* harmony export */   "HtmlTagHydration": () => (/* binding */ HtmlTagHydration),
/* harmony export */   "SvelteComponent": () => (/* binding */ SvelteComponent),
/* harmony export */   "SvelteComponentDev": () => (/* binding */ SvelteComponentDev),
/* harmony export */   "SvelteComponentTyped": () => (/* binding */ SvelteComponentTyped),
/* harmony export */   "SvelteElement": () => (/* binding */ SvelteElement),
/* harmony export */   "action_destroyer": () => (/* binding */ action_destroyer),
/* harmony export */   "add_attribute": () => (/* binding */ add_attribute),
/* harmony export */   "add_classes": () => (/* binding */ add_classes),
/* harmony export */   "add_flush_callback": () => (/* binding */ add_flush_callback),
/* harmony export */   "add_location": () => (/* binding */ add_location),
/* harmony export */   "add_render_callback": () => (/* binding */ add_render_callback),
/* harmony export */   "add_resize_listener": () => (/* binding */ add_resize_listener),
/* harmony export */   "add_transform": () => (/* binding */ add_transform),
/* harmony export */   "afterUpdate": () => (/* binding */ afterUpdate),
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "append_dev": () => (/* binding */ append_dev),
/* harmony export */   "append_empty_stylesheet": () => (/* binding */ append_empty_stylesheet),
/* harmony export */   "append_hydration": () => (/* binding */ append_hydration),
/* harmony export */   "append_hydration_dev": () => (/* binding */ append_hydration_dev),
/* harmony export */   "append_styles": () => (/* binding */ append_styles),
/* harmony export */   "assign": () => (/* binding */ assign),
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "attr_dev": () => (/* binding */ attr_dev),
/* harmony export */   "attribute_to_object": () => (/* binding */ attribute_to_object),
/* harmony export */   "beforeUpdate": () => (/* binding */ beforeUpdate),
/* harmony export */   "bind": () => (/* binding */ bind),
/* harmony export */   "binding_callbacks": () => (/* binding */ binding_callbacks),
/* harmony export */   "blank_object": () => (/* binding */ blank_object),
/* harmony export */   "bubble": () => (/* binding */ bubble),
/* harmony export */   "check_outros": () => (/* binding */ check_outros),
/* harmony export */   "children": () => (/* binding */ children),
/* harmony export */   "claim_component": () => (/* binding */ claim_component),
/* harmony export */   "claim_element": () => (/* binding */ claim_element),
/* harmony export */   "claim_html_tag": () => (/* binding */ claim_html_tag),
/* harmony export */   "claim_space": () => (/* binding */ claim_space),
/* harmony export */   "claim_svg_element": () => (/* binding */ claim_svg_element),
/* harmony export */   "claim_text": () => (/* binding */ claim_text),
/* harmony export */   "clear_loops": () => (/* binding */ clear_loops),
/* harmony export */   "component_subscribe": () => (/* binding */ component_subscribe),
/* harmony export */   "compute_rest_props": () => (/* binding */ compute_rest_props),
/* harmony export */   "compute_slots": () => (/* binding */ compute_slots),
/* harmony export */   "createEventDispatcher": () => (/* binding */ createEventDispatcher),
/* harmony export */   "create_animation": () => (/* binding */ create_animation),
/* harmony export */   "create_bidirectional_transition": () => (/* binding */ create_bidirectional_transition),
/* harmony export */   "create_component": () => (/* binding */ create_component),
/* harmony export */   "create_in_transition": () => (/* binding */ create_in_transition),
/* harmony export */   "create_out_transition": () => (/* binding */ create_out_transition),
/* harmony export */   "create_slot": () => (/* binding */ create_slot),
/* harmony export */   "create_ssr_component": () => (/* binding */ create_ssr_component),
/* harmony export */   "current_component": () => (/* binding */ current_component),
/* harmony export */   "custom_event": () => (/* binding */ custom_event),
/* harmony export */   "dataset_dev": () => (/* binding */ dataset_dev),
/* harmony export */   "debug": () => (/* binding */ debug),
/* harmony export */   "destroy_block": () => (/* binding */ destroy_block),
/* harmony export */   "destroy_component": () => (/* binding */ destroy_component),
/* harmony export */   "destroy_each": () => (/* binding */ destroy_each),
/* harmony export */   "detach": () => (/* binding */ detach),
/* harmony export */   "detach_after_dev": () => (/* binding */ detach_after_dev),
/* harmony export */   "detach_before_dev": () => (/* binding */ detach_before_dev),
/* harmony export */   "detach_between_dev": () => (/* binding */ detach_between_dev),
/* harmony export */   "detach_dev": () => (/* binding */ detach_dev),
/* harmony export */   "dirty_components": () => (/* binding */ dirty_components),
/* harmony export */   "dispatch_dev": () => (/* binding */ dispatch_dev),
/* harmony export */   "each": () => (/* binding */ each),
/* harmony export */   "element": () => (/* binding */ element),
/* harmony export */   "element_is": () => (/* binding */ element_is),
/* harmony export */   "empty": () => (/* binding */ empty),
/* harmony export */   "end_hydrating": () => (/* binding */ end_hydrating),
/* harmony export */   "escape": () => (/* binding */ escape),
/* harmony export */   "escape_attribute_value": () => (/* binding */ escape_attribute_value),
/* harmony export */   "escape_object": () => (/* binding */ escape_object),
/* harmony export */   "escaped": () => (/* binding */ escaped),
/* harmony export */   "exclude_internal_props": () => (/* binding */ exclude_internal_props),
/* harmony export */   "fix_and_destroy_block": () => (/* binding */ fix_and_destroy_block),
/* harmony export */   "fix_and_outro_and_destroy_block": () => (/* binding */ fix_and_outro_and_destroy_block),
/* harmony export */   "fix_position": () => (/* binding */ fix_position),
/* harmony export */   "flush": () => (/* binding */ flush),
/* harmony export */   "getAllContexts": () => (/* binding */ getAllContexts),
/* harmony export */   "getContext": () => (/* binding */ getContext),
/* harmony export */   "get_all_dirty_from_scope": () => (/* binding */ get_all_dirty_from_scope),
/* harmony export */   "get_binding_group_value": () => (/* binding */ get_binding_group_value),
/* harmony export */   "get_current_component": () => (/* binding */ get_current_component),
/* harmony export */   "get_custom_elements_slots": () => (/* binding */ get_custom_elements_slots),
/* harmony export */   "get_root_for_style": () => (/* binding */ get_root_for_style),
/* harmony export */   "get_slot_changes": () => (/* binding */ get_slot_changes),
/* harmony export */   "get_spread_object": () => (/* binding */ get_spread_object),
/* harmony export */   "get_spread_update": () => (/* binding */ get_spread_update),
/* harmony export */   "get_store_value": () => (/* binding */ get_store_value),
/* harmony export */   "globals": () => (/* binding */ globals),
/* harmony export */   "group_outros": () => (/* binding */ group_outros),
/* harmony export */   "handle_promise": () => (/* binding */ handle_promise),
/* harmony export */   "hasContext": () => (/* binding */ hasContext),
/* harmony export */   "has_prop": () => (/* binding */ has_prop),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "init": () => (/* binding */ init),
/* harmony export */   "insert": () => (/* binding */ insert),
/* harmony export */   "insert_dev": () => (/* binding */ insert_dev),
/* harmony export */   "insert_hydration": () => (/* binding */ insert_hydration),
/* harmony export */   "insert_hydration_dev": () => (/* binding */ insert_hydration_dev),
/* harmony export */   "intros": () => (/* binding */ intros),
/* harmony export */   "invalid_attribute_name_character": () => (/* binding */ invalid_attribute_name_character),
/* harmony export */   "is_client": () => (/* binding */ is_client),
/* harmony export */   "is_crossorigin": () => (/* binding */ is_crossorigin),
/* harmony export */   "is_empty": () => (/* binding */ is_empty),
/* harmony export */   "is_function": () => (/* binding */ is_function),
/* harmony export */   "is_promise": () => (/* binding */ is_promise),
/* harmony export */   "listen": () => (/* binding */ listen),
/* harmony export */   "listen_dev": () => (/* binding */ listen_dev),
/* harmony export */   "loop": () => (/* binding */ loop),
/* harmony export */   "loop_guard": () => (/* binding */ loop_guard),
/* harmony export */   "missing_component": () => (/* binding */ missing_component),
/* harmony export */   "mount_component": () => (/* binding */ mount_component),
/* harmony export */   "noop": () => (/* binding */ noop),
/* harmony export */   "not_equal": () => (/* binding */ not_equal),
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "null_to_empty": () => (/* binding */ null_to_empty),
/* harmony export */   "object_without_properties": () => (/* binding */ object_without_properties),
/* harmony export */   "onDestroy": () => (/* binding */ onDestroy),
/* harmony export */   "onMount": () => (/* binding */ onMount),
/* harmony export */   "once": () => (/* binding */ once),
/* harmony export */   "outro_and_destroy_block": () => (/* binding */ outro_and_destroy_block),
/* harmony export */   "prevent_default": () => (/* binding */ prevent_default),
/* harmony export */   "prop_dev": () => (/* binding */ prop_dev),
/* harmony export */   "query_selector_all": () => (/* binding */ query_selector_all),
/* harmony export */   "raf": () => (/* binding */ raf),
/* harmony export */   "run": () => (/* binding */ run),
/* harmony export */   "run_all": () => (/* binding */ run_all),
/* harmony export */   "safe_not_equal": () => (/* binding */ safe_not_equal),
/* harmony export */   "schedule_update": () => (/* binding */ schedule_update),
/* harmony export */   "select_multiple_value": () => (/* binding */ select_multiple_value),
/* harmony export */   "select_option": () => (/* binding */ select_option),
/* harmony export */   "select_options": () => (/* binding */ select_options),
/* harmony export */   "select_value": () => (/* binding */ select_value),
/* harmony export */   "self": () => (/* binding */ self),
/* harmony export */   "setContext": () => (/* binding */ setContext),
/* harmony export */   "set_attributes": () => (/* binding */ set_attributes),
/* harmony export */   "set_current_component": () => (/* binding */ set_current_component),
/* harmony export */   "set_custom_element_data": () => (/* binding */ set_custom_element_data),
/* harmony export */   "set_data": () => (/* binding */ set_data),
/* harmony export */   "set_data_dev": () => (/* binding */ set_data_dev),
/* harmony export */   "set_input_type": () => (/* binding */ set_input_type),
/* harmony export */   "set_input_value": () => (/* binding */ set_input_value),
/* harmony export */   "set_now": () => (/* binding */ set_now),
/* harmony export */   "set_raf": () => (/* binding */ set_raf),
/* harmony export */   "set_store_value": () => (/* binding */ set_store_value),
/* harmony export */   "set_style": () => (/* binding */ set_style),
/* harmony export */   "set_svg_attributes": () => (/* binding */ set_svg_attributes),
/* harmony export */   "space": () => (/* binding */ space),
/* harmony export */   "spread": () => (/* binding */ spread),
/* harmony export */   "src_url_equal": () => (/* binding */ src_url_equal),
/* harmony export */   "start_hydrating": () => (/* binding */ start_hydrating),
/* harmony export */   "stop_propagation": () => (/* binding */ stop_propagation),
/* harmony export */   "subscribe": () => (/* binding */ subscribe),
/* harmony export */   "svg_element": () => (/* binding */ svg_element),
/* harmony export */   "text": () => (/* binding */ text),
/* harmony export */   "tick": () => (/* binding */ tick),
/* harmony export */   "time_ranges_to_array": () => (/* binding */ time_ranges_to_array),
/* harmony export */   "to_number": () => (/* binding */ to_number),
/* harmony export */   "toggle_class": () => (/* binding */ toggle_class),
/* harmony export */   "transition_in": () => (/* binding */ transition_in),
/* harmony export */   "transition_out": () => (/* binding */ transition_out),
/* harmony export */   "trusted": () => (/* binding */ trusted),
/* harmony export */   "update_await_block_branch": () => (/* binding */ update_await_block_branch),
/* harmony export */   "update_keyed_each": () => (/* binding */ update_keyed_each),
/* harmony export */   "update_slot": () => (/* binding */ update_slot),
/* harmony export */   "update_slot_base": () => (/* binding */ update_slot_base),
/* harmony export */   "validate_component": () => (/* binding */ validate_component),
/* harmony export */   "validate_each_argument": () => (/* binding */ validate_each_argument),
/* harmony export */   "validate_each_keys": () => (/* binding */ validate_each_keys),
/* harmony export */   "validate_slots": () => (/* binding */ validate_slots),
/* harmony export */   "validate_store": () => (/* binding */ validate_store),
/* harmony export */   "xlink_attr": () => (/* binding */ xlink_attr)
/* harmony export */ });
function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function is_promise(value) {
    return value && typeof value === 'object' && typeof value.then === 'function';
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
}
function not_equal(a, b) {
    return a != a ? b == b : a !== b;
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
        result[key] = true;
    }
    return result;
}
function once(fn) {
    let ran = false;
    return function (...args) {
        if (ran)
            return;
        ran = true;
        fn.call(this, ...args);
    };
}
function null_to_empty(value) {
    return value == null ? '' : value;
}
function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
}
const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;
// used internally for testing
function set_now(fn) {
    now = fn;
}
function set_raf(fn) {
    raf = fn;
}

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * For testing purposes only!
 */
function clear_loops() {
    tasks.clear();
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
let is_hydrating = false;
function start_hydrating() {
    is_hydrating = true;
}
function end_hydrating() {
    is_hydrating = false;
}
function upper_bound(low, high, key, value) {
    // Return first index of value larger than input value in the range [low, high)
    while (low < high) {
        const mid = low + ((high - low) >> 1);
        if (key(mid) <= value) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return low;
}
function init_hydrate(target) {
    if (target.hydrate_init)
        return;
    target.hydrate_init = true;
    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>
    let children = target.childNodes;
    // If target is <head>, there may be children without claim_order
    if (target.nodeName === 'HEAD') {
        const myChildren = [];
        for (let i = 0; i < children.length; i++) {
            const node = children[i];
            if (node.claim_order !== undefined) {
                myChildren.push(node);
            }
        }
        children = myChildren;
    }
    /*
    * Reorder claimed children optimally.
    * We can reorder claimed children optimally by finding the longest subsequence of
    * nodes that are already claimed in order and only moving the rest. The longest
    * subsequence subsequence of nodes that are claimed in order can be found by
    * computing the longest increasing subsequence of .claim_order values.
    *
    * This algorithm is optimal in generating the least amount of reorder operations
    * possible.
    *
    * Proof:
    * We know that, given a set of reordering operations, the nodes that do not move
    * always form an increasing subsequence, since they do not move among each other
    * meaning that they must be already ordered among each other. Thus, the maximal
    * set of nodes that do not move form a longest increasing subsequence.
    */
    // Compute longest increasing subsequence
    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
    const m = new Int32Array(children.length + 1);
    // Predecessor indices + 1
    const p = new Int32Array(children.length);
    m[0] = -1;
    let longest = 0;
    for (let i = 0; i < children.length; i++) {
        const current = children[i].claim_order;
        // Find the largest subsequence length such that it ends in a value less than our current value
        // upper_bound returns first greater value, so we subtract one
        // with fast path for when we are on the current longest subsequence
        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;
        p[i] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
        m[newLen] = i;
        longest = Math.max(newLen, longest);
    }
    // The longest increasing subsequence of nodes (initially reversed)
    const lis = [];
    // The rest of the nodes, nodes that will be moved
    const toMove = [];
    let last = children.length - 1;
    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
        lis.push(children[cur - 1]);
        for (; last >= cur; last--) {
            toMove.push(children[last]);
        }
        last--;
    }
    for (; last >= 0; last--) {
        toMove.push(children[last]);
    }
    lis.reverse();
    // We sort the nodes being moved to guarantee that their insertion order matches the claim order
    toMove.sort((a, b) => a.claim_order - b.claim_order);
    // Finally, we move the nodes
    for (let i = 0, j = 0; i < toMove.length; i++) {
        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
            j++;
        }
        const anchor = j < lis.length ? lis[j] : null;
        target.insertBefore(toMove[i], anchor);
    }
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
}
function append_hydration(target, node) {
    if (is_hydrating) {
        init_hydrate(target);
        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {
            target.actual_end_child = target.firstChild;
        }
        // Skip nodes of undefined ordering
        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {
            target.actual_end_child = target.actual_end_child.nextSibling;
        }
        if (node !== target.actual_end_child) {
            // We only insert if the ordering of this node should be modified or the parent node is not target
            if (node.claim_order !== undefined || node.parentNode !== target) {
                target.insertBefore(node, target.actual_end_child);
            }
        }
        else {
            target.actual_end_child = node.nextSibling;
        }
    }
    else if (node.parentNode !== target || node.nextSibling !== null) {
        target.appendChild(node);
    }
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function insert_hydration(target, node, anchor) {
    if (is_hydrating && !anchor) {
        append_hydration(target, node);
    }
    else if (node.parentNode !== target || node.nextSibling != anchor) {
        target.insertBefore(node, anchor || null);
    }
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function element_is(name, is) {
    return document.createElement(name, { is });
}
function object_without_properties(obj, exclude) {
    const target = {};
    for (const k in obj) {
        if (has_prop(obj, k)
            // @ts-ignore
            && exclude.indexOf(k) === -1) {
            // @ts-ignore
            target[k] = obj[k];
        }
    }
    return target;
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function self(fn) {
    return function (event) {
        // @ts-ignore
        if (event.target === this)
            fn.call(this, event);
    };
}
function trusted(fn) {
    return function (event) {
        // @ts-ignore
        if (event.isTrusted)
            fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function set_custom_element_data(node, prop, value) {
    if (prop in node) {
        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
    }
    else {
        attr(node, prop, value);
    }
}
function xlink_attr(node, attribute, value) {
    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}
function get_binding_group_value(group, __value, checked) {
    const value = new Set();
    for (let i = 0; i < group.length; i += 1) {
        if (group[i].checked)
            value.add(group[i].__value);
    }
    if (!checked) {
        value.delete(__value);
    }
    return Array.from(value);
}
function to_number(value) {
    return value === '' ? null : +value;
}
function time_ranges_to_array(ranges) {
    const array = [];
    for (let i = 0; i < ranges.length; i += 1) {
        array.push({ start: ranges.start(i), end: ranges.end(i) });
    }
    return array;
}
function children(element) {
    return Array.from(element.childNodes);
}
function init_claim_info(nodes) {
    if (nodes.claim_info === undefined) {
        nodes.claim_info = { last_index: 0, total_claimed: 0 };
    }
}
function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
    // Try to find nodes in an order such that we lengthen the longest increasing subsequence
    init_claim_info(nodes);
    const resultNode = (() => {
        // We first try to find an element after the previous one
        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
            const node = nodes[i];
            if (predicate(node)) {
                const replacement = processNode(node);
                if (replacement === undefined) {
                    nodes.splice(i, 1);
                }
                else {
                    nodes[i] = replacement;
                }
                if (!dontUpdateLastIndex) {
                    nodes.claim_info.last_index = i;
                }
                return node;
            }
        }
        // Otherwise, we try to find one before
        // We iterate in reverse so that we don't go too far back
        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
            const node = nodes[i];
            if (predicate(node)) {
                const replacement = processNode(node);
                if (replacement === undefined) {
                    nodes.splice(i, 1);
                }
                else {
                    nodes[i] = replacement;
                }
                if (!dontUpdateLastIndex) {
                    nodes.claim_info.last_index = i;
                }
                else if (replacement === undefined) {
                    // Since we spliced before the last_index, we decrease it
                    nodes.claim_info.last_index--;
                }
                return node;
            }
        }
        // If we can't find any matching node, we create a new one
        return createNode();
    })();
    resultNode.claim_order = nodes.claim_info.total_claimed;
    nodes.claim_info.total_claimed += 1;
    return resultNode;
}
function claim_element_base(nodes, name, attributes, create_element) {
    return claim_node(nodes, (node) => node.nodeName === name, (node) => {
        const remove = [];
        for (let j = 0; j < node.attributes.length; j++) {
            const attribute = node.attributes[j];
            if (!attributes[attribute.name]) {
                remove.push(attribute.name);
            }
        }
        remove.forEach(v => node.removeAttribute(v));
        return undefined;
    }, () => create_element(name));
}
function claim_element(nodes, name, attributes) {
    return claim_element_base(nodes, name, attributes, element);
}
function claim_svg_element(nodes, name, attributes) {
    return claim_element_base(nodes, name, attributes, svg_element);
}
function claim_text(nodes, data) {
    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {
        const dataStr = '' + data;
        if (node.data.startsWith(dataStr)) {
            if (node.data.length !== dataStr.length) {
                return node.splitText(dataStr.length);
            }
        }
        else {
            node.data = dataStr;
        }
    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
    );
}
function claim_space(nodes) {
    return claim_text(nodes, ' ');
}
function find_comment(nodes, text, start) {
    for (let i = start; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {
            return i;
        }
    }
    return nodes.length;
}
function claim_html_tag(nodes) {
    // find html opening tag
    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);
    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);
    if (start_index === end_index) {
        return new HtmlTagHydration();
    }
    init_claim_info(nodes);
    const html_tag_nodes = nodes.splice(start_index, end_index + 1);
    detach(html_tag_nodes[0]);
    detach(html_tag_nodes[html_tag_nodes.length - 1]);
    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
    for (const n of claimed_nodes) {
        n.claim_order = nodes.claim_info.total_claimed;
        nodes.claim_info.total_claimed += 1;
    }
    return new HtmlTagHydration(claimed_nodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_input_type(input, type) {
    try {
        input.type = type;
    }
    catch (e) {
        // do nothing
    }
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    select.selectedIndex = -1; // no option should be selected
}
function select_options(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        option.selected = ~value.indexOf(option.__value);
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function select_multiple_value(select) {
    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
let crossorigin;
function is_crossorigin() {
    if (crossorigin === undefined) {
        crossorigin = false;
        try {
            if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
            }
        }
        catch (error) {
            crossorigin = true;
        }
    }
    return crossorigin;
}
function add_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    if (computed_style.position === 'static') {
        node.style.position = 'relative';
    }
    const iframe = element('iframe');
    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.tabIndex = -1;
    const crossorigin = is_crossorigin();
    let unsubscribe;
    if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', (event) => {
            if (event.source === iframe.contentWindow)
                fn();
        });
    }
    else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
    }
    append(node, iframe);
    return () => {
        if (crossorigin) {
            unsubscribe();
        }
        else if (unsubscribe && iframe.contentWindow) {
            unsubscribe();
        }
        detach(iframe);
    };
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
}
function query_selector_all(selector, parent = document.body) {
    return Array.from(parent.querySelectorAll(selector));
}
class HtmlTag {
    constructor() {
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            this.e = element(target.nodeName);
            this.t = target;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}
class HtmlTagHydration extends HtmlTag {
    constructor(claimed_nodes) {
        super();
        this.e = this.n = null;
        this.l = claimed_nodes;
    }
    c(html) {
        if (this.l) {
            this.n = this.l;
        }
        else {
            super.c(html);
        }
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert_hydration(this.t, this.n[i], anchor);
        }
    }
}
function attribute_to_object(attributes) {
    const result = {};
    for (const attribute of attributes) {
        result[attribute.name] = attribute.value;
    }
    return result;
}
function get_custom_elements_slots(element) {
    const result = {};
    element.childNodes.forEach((node) => {
        result[node.slot || 'default'] = true;
    });
    return result;
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
function getAllContexts() {
    return get_current_component().$$.context;
}
function hasContext(key) {
    return get_current_component().$$.context.has(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const intros = { enabled: false };
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config();
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            if (info.blocks[i] === block) {
                                info.blocks[i] = null;
                            }
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}
function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const { resolved } = info;
    if (info.current === info.then) {
        child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_destroy_block(block, lookup) {
    block.f();
    destroy_block(block, lookup);
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));
        if (keys.has(key)) {
            throw new Error('Cannot have duplicate keys in a keyed each');
        }
        keys.add(key);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

// source: https://html.spec.whatwg.org/multipage/indices.html
const boolean_attributes = new Set([
    'allowfullscreen',
    'allowpaymentrequest',
    'async',
    'autofocus',
    'autoplay',
    'checked',
    'controls',
    'default',
    'defer',
    'disabled',
    'formnovalidate',
    'hidden',
    'ismap',
    'loop',
    'multiple',
    'muted',
    'nomodule',
    'novalidate',
    'open',
    'playsinline',
    'readonly',
    'required',
    'reversed',
    'selected'
]);

const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter
function spread(args, classes_to_add) {
    const attributes = Object.assign({}, ...args);
    if (classes_to_add) {
        if (attributes.class == null) {
            attributes.class = classes_to_add;
        }
        else {
            attributes.class += ' ' + classes_to_add;
        }
    }
    let str = '';
    Object.keys(attributes).forEach(name => {
        if (invalid_attribute_name_character.test(name))
            return;
        const value = attributes[name];
        if (value === true)
            str += ' ' + name;
        else if (boolean_attributes.has(name.toLowerCase())) {
            if (value)
                str += ' ' + name;
        }
        else if (value != null) {
            str += ` ${name}="${value}"`;
        }
    });
    return str;
}
const escaped = {
    '"': '&quot;',
    "'": '&#39;',
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
};
function escape(html) {
    return String(html).replace(/["'&<>]/g, match => escaped[match]);
}
function escape_attribute_value(value) {
    return typeof value === 'string' ? escape(value) : value;
}
function escape_object(obj) {
    const result = {};
    for (const key in obj) {
        result[key] = escape_attribute_value(obj[key]);
    }
    return result;
}
function each(items, fn) {
    let str = '';
    for (let i = 0; i < items.length; i += 1) {
        str += fn(items[i], i);
    }
    return str;
}
const missing_component = {
    $$render: () => ''
};
function validate_component(component, name) {
    if (!component || !component.$$render) {
        if (name === 'svelte:component')
            name += ' this={...}';
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
    }
    return component;
}
function debug(file, line, column, values) {
    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
    console.log(values); // eslint-disable-line no-console
    return '';
}
let on_destroy;
function create_ssr_component(fn) {
    function $$render(result, props, bindings, slots, context) {
        const parent_component = current_component;
        const $$ = {
            on_destroy,
            context: new Map(context || (parent_component ? parent_component.$$.context : [])),
            // these will be immediately discarded
            on_mount: [],
            before_update: [],
            after_update: [],
            callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
    }
    return {
        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
            on_destroy = [];
            const result = { title: '', head: '', css: new Set() };
            const html = $$render(result, props, {}, $$slots, context);
            run_all(on_destroy);
            return {
                html,
                css: {
                    code: Array.from(result.css).map(css => css.code).join('\n'),
                    map: null // TODO
                },
                head: result.title + result.head
            };
        },
        $$render
    };
}
function add_attribute(name, value, boolean) {
    if (value == null || (boolean && !value))
        return '';
    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function add_classes(classes) {
    return classes ? ` class="${classes}"` : '';
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function claim_component(block, parent_nodes) {
    block && block.l(parent_nodes);
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            start_hydrating();
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        end_hydrating();
        flush();
    }
    set_current_component(parent_component);
}
let SvelteElement;
if (typeof HTMLElement === 'function') {
    SvelteElement = class extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
        }
        connectedCallback() {
            const { on_mount } = this.$$;
            this.$$.on_disconnect = on_mount.map(run).filter(is_function);
            // @ts-ignore todo: improve typings
            for (const key in this.$$.slotted) {
                // @ts-ignore todo: improve typings
                this.appendChild(this.$$.slotted[key]);
            }
        }
        attributeChangedCallback(attr, _oldValue, newValue) {
            this[attr] = newValue;
        }
        disconnectedCallback() {
            run_all(this.$$.on_disconnect);
        }
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            // TODO should this delegate to addEventListener?
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    };
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.43.1' }, detail), true));
}
function append_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append(target, node);
}
function append_hydration_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append_hydration(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert(target, node, anchor);
}
function insert_hydration_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert_hydration(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev('SvelteDOMRemove', { node });
    detach(node);
}
function detach_between_dev(before, after) {
    while (before.nextSibling && before.nextSibling !== after) {
        detach_dev(before.nextSibling);
    }
}
function detach_before_dev(after) {
    while (after.previousSibling) {
        detach_dev(after.previousSibling);
    }
}
function detach_after_dev(before) {
    while (before.nextSibling) {
        detach_dev(before.nextSibling);
    }
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
    else
        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}
function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev('SvelteDOMSetProperty', { node, property, value });
}
function dataset_dev(node, property, value) {
    node.dataset[property] = value;
    dispatch_dev('SvelteDOMSetDataset', { node, property, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    dispatch_dev('SvelteDOMSetData', { node: text, data });
    text.data = data;
}
function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';
        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
            msg += ' You can use a spread to convert this iterable into an array.';
        }
        throw new Error(msg);
    }
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error("'target' is a required option");
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}
/**
 * Base class to create strongly typed Svelte components.
 * This only exists for typing purposes and should be used in `.d.ts` files.
 *
 * ### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponentTyped } from "svelte";
 * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 *
 * #### Why not make this part of `SvelteComponent(Dev)`?
 * Because
 * ```ts
 * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
 * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
 * ```
 * will throw a type error, so we need to separate the more strictly typed class.
 */
class SvelteComponentTyped extends SvelteComponentDev {
    constructor(options) {
        super(options);
    }
}
function loop_guard(timeout) {
    const start = Date.now();
    return () => {
        if (Date.now() - start > timeout) {
            throw new Error('Infinite loop detected');
        }
    };
}




/***/ }),

/***/ "./node_modules/svelte/transition/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/svelte/transition/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "blur": () => (/* binding */ blur),
/* harmony export */   "crossfade": () => (/* binding */ crossfade),
/* harmony export */   "draw": () => (/* binding */ draw),
/* harmony export */   "fade": () => (/* binding */ fade),
/* harmony export */   "fly": () => (/* binding */ fly),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "slide": () => (/* binding */ slide)
/* harmony export */ });
/* harmony import */ var _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../easing/index.mjs */ "./node_modules/svelte/easing/index.mjs");
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");



/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function blur(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicInOut, amount = 5, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const f = style.filter === 'none' ? '' : style.filter;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * amount}px);`
    };
}
function fade(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.linear } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut } = {}) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => 'overflow: hidden;' +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}
function scale(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut, start = 0, opacity = 0 } = {}) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const sd = 1 - start;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
    };
}
function draw(node, { delay = 0, speed, duration, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicInOut } = {}) {
    let len = node.getTotalLength();
    const style = getComputedStyle(node);
    if (style.strokeLinecap !== 'butt') {
        len += parseInt(style.strokeWidth);
    }
    if (duration === undefined) {
        if (speed === undefined) {
            duration = 800;
        }
        else {
            duration = len / speed;
        }
    }
    else if (typeof duration === 'function') {
        duration = duration(len);
    }
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`
    };
}
function crossfade(_a) {
    var { fallback } = _a, defaults = __rest(_a, ["fallback"]);
    const to_receive = new Map();
    const to_send = new Map();
    function crossfade(from, node, params) {
        const { delay = 0, duration = d => Math.sqrt(d) * 30, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut } = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, defaults), params);
        const to = node.getBoundingClientRect();
        const dx = from.left - to.left;
        const dy = from.top - to.top;
        const dw = from.width / to.width;
        const dh = from.height / to.height;
        const d = Math.sqrt(dx * dx + dy * dy);
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const opacity = +style.opacity;
        return {
            delay,
            duration: (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.is_function)(duration) ? duration(d) : duration,
            easing,
            css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`
        };
    }
    function transition(items, counterparts, intro) {
        return (node, params) => {
            items.set(params.key, {
                rect: node.getBoundingClientRect()
            });
            return () => {
                if (counterparts.has(params.key)) {
                    const { rect } = counterparts.get(params.key);
                    counterparts.delete(params.key);
                    return crossfade(rect, node, params);
                }
                // if the node is disappearing altogether
                // (i.e. wasn't claimed by the other list)
                // then we need to supply an outro
                items.delete(params.key);
                return fallback && fallback(node, params, intro);
            };
        };
    }
    return [
        transition(to_send, to_receive, false),
        transition(to_receive, to_send, true)
    ];
}




/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/latest-news/block.json":
/*!*********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/latest-news/block.json ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"style":"file:../../../../dist/styles/editor.min.css","name":"gameplayblocks/latest-news","category":"gameplay-mini-blocks","attributes":{"className":{"type":"string"},"content":{"type":"string"}},"supports":{"align":["wide","full"],"anchor":true,"__experimentalColor":{"gradients":true,"linkColor":true}}}');

/***/ }),

/***/ "./resources/scripts/editor/mini-blocks/most-popular/block.json":
/*!**********************************************************************!*\
  !*** ./resources/scripts/editor/mini-blocks/most-popular/block.json ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"style":"file:../../../../dist/styles/editor.min.css","name":"gameplayblocks/most-popular","category":"gameplay-mini-blocks","attributes":{"className":{"type":"string"},"content":{"type":"string"}},"supports":{"align":["wide","full"],"anchor":true,"__experimentalColor":{"gradients":true,"linkColor":true}}}');

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/footer/block.json":
/*!*****************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/footer/block.json ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"style":"file:../../../../dist/styles/editor.min.css","name":"gameplayblocks/footer","category":"gameplay-super-blocks","attributes":{"className":{"type":"string","default":"tw-bg-yellow-200"},"content":{"type":"string"},"currentTheme":{"type":"string","default":"cleanreddredmp"}},"supports":{"align":["wide","full"],"anchor":true,"__experimentalColor":{"gradients":true,"linkColor":true}}}');

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/header/block.json":
/*!*****************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/header/block.json ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"style":"file:../../../../dist/styles/editor.min.css","name":"gameplayblocks/gpheader","category":"gameplay-super-blocks","attributes":{"postsToShow":{"type":"number","default":6}},"supports":{"align":["wide","full"]}}');

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/hero/block.json":
/*!***************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/hero/block.json ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"gameplayblocks/hero","category":"gameplay-super-blocks","attributes":{"className":{"type":"string"},"content":{"type":"string"},"alignment":{"type":"string","default":"none"},"date":{"type":"number","default":"none"},"myRichHeading":{"type":"string"},"myRichText":{"type":"string","source":"html","selector":"p"},"toggle":{"type":"boolean","default":true},"favoriteAnimal":{"type":"string","default":"dogs"},"favoriteColor":{"type":"string","default":"#DDDDDD"},"activateLasers":{"type":"boolean","default":false}},"supports":{"align":["wide","full"],"anchor":true,"__experimentalColor":{"gradients":true,"linkColor":true}},"style":"file:../../../../dist/styles/editor.min.css","editorScript":"file:../../../../dist/editor.min.js"}');

/***/ }),

/***/ "./resources/scripts/editor/super-blocks/main-content/block.json":
/*!***********************************************************************!*\
  !*** ./resources/scripts/editor/super-blocks/main-content/block.json ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"style":"file:../../../../dist/styles/editor.min.css","name":"gameplayblocks/gpmaincontent","category":"gameplay-super-blocks","attributes":{"postsToShow":{"type":"number","default":6},"currentTheme":{"type":"string","default":"cleanreddredmp"}},"supports":{"align":["wide","full"]}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************************************!*\
  !*** ./resources/scripts/editor/index.ts ***!
  \*******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_admin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @styles/admin */ "./resources/styles/admin/index.scss");
/* harmony import */ var _super_blocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./super-blocks */ "./resources/scripts/editor/super-blocks/index.ts");
/* harmony import */ var _mini_blocks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mini-blocks */ "./resources/scripts/editor/mini-blocks/index.ts");
/* harmony import */ var _sbirdThemeBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sbirdThemeBuilder */ "./resources/scripts/editor/sbirdThemeBuilder.tsx");
// eslint-disable-next-line no-unused-vars
// import config from '@config';
 // Uncomment the following line if needed:
// import 'airbnb-browser-shims';
// Your code goes here ...
// Internal dependencies


 // import EditorApp from "./EditorApp.svelte";
//     const App = new EditorApp({
//         target: document.querySelector("body"),
//         props: {}
//     });
// export default App


})();

/******/ })()
;
//# sourceMappingURL=editor.min.js.map